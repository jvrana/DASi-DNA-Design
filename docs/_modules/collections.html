<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>collections &#8212; dasi 0.0.5 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/style.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>



  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.5</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../design.html">Design (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.design</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../models.html">Models (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.models</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../generated/dasi.models.Assembly.html">dasi.models.Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generated/dasi.models.AssemblyNode.html">dasi.models.AssemblyNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generated/dasi.models.Molecule.html">dasi.models.Molecule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generated/dasi.models.MoleculeType.html">dasi.models.MoleculeType</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generated/dasi.models.Reaction.html">dasi.models.Reaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generated/dasi.models.AlignmentGroup.html">dasi.models.AlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generated/dasi.models.AlignmentGroupBase.html">dasi.models.AlignmentGroupBase</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generated/dasi.models.MultiPCRProductAlignmentGroup.html">dasi.models.MultiPCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generated/dasi.models.PCRProductAlignmentGroup.html">dasi.models.PCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generated/dasi.models.AlignmentContainer.html">dasi.models.AlignmentContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generated/dasi.models.AlignmentContainerFactory.html">dasi.models.AlignmentContainerFactory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../models.html#modules">modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../generated/dasi.models.alignment.html">dasi.models.alignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/dasi.models.alignment_container.html">dasi.models.alignment_container</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cost.html">Cost Model (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.cost</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../cost.html#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../generated/dasi.cost.utils.html">dasi.cost.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../command_line.html">Command Line (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.command_line</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">Utilities (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.utils</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../utils.html#utility-modules">Utility modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../generated/dasi.utils.npdf.html">dasi.utils.npdf</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/dasi.utils.region.html">dasi.utils.region</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/dasi.utils.sequence_design.html">dasi.utils.sequence_design</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../utils.html#networkx-utilities">Networkx utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../generated/dasi.utils.networkx.exceptions.html">dasi.utils.networkx.exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/dasi.utils.networkx.shortest_path.html">dasi.utils.networkx.shortest_path</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/dasi.utils.networkx.utils.html">dasi.utils.networkx.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../exceptions.html">Exceptions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.exceptions</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../constants.html">Constants (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.constants</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../schemas/schemas.html">User Parameter Inputs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../schemas/schemas.html#default-cost-parameters">Default Cost Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../schemas/schemas.html#cost-parameter-schema">Cost Parameter Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../schemas/schemas.html#cost-parameters-schema">Cost Parameters Schema</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guidelines.html">Code Guidelines</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for collections</h1><div class="highlight"><pre>
<span></span>&#39;&#39;&#39;This module implements specialized container datatypes providing
alternatives to Python&#39;s general purpose built-in containers, dict,
list, set, and tuple.

* namedtuple   factory function for creating tuple subclasses with named fields
* deque        list-like container with fast appends and pops on either end
* ChainMap     dict-like class for creating a single view of multiple mappings
* Counter      dict subclass for counting hashable objects
* OrderedDict  dict subclass that remembers the order entries were added
* defaultdict  dict subclass that calls a factory function to supply missing values
* UserDict     wrapper around dictionary objects for easier dict subclassing
* UserList     wrapper around list objects for easier list subclassing
* UserString   wrapper around string objects for easier string subclassing

&#39;&#39;&#39;

__all__ = [&#39;deque&#39;, &#39;defaultdict&#39;, &#39;namedtuple&#39;, &#39;UserDict&#39;, &#39;UserList&#39;,
            &#39;UserString&#39;, &#39;Counter&#39;, &#39;OrderedDict&#39;, &#39;ChainMap&#39;]

import _collections_abc
from operator import itemgetter as _itemgetter, eq as _eq
from keyword import iskeyword as _iskeyword
import sys as _sys
import heapq as _heapq
from _weakref import proxy as _proxy
from itertools import repeat as _repeat, chain as _chain, starmap as _starmap
from reprlib import recursive_repr as _recursive_repr

try:
    from _collections import deque
except ImportError:
    pass
else:
    _collections_abc.MutableSequence.register(deque)

try:
    from _collections import defaultdict
except ImportError:
    pass


def __getattr__(name):
    # For backwards compatibility, continue to make the collections ABCs
    # through Python 3.6 available through the collections module.
    # Note, no new collections ABCs were added in Python 3.7
    if name in _collections_abc.__all__:
        obj = getattr(_collections_abc, name)
        import warnings
        warnings.warn(&quot;Using or importing the ABCs from &#39;collections&#39; instead &quot;
                      &quot;of from &#39;collections.abc&#39; is deprecated, &quot;
                      &quot;and in 3.8 it will stop working&quot;,
                      DeprecationWarning, stacklevel=2)
        globals()[name] = obj
        return obj
    raise AttributeError(f&#39;module {__name__!r} has no attribute {name!r}&#39;)

################################################################################
### OrderedDict
################################################################################

class _OrderedDictKeysView(_collections_abc.KeysView):

    def __reversed__(self):
        yield from reversed(self._mapping)

class _OrderedDictItemsView(_collections_abc.ItemsView):

    def __reversed__(self):
        for key in reversed(self._mapping):
            yield (key, self._mapping[key])

class _OrderedDictValuesView(_collections_abc.ValuesView):

    def __reversed__(self):
        for key in reversed(self._mapping):
            yield self._mapping[key]

class _Link(object):
    __slots__ = &#39;prev&#39;, &#39;next&#39;, &#39;key&#39;, &#39;__weakref__&#39;

class OrderedDict(dict):
    &#39;Dictionary that remembers insertion order&#39;
    # An inherited dict maps keys to values.
    # The inherited dict provides __getitem__, __len__, __contains__, and get.
    # The remaining methods are order-aware.
    # Big-O running times for all methods are the same as regular dictionaries.

    # The internal self.__map dict maps keys to links in a doubly linked list.
    # The circular doubly linked list starts and ends with a sentinel element.
    # The sentinel element never gets deleted (this simplifies the algorithm).
    # The sentinel is in self.__hardroot with a weakref proxy in self.__root.
    # The prev links are weakref proxies (to prevent circular references).
    # Individual links are kept alive by the hard reference in self.__map.
    # Those hard references disappear when a key is deleted from an OrderedDict.

    def __init__(*args, **kwds):
        &#39;&#39;&#39;Initialize an ordered dictionary.  The signature is the same as
        regular dictionaries.  Keyword argument order is preserved.
        &#39;&#39;&#39;
        if not args:
            raise TypeError(&quot;descriptor &#39;__init__&#39; of &#39;OrderedDict&#39; object &quot;
                            &quot;needs an argument&quot;)
        self, *args = args
        if len(args) &gt; 1:
            raise TypeError(&#39;expected at most 1 arguments, got %d&#39; % len(args))
        try:
            self.__root
        except AttributeError:
            self.__hardroot = _Link()
            self.__root = root = _proxy(self.__hardroot)
            root.prev = root.next = root
            self.__map = {}
        self.__update(*args, **kwds)

    def __setitem__(self, key, value,
                    dict_setitem=dict.__setitem__, proxy=_proxy, Link=_Link):
        &#39;od.__setitem__(i, y) &lt;==&gt; od[i]=y&#39;
        # Setting a new item creates a new link at the end of the linked list,
        # and the inherited dictionary is updated with the new key/value pair.
        if key not in self:
            self.__map[key] = link = Link()
            root = self.__root
            last = root.prev
            link.prev, link.next, link.key = last, root, key
            last.next = link
            root.prev = proxy(link)
        dict_setitem(self, key, value)

    def __delitem__(self, key, dict_delitem=dict.__delitem__):
        &#39;od.__delitem__(y) &lt;==&gt; del od[y]&#39;
        # Deleting an existing item uses self.__map to find the link which gets
        # removed by updating the links in the predecessor and successor nodes.
        dict_delitem(self, key)
        link = self.__map.pop(key)
        link_prev = link.prev
        link_next = link.next
        link_prev.next = link_next
        link_next.prev = link_prev
        link.prev = None
        link.next = None

    def __iter__(self):
        &#39;od.__iter__() &lt;==&gt; iter(od)&#39;
        # Traverse the linked list in order.
        root = self.__root
        curr = root.next
        while curr is not root:
            yield curr.key
            curr = curr.next

    def __reversed__(self):
        &#39;od.__reversed__() &lt;==&gt; reversed(od)&#39;
        # Traverse the linked list in reverse order.
        root = self.__root
        curr = root.prev
        while curr is not root:
            yield curr.key
            curr = curr.prev

    def clear(self):
        &#39;od.clear() -&gt; None.  Remove all items from od.&#39;
        root = self.__root
        root.prev = root.next = root
        self.__map.clear()
        dict.clear(self)

    def popitem(self, last=True):
        &#39;&#39;&#39;Remove and return a (key, value) pair from the dictionary.

        Pairs are returned in LIFO order if last is true or FIFO order if false.
        &#39;&#39;&#39;
        if not self:
            raise KeyError(&#39;dictionary is empty&#39;)
        root = self.__root
        if last:
            link = root.prev
            link_prev = link.prev
            link_prev.next = root
            root.prev = link_prev
        else:
            link = root.next
            link_next = link.next
            root.next = link_next
            link_next.prev = root
        key = link.key
        del self.__map[key]
        value = dict.pop(self, key)
        return key, value

    def move_to_end(self, key, last=True):
        &#39;&#39;&#39;Move an existing element to the end (or beginning if last is false).

        Raise KeyError if the element does not exist.
        &#39;&#39;&#39;
        link = self.__map[key]
        link_prev = link.prev
        link_next = link.next
        soft_link = link_next.prev
        link_prev.next = link_next
        link_next.prev = link_prev
        root = self.__root
        if last:
            last = root.prev
            link.prev = last
            link.next = root
            root.prev = soft_link
            last.next = link
        else:
            first = root.next
            link.prev = root
            link.next = first
            first.prev = soft_link
            root.next = link

    def __sizeof__(self):
        sizeof = _sys.getsizeof
        n = len(self) + 1                       # number of links including root
        size = sizeof(self.__dict__)            # instance dictionary
        size += sizeof(self.__map) * 2          # internal dict and inherited dict
        size += sizeof(self.__hardroot) * n     # link objects
        size += sizeof(self.__root) * n         # proxy objects
        return size

    update = __update = _collections_abc.MutableMapping.update

    def keys(self):
        &quot;D.keys() -&gt; a set-like object providing a view on D&#39;s keys&quot;
        return _OrderedDictKeysView(self)

    def items(self):
        &quot;D.items() -&gt; a set-like object providing a view on D&#39;s items&quot;
        return _OrderedDictItemsView(self)

    def values(self):
        &quot;D.values() -&gt; an object providing a view on D&#39;s values&quot;
        return _OrderedDictValuesView(self)

    __ne__ = _collections_abc.MutableMapping.__ne__

    __marker = object()

    def pop(self, key, default=__marker):
        &#39;&#39;&#39;od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding
        value.  If key is not found, d is returned if given, otherwise KeyError
        is raised.

        &#39;&#39;&#39;
        if key in self:
            result = self[key]
            del self[key]
            return result
        if default is self.__marker:
            raise KeyError(key)
        return default

    def setdefault(self, key, default=None):
        &#39;&#39;&#39;Insert key with a value of default if key is not in the dictionary.

        Return the value for key if key is in the dictionary, else default.
        &#39;&#39;&#39;
        if key in self:
            return self[key]
        self[key] = default
        return default

    @_recursive_repr()
    def __repr__(self):
        &#39;od.__repr__() &lt;==&gt; repr(od)&#39;
        if not self:
            return &#39;%s()&#39; % (self.__class__.__name__,)
        return &#39;%s(%r)&#39; % (self.__class__.__name__, list(self.items()))

    def __reduce__(self):
        &#39;Return state information for pickling&#39;
        inst_dict = vars(self).copy()
        for k in vars(OrderedDict()):
            inst_dict.pop(k, None)
        return self.__class__, (), inst_dict or None, None, iter(self.items())

    def copy(self):
        &#39;od.copy() -&gt; a shallow copy of od&#39;
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        &#39;&#39;&#39;Create a new ordered dictionary with keys from iterable and values set to value.
        &#39;&#39;&#39;
        self = cls()
        for key in iterable:
            self[key] = value
        return self

    def __eq__(self, other):
        &#39;&#39;&#39;od.__eq__(y) &lt;==&gt; od==y.  Comparison to another OD is order-sensitive
        while comparison to a regular mapping is order-insensitive.

        &#39;&#39;&#39;
        if isinstance(other, OrderedDict):
            return dict.__eq__(self, other) and all(map(_eq, self, other))
        return dict.__eq__(self, other)


try:
    from _collections import OrderedDict
except ImportError:
    # Leave the pure Python version in place.
    pass


################################################################################
### namedtuple
################################################################################

_nt_itemgetters = {}

def namedtuple(typename, field_names, *, rename=False, defaults=None, module=None):
    &quot;&quot;&quot;Returns a new subclass of tuple with named fields.

    &gt;&gt;&gt; Point = namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])
    &gt;&gt;&gt; Point.__doc__                   # docstring for the new class
    &#39;Point(x, y)&#39;
    &gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords
    &gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple
    33
    &gt;&gt;&gt; x, y = p                        # unpack like a regular tuple
    &gt;&gt;&gt; x, y
    (11, 22)
    &gt;&gt;&gt; p.x + p.y                       # fields also accessible by name
    33
    &gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary
    &gt;&gt;&gt; d[&#39;x&#39;]
    11
    &gt;&gt;&gt; Point(**d)                      # convert from a dictionary
    Point(x=11, y=22)
    &gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields
    Point(x=100, y=22)

    &quot;&quot;&quot;

    # Validate the field names.  At the user&#39;s option, either generate an error
    # message or automatically replace the field name with a valid name.
    if isinstance(field_names, str):
        field_names = field_names.replace(&#39;,&#39;, &#39; &#39;).split()
    field_names = list(map(str, field_names))
    typename = _sys.intern(str(typename))

    if rename:
        seen = set()
        for index, name in enumerate(field_names):
            if (not name.isidentifier()
                or _iskeyword(name)
                or name.startswith(&#39;_&#39;)
                or name in seen):
                field_names[index] = f&#39;_{index}&#39;
            seen.add(name)

    for name in [typename] + field_names:
        if type(name) is not str:
            raise TypeError(&#39;Type names and field names must be strings&#39;)
        if not name.isidentifier():
            raise ValueError(&#39;Type names and field names must be valid &#39;
                             f&#39;identifiers: {name!r}&#39;)
        if _iskeyword(name):
            raise ValueError(&#39;Type names and field names cannot be a &#39;
                             f&#39;keyword: {name!r}&#39;)

    seen = set()
    for name in field_names:
        if name.startswith(&#39;_&#39;) and not rename:
            raise ValueError(&#39;Field names cannot start with an underscore: &#39;
                             f&#39;{name!r}&#39;)
        if name in seen:
            raise ValueError(f&#39;Encountered duplicate field name: {name!r}&#39;)
        seen.add(name)

    field_defaults = {}
    if defaults is not None:
        defaults = tuple(defaults)
        if len(defaults) &gt; len(field_names):
            raise TypeError(&#39;Got more default values than field names&#39;)
        field_defaults = dict(reversed(list(zip(reversed(field_names),
                                                reversed(defaults)))))

    # Variables used in the methods and docstrings
    field_names = tuple(map(_sys.intern, field_names))
    num_fields = len(field_names)
    arg_list = repr(field_names).replace(&quot;&#39;&quot;, &quot;&quot;)[1:-1]
    repr_fmt = &#39;(&#39; + &#39;, &#39;.join(f&#39;{name}=%r&#39; for name in field_names) + &#39;)&#39;
    tuple_new = tuple.__new__
    _len = len

    # Create all the named tuple methods to be added to the class namespace

    s = f&#39;def __new__(_cls, {arg_list}): return _tuple_new(_cls, ({arg_list}))&#39;
    namespace = {&#39;_tuple_new&#39;: tuple_new, &#39;__name__&#39;: f&#39;namedtuple_{typename}&#39;}
    # Note: exec() has the side-effect of interning the field names
    exec(s, namespace)
    __new__ = namespace[&#39;__new__&#39;]
    __new__.__doc__ = f&#39;Create new instance of {typename}({arg_list})&#39;
    if defaults is not None:
        __new__.__defaults__ = defaults

    @classmethod
    def _make(cls, iterable):
        result = tuple_new(cls, iterable)
        if _len(result) != num_fields:
            raise TypeError(f&#39;Expected {num_fields} arguments, got {len(result)}&#39;)
        return result

    _make.__func__.__doc__ = (f&#39;Make a new {typename} object from a sequence &#39;
                              &#39;or iterable&#39;)

    def _replace(_self, **kwds):
        result = _self._make(map(kwds.pop, field_names, _self))
        if kwds:
            raise ValueError(f&#39;Got unexpected field names: {list(kwds)!r}&#39;)
        return result

    _replace.__doc__ = (f&#39;Return a new {typename} object replacing specified &#39;
                        &#39;fields with new values&#39;)

    def __repr__(self):
        &#39;Return a nicely formatted representation string&#39;
        return self.__class__.__name__ + repr_fmt % self

    def _asdict(self):
        &#39;Return a new OrderedDict which maps field names to their values.&#39;
        return OrderedDict(zip(self._fields, self))

    def __getnewargs__(self):
        &#39;Return self as a plain tuple.  Used by copy and pickle.&#39;
        return tuple(self)

    # Modify function metadata to help with introspection and debugging

    for method in (__new__, _make.__func__, _replace,
                   __repr__, _asdict, __getnewargs__):
        method.__qualname__ = f&#39;{typename}.{method.__name__}&#39;

    # Build-up the class namespace dictionary
    # and use type() to build the result class
    class_namespace = {
        &#39;__doc__&#39;: f&#39;{typename}({arg_list})&#39;,
        &#39;__slots__&#39;: (),
        &#39;_fields&#39;: field_names,
        &#39;_fields_defaults&#39;: field_defaults,
        &#39;__new__&#39;: __new__,
        &#39;_make&#39;: _make,
        &#39;_replace&#39;: _replace,
        &#39;__repr__&#39;: __repr__,
        &#39;_asdict&#39;: _asdict,
        &#39;__getnewargs__&#39;: __getnewargs__,
    }
    cache = _nt_itemgetters
    for index, name in enumerate(field_names):
        try:
            itemgetter_object, doc = cache[index]
        except KeyError:
            itemgetter_object = _itemgetter(index)
            doc = f&#39;Alias for field number {index}&#39;
            cache[index] = itemgetter_object, doc
        class_namespace[name] = property(itemgetter_object, doc=doc)

    result = type(typename, (tuple,), class_namespace)

    # For pickling to work, the __module__ variable needs to be set to the frame
    # where the named tuple is created.  Bypass this step in environments where
    # sys._getframe is not defined (Jython for example) or sys._getframe is not
    # defined for arguments greater than 0 (IronPython), or where the user has
    # specified a particular module.
    if module is None:
        try:
            module = _sys._getframe(1).f_globals.get(&#39;__name__&#39;, &#39;__main__&#39;)
        except (AttributeError, ValueError):
            pass
    if module is not None:
        result.__module__ = module

    return result


########################################################################
###  Counter
########################################################################

def _count_elements(mapping, iterable):
    &#39;Tally elements from the iterable.&#39;
    mapping_get = mapping.get
    for elem in iterable:
        mapping[elem] = mapping_get(elem, 0) + 1

try:                                    # Load C helper function if available
    from _collections import _count_elements
except ImportError:
    pass

class Counter(dict):
    &#39;&#39;&#39;Dict subclass for counting hashable items.  Sometimes called a bag
    or multiset.  Elements are stored as dictionary keys and their counts
    are stored as dictionary values.

    &gt;&gt;&gt; c = Counter(&#39;abcdeabcdabcaba&#39;)  # count elements from a string

    &gt;&gt;&gt; c.most_common(3)                # three most common elements
    [(&#39;a&#39;, 5), (&#39;b&#39;, 4), (&#39;c&#39;, 3)]
    &gt;&gt;&gt; sorted(c)                       # list all unique elements
    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
    &gt;&gt;&gt; &#39;&#39;.join(sorted(c.elements()))   # list elements with repetitions
    &#39;aaaaabbbbcccdde&#39;
    &gt;&gt;&gt; sum(c.values())                 # total of all counts
    15

    &gt;&gt;&gt; c[&#39;a&#39;]                          # count of letter &#39;a&#39;
    5
    &gt;&gt;&gt; for elem in &#39;shazam&#39;:           # update counts from an iterable
    ...     c[elem] += 1                # by adding 1 to each element&#39;s count
    &gt;&gt;&gt; c[&#39;a&#39;]                          # now there are seven &#39;a&#39;
    7
    &gt;&gt;&gt; del c[&#39;b&#39;]                      # remove all &#39;b&#39;
    &gt;&gt;&gt; c[&#39;b&#39;]                          # now there are zero &#39;b&#39;
    0

    &gt;&gt;&gt; d = Counter(&#39;simsalabim&#39;)       # make another counter
    &gt;&gt;&gt; c.update(d)                     # add in the second counter
    &gt;&gt;&gt; c[&#39;a&#39;]                          # now there are nine &#39;a&#39;
    9

    &gt;&gt;&gt; c.clear()                       # empty the counter
    &gt;&gt;&gt; c
    Counter()

    Note:  If a count is set to zero or reduced to zero, it will remain
    in the counter until the entry is deleted or the counter is cleared:

    &gt;&gt;&gt; c = Counter(&#39;aaabbc&#39;)
    &gt;&gt;&gt; c[&#39;b&#39;] -= 2                     # reduce the count of &#39;b&#39; by two
    &gt;&gt;&gt; c.most_common()                 # &#39;b&#39; is still in, but its count is zero
    [(&#39;a&#39;, 3), (&#39;c&#39;, 1), (&#39;b&#39;, 0)]

    &#39;&#39;&#39;
    # References:
    #   http://en.wikipedia.org/wiki/Multiset
    #   http://www.gnu.org/software/smalltalk/manual-base/html_node/Bag.html
    #   http://www.demo2s.com/Tutorial/Cpp/0380__set-multiset/Catalog0380__set-multiset.htm
    #   http://code.activestate.com/recipes/259174/
    #   Knuth, TAOCP Vol. II section 4.6.3

    def __init__(*args, **kwds):
        &#39;&#39;&#39;Create a new, empty Counter object.  And if given, count elements
        from an input iterable.  Or, initialize the count from another mapping
        of elements to their counts.

        &gt;&gt;&gt; c = Counter()                           # a new, empty counter
        &gt;&gt;&gt; c = Counter(&#39;gallahad&#39;)                 # a new counter from an iterable
        &gt;&gt;&gt; c = Counter({&#39;a&#39;: 4, &#39;b&#39;: 2})           # a new counter from a mapping
        &gt;&gt;&gt; c = Counter(a=4, b=2)                   # a new counter from keyword args

        &#39;&#39;&#39;
        if not args:
            raise TypeError(&quot;descriptor &#39;__init__&#39; of &#39;Counter&#39; object &quot;
                            &quot;needs an argument&quot;)
        self, *args = args
        if len(args) &gt; 1:
            raise TypeError(&#39;expected at most 1 arguments, got %d&#39; % len(args))
        super(Counter, self).__init__()
        self.update(*args, **kwds)

    def __missing__(self, key):
        &#39;The count of elements not in the Counter is zero.&#39;
        # Needed so that self[missing_item] does not raise KeyError
        return 0

    def most_common(self, n=None):
        &#39;&#39;&#39;List the n most common elements and their counts from the most
        common to the least.  If n is None, then list all element counts.

        &gt;&gt;&gt; Counter(&#39;abcdeabcdabcaba&#39;).most_common(3)
        [(&#39;a&#39;, 5), (&#39;b&#39;, 4), (&#39;c&#39;, 3)]

        &#39;&#39;&#39;
        # Emulate Bag.sortedByCount from Smalltalk
        if n is None:
            return sorted(self.items(), key=_itemgetter(1), reverse=True)
        return _heapq.nlargest(n, self.items(), key=_itemgetter(1))

    def elements(self):
        &#39;&#39;&#39;Iterator over elements repeating each as many times as its count.

        &gt;&gt;&gt; c = Counter(&#39;ABCABC&#39;)
        &gt;&gt;&gt; sorted(c.elements())
        [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C&#39;]

        # Knuth&#39;s example for prime factors of 1836:  2**2 * 3**3 * 17**1
        &gt;&gt;&gt; prime_factors = Counter({2: 2, 3: 3, 17: 1})
        &gt;&gt;&gt; product = 1
        &gt;&gt;&gt; for factor in prime_factors.elements():     # loop over factors
        ...     product *= factor                       # and multiply them
        &gt;&gt;&gt; product
        1836

        Note, if an element&#39;s count has been set to zero or is a negative
        number, elements() will ignore it.

        &#39;&#39;&#39;
        # Emulate Bag.do from Smalltalk and Multiset.begin from C++.
        return _chain.from_iterable(_starmap(_repeat, self.items()))

    # Override dict methods where necessary

    @classmethod
    def fromkeys(cls, iterable, v=None):
        # There is no equivalent method for counters because setting v=1
        # means that no element can have a count greater than one.
        raise NotImplementedError(
            &#39;Counter.fromkeys() is undefined.  Use Counter(iterable) instead.&#39;)

    def update(*args, **kwds):
        &#39;&#39;&#39;Like dict.update() but add counts instead of replacing them.

        Source can be an iterable, a dictionary, or another Counter instance.

        &gt;&gt;&gt; c = Counter(&#39;which&#39;)
        &gt;&gt;&gt; c.update(&#39;witch&#39;)           # add elements from another iterable
        &gt;&gt;&gt; d = Counter(&#39;watch&#39;)
        &gt;&gt;&gt; c.update(d)                 # add elements from another counter
        &gt;&gt;&gt; c[&#39;h&#39;]                      # four &#39;h&#39; in which, witch, and watch
        4

        &#39;&#39;&#39;
        # The regular dict.update() operation makes no sense here because the
        # replace behavior results in the some of original untouched counts
        # being mixed-in with all of the other counts for a mismash that
        # doesn&#39;t have a straight-forward interpretation in most counting
        # contexts.  Instead, we implement straight-addition.  Both the inputs
        # and outputs are allowed to contain zero and negative counts.

        if not args:
            raise TypeError(&quot;descriptor &#39;update&#39; of &#39;Counter&#39; object &quot;
                            &quot;needs an argument&quot;)
        self, *args = args
        if len(args) &gt; 1:
            raise TypeError(&#39;expected at most 1 arguments, got %d&#39; % len(args))
        iterable = args[0] if args else None
        if iterable is not None:
            if isinstance(iterable, _collections_abc.Mapping):
                if self:
                    self_get = self.get
                    for elem, count in iterable.items():
                        self[elem] = count + self_get(elem, 0)
                else:
                    super(Counter, self).update(iterable) # fast path when counter is empty
            else:
                _count_elements(self, iterable)
        if kwds:
            self.update(kwds)

    def subtract(*args, **kwds):
        &#39;&#39;&#39;Like dict.update() but subtracts counts instead of replacing them.
        Counts can be reduced below zero.  Both the inputs and outputs are
        allowed to contain zero and negative counts.

        Source can be an iterable, a dictionary, or another Counter instance.

        &gt;&gt;&gt; c = Counter(&#39;which&#39;)
        &gt;&gt;&gt; c.subtract(&#39;witch&#39;)             # subtract elements from another iterable
        &gt;&gt;&gt; c.subtract(Counter(&#39;watch&#39;))    # subtract elements from another counter
        &gt;&gt;&gt; c[&#39;h&#39;]                          # 2 in which, minus 1 in witch, minus 1 in watch
        0
        &gt;&gt;&gt; c[&#39;w&#39;]                          # 1 in which, minus 1 in witch, minus 1 in watch
        -1

        &#39;&#39;&#39;
        if not args:
            raise TypeError(&quot;descriptor &#39;subtract&#39; of &#39;Counter&#39; object &quot;
                            &quot;needs an argument&quot;)
        self, *args = args
        if len(args) &gt; 1:
            raise TypeError(&#39;expected at most 1 arguments, got %d&#39; % len(args))
        iterable = args[0] if args else None
        if iterable is not None:
            self_get = self.get
            if isinstance(iterable, _collections_abc.Mapping):
                for elem, count in iterable.items():
                    self[elem] = self_get(elem, 0) - count
            else:
                for elem in iterable:
                    self[elem] = self_get(elem, 0) - 1
        if kwds:
            self.subtract(kwds)

    def copy(self):
        &#39;Return a shallow copy.&#39;
        return self.__class__(self)

    def __reduce__(self):
        return self.__class__, (dict(self),)

    def __delitem__(self, elem):
        &#39;Like dict.__delitem__() but does not raise KeyError for missing values.&#39;
        if elem in self:
            super().__delitem__(elem)

    def __repr__(self):
        if not self:
            return &#39;%s()&#39; % self.__class__.__name__
        try:
            items = &#39;, &#39;.join(map(&#39;%r: %r&#39;.__mod__, self.most_common()))
            return &#39;%s({%s})&#39; % (self.__class__.__name__, items)
        except TypeError:
            # handle case where values are not orderable
            return &#39;{0}({1!r})&#39;.format(self.__class__.__name__, dict(self))

    # Multiset-style mathematical operations discussed in:
    #       Knuth TAOCP Volume II section 4.6.3 exercise 19
    #       and at http://en.wikipedia.org/wiki/Multiset
    #
    # Outputs guaranteed to only include positive counts.
    #
    # To strip negative and zero counts, add-in an empty counter:
    #       c += Counter()

    def __add__(self, other):
        &#39;&#39;&#39;Add counts from two counters.

        &gt;&gt;&gt; Counter(&#39;abbb&#39;) + Counter(&#39;bcc&#39;)
        Counter({&#39;b&#39;: 4, &#39;c&#39;: 2, &#39;a&#39;: 1})

        &#39;&#39;&#39;
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem, count in self.items():
            newcount = count + other[elem]
            if newcount &gt; 0:
                result[elem] = newcount
        for elem, count in other.items():
            if elem not in self and count &gt; 0:
                result[elem] = count
        return result

    def __sub__(self, other):
        &#39;&#39;&#39; Subtract count, but keep only results with positive counts.

        &gt;&gt;&gt; Counter(&#39;abbbc&#39;) - Counter(&#39;bccd&#39;)
        Counter({&#39;b&#39;: 2, &#39;a&#39;: 1})

        &#39;&#39;&#39;
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem, count in self.items():
            newcount = count - other[elem]
            if newcount &gt; 0:
                result[elem] = newcount
        for elem, count in other.items():
            if elem not in self and count &lt; 0:
                result[elem] = 0 - count
        return result

    def __or__(self, other):
        &#39;&#39;&#39;Union is the maximum of value in either of the input counters.

        &gt;&gt;&gt; Counter(&#39;abbb&#39;) | Counter(&#39;bcc&#39;)
        Counter({&#39;b&#39;: 3, &#39;c&#39;: 2, &#39;a&#39;: 1})

        &#39;&#39;&#39;
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem, count in self.items():
            other_count = other[elem]
            newcount = other_count if count &lt; other_count else count
            if newcount &gt; 0:
                result[elem] = newcount
        for elem, count in other.items():
            if elem not in self and count &gt; 0:
                result[elem] = count
        return result

    def __and__(self, other):
        &#39;&#39;&#39; Intersection is the minimum of corresponding counts.

        &gt;&gt;&gt; Counter(&#39;abbb&#39;) &amp; Counter(&#39;bcc&#39;)
        Counter({&#39;b&#39;: 1})

        &#39;&#39;&#39;
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem, count in self.items():
            other_count = other[elem]
            newcount = count if count &lt; other_count else other_count
            if newcount &gt; 0:
                result[elem] = newcount
        return result

    def __pos__(self):
        &#39;Adds an empty counter, effectively stripping negative and zero counts&#39;
        result = Counter()
        for elem, count in self.items():
            if count &gt; 0:
                result[elem] = count
        return result

    def __neg__(self):
        &#39;&#39;&#39;Subtracts from an empty counter.  Strips positive and zero counts,
        and flips the sign on negative counts.

        &#39;&#39;&#39;
        result = Counter()
        for elem, count in self.items():
            if count &lt; 0:
                result[elem] = 0 - count
        return result

    def _keep_positive(self):
        &#39;&#39;&#39;Internal method to strip elements with a negative or zero count&#39;&#39;&#39;
        nonpositive = [elem for elem, count in self.items() if not count &gt; 0]
        for elem in nonpositive:
            del self[elem]
        return self

    def __iadd__(self, other):
        &#39;&#39;&#39;Inplace add from another counter, keeping only positive counts.

        &gt;&gt;&gt; c = Counter(&#39;abbb&#39;)
        &gt;&gt;&gt; c += Counter(&#39;bcc&#39;)
        &gt;&gt;&gt; c
        Counter({&#39;b&#39;: 4, &#39;c&#39;: 2, &#39;a&#39;: 1})

        &#39;&#39;&#39;
        for elem, count in other.items():
            self[elem] += count
        return self._keep_positive()

    def __isub__(self, other):
        &#39;&#39;&#39;Inplace subtract counter, but keep only results with positive counts.

        &gt;&gt;&gt; c = Counter(&#39;abbbc&#39;)
        &gt;&gt;&gt; c -= Counter(&#39;bccd&#39;)
        &gt;&gt;&gt; c
        Counter({&#39;b&#39;: 2, &#39;a&#39;: 1})

        &#39;&#39;&#39;
        for elem, count in other.items():
            self[elem] -= count
        return self._keep_positive()

    def __ior__(self, other):
        &#39;&#39;&#39;Inplace union is the maximum of value from either counter.

        &gt;&gt;&gt; c = Counter(&#39;abbb&#39;)
        &gt;&gt;&gt; c |= Counter(&#39;bcc&#39;)
        &gt;&gt;&gt; c
        Counter({&#39;b&#39;: 3, &#39;c&#39;: 2, &#39;a&#39;: 1})

        &#39;&#39;&#39;
        for elem, other_count in other.items():
            count = self[elem]
            if other_count &gt; count:
                self[elem] = other_count
        return self._keep_positive()

    def __iand__(self, other):
        &#39;&#39;&#39;Inplace intersection is the minimum of corresponding counts.

        &gt;&gt;&gt; c = Counter(&#39;abbb&#39;)
        &gt;&gt;&gt; c &amp;= Counter(&#39;bcc&#39;)
        &gt;&gt;&gt; c
        Counter({&#39;b&#39;: 1})

        &#39;&#39;&#39;
        for elem, count in self.items():
            other_count = other[elem]
            if other_count &lt; count:
                self[elem] = other_count
        return self._keep_positive()


########################################################################
###  ChainMap
########################################################################

class ChainMap(_collections_abc.MutableMapping):
    &#39;&#39;&#39; A ChainMap groups multiple dicts (or other mappings) together
    to create a single, updateable view.

    The underlying mappings are stored in a list.  That list is public and can
    be accessed or updated using the *maps* attribute.  There is no other
    state.

    Lookups search the underlying mappings successively until a key is found.
    In contrast, writes, updates, and deletions only operate on the first
    mapping.

    &#39;&#39;&#39;

    def __init__(self, *maps):
        &#39;&#39;&#39;Initialize a ChainMap by setting *maps* to the given mappings.
        If no mappings are provided, a single empty dictionary is used.

        &#39;&#39;&#39;
        self.maps = list(maps) or [{}]          # always at least one map

    def __missing__(self, key):
        raise KeyError(key)

    def __getitem__(self, key):
        for mapping in self.maps:
            try:
                return mapping[key]             # can&#39;t use &#39;key in mapping&#39; with defaultdict
            except KeyError:
                pass
        return self.__missing__(key)            # support subclasses that define __missing__

    def get(self, key, default=None):
        return self[key] if key in self else default

    def __len__(self):
        return len(set().union(*self.maps))     # reuses stored hash values if possible

    def __iter__(self):
        d = {}
        for mapping in reversed(self.maps):
            d.update(mapping)                   # reuses stored hash values if possible
        return iter(d)

    def __contains__(self, key):
        return any(key in m for m in self.maps)

    def __bool__(self):
        return any(self.maps)

    @_recursive_repr()
    def __repr__(self):
        return &#39;{0.__class__.__name__}({1})&#39;.format(
            self, &#39;, &#39;.join(map(repr, self.maps)))

    @classmethod
    def fromkeys(cls, iterable, *args):
        &#39;Create a ChainMap with a single dict created from the iterable.&#39;
        return cls(dict.fromkeys(iterable, *args))

    def copy(self):
        &#39;New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]&#39;
        return self.__class__(self.maps[0].copy(), *self.maps[1:])

    __copy__ = copy

    def new_child(self, m=None):                # like Django&#39;s Context.push()
        &#39;&#39;&#39;New ChainMap with a new map followed by all previous maps.
        If no map is provided, an empty dict is used.
        &#39;&#39;&#39;
        if m is None:
            m = {}
        return self.__class__(m, *self.maps)

    @property
    def parents(self):                          # like Django&#39;s Context.pop()
        &#39;New ChainMap from maps[1:].&#39;
        return self.__class__(*self.maps[1:])

    def __setitem__(self, key, value):
        self.maps[0][key] = value

    def __delitem__(self, key):
        try:
            del self.maps[0][key]
        except KeyError:
            raise KeyError(&#39;Key not found in the first mapping: {!r}&#39;.format(key))

    def popitem(self):
        &#39;Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.&#39;
        try:
            return self.maps[0].popitem()
        except KeyError:
            raise KeyError(&#39;No keys found in the first mapping.&#39;)

    def pop(self, key, *args):
        &#39;Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].&#39;
        try:
            return self.maps[0].pop(key, *args)
        except KeyError:
            raise KeyError(&#39;Key not found in the first mapping: {!r}&#39;.format(key))

    def clear(self):
        &#39;Clear maps[0], leaving maps[1:] intact.&#39;
        self.maps[0].clear()


################################################################################
### UserDict
################################################################################

class UserDict(_collections_abc.MutableMapping):

    # Start by filling-out the abstract methods
    def __init__(*args, **kwargs):
        if not args:
            raise TypeError(&quot;descriptor &#39;__init__&#39; of &#39;UserDict&#39; object &quot;
                            &quot;needs an argument&quot;)
        self, *args = args
        if len(args) &gt; 1:
            raise TypeError(&#39;expected at most 1 arguments, got %d&#39; % len(args))
        if args:
            dict = args[0]
        elif &#39;dict&#39; in kwargs:
            dict = kwargs.pop(&#39;dict&#39;)
            import warnings
            warnings.warn(&quot;Passing &#39;dict&#39; as keyword argument is deprecated&quot;,
                          DeprecationWarning, stacklevel=2)
        else:
            dict = None
        self.data = {}
        if dict is not None:
            self.update(dict)
        if len(kwargs):
            self.update(kwargs)
    def __len__(self): return len(self.data)
    def __getitem__(self, key):
        if key in self.data:
            return self.data[key]
        if hasattr(self.__class__, &quot;__missing__&quot;):
            return self.__class__.__missing__(self, key)
        raise KeyError(key)
    def __setitem__(self, key, item): self.data[key] = item
    def __delitem__(self, key): del self.data[key]
    def __iter__(self):
        return iter(self.data)

    # Modify __contains__ to work correctly when __missing__ is present
    def __contains__(self, key):
        return key in self.data

    # Now, add the methods in dicts but not in MutableMapping
    def __repr__(self): return repr(self.data)
    def copy(self):
        if self.__class__ is UserDict:
            return UserDict(self.data.copy())
        import copy
        data = self.data
        try:
            self.data = {}
            c = copy.copy(self)
        finally:
            self.data = data
        c.update(self)
        return c
    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
        return d



################################################################################
### UserList
################################################################################

class UserList(_collections_abc.MutableSequence):
    &quot;&quot;&quot;A more or less complete user-defined wrapper around list objects.&quot;&quot;&quot;
    def __init__(self, initlist=None):
        self.data = []
        if initlist is not None:
            # XXX should this accept an arbitrary sequence?
            if type(initlist) == type(self.data):
                self.data[:] = initlist
            elif isinstance(initlist, UserList):
                self.data[:] = initlist.data[:]
            else:
                self.data = list(initlist)
    def __repr__(self): return repr(self.data)
    def __lt__(self, other): return self.data &lt;  self.__cast(other)
    def __le__(self, other): return self.data &lt;= self.__cast(other)
    def __eq__(self, other): return self.data == self.__cast(other)
    def __gt__(self, other): return self.data &gt;  self.__cast(other)
    def __ge__(self, other): return self.data &gt;= self.__cast(other)
    def __cast(self, other):
        return other.data if isinstance(other, UserList) else other
    def __contains__(self, item): return item in self.data
    def __len__(self): return len(self.data)
    def __getitem__(self, i): return self.data[i]
    def __setitem__(self, i, item): self.data[i] = item
    def __delitem__(self, i): del self.data[i]
    def __add__(self, other):
        if isinstance(other, UserList):
            return self.__class__(self.data + other.data)
        elif isinstance(other, type(self.data)):
            return self.__class__(self.data + other)
        return self.__class__(self.data + list(other))
    def __radd__(self, other):
        if isinstance(other, UserList):
            return self.__class__(other.data + self.data)
        elif isinstance(other, type(self.data)):
            return self.__class__(other + self.data)
        return self.__class__(list(other) + self.data)
    def __iadd__(self, other):
        if isinstance(other, UserList):
            self.data += other.data
        elif isinstance(other, type(self.data)):
            self.data += other
        else:
            self.data += list(other)
        return self
    def __mul__(self, n):
        return self.__class__(self.data*n)
    __rmul__ = __mul__
    def __imul__(self, n):
        self.data *= n
        return self
    def append(self, item): self.data.append(item)
    def insert(self, i, item): self.data.insert(i, item)
    def pop(self, i=-1): return self.data.pop(i)
    def remove(self, item): self.data.remove(item)
    def clear(self): self.data.clear()
    def copy(self): return self.__class__(self)
    def count(self, item): return self.data.count(item)
    def index(self, item, *args): return self.data.index(item, *args)
    def reverse(self): self.data.reverse()
    def sort(self, *args, **kwds): self.data.sort(*args, **kwds)
    def extend(self, other):
        if isinstance(other, UserList):
            self.data.extend(other.data)
        else:
            self.data.extend(other)



################################################################################
### UserString
################################################################################

class UserString(_collections_abc.Sequence):
    def __init__(self, seq):
        if isinstance(seq, str):
            self.data = seq
        elif isinstance(seq, UserString):
            self.data = seq.data[:]
        else:
            self.data = str(seq)
    def __str__(self): return str(self.data)
    def __repr__(self): return repr(self.data)
    def __int__(self): return int(self.data)
    def __float__(self): return float(self.data)
    def __complex__(self): return complex(self.data)
    def __hash__(self): return hash(self.data)
    def __getnewargs__(self):
        return (self.data[:],)

    def __eq__(self, string):
        if isinstance(string, UserString):
            return self.data == string.data
        return self.data == string
    def __lt__(self, string):
        if isinstance(string, UserString):
            return self.data &lt; string.data
        return self.data &lt; string
    def __le__(self, string):
        if isinstance(string, UserString):
            return self.data &lt;= string.data
        return self.data &lt;= string
    def __gt__(self, string):
        if isinstance(string, UserString):
            return self.data &gt; string.data
        return self.data &gt; string
    def __ge__(self, string):
        if isinstance(string, UserString):
            return self.data &gt;= string.data
        return self.data &gt;= string

    def __contains__(self, char):
        if isinstance(char, UserString):
            char = char.data
        return char in self.data

    def __len__(self): return len(self.data)
    def __getitem__(self, index): return self.__class__(self.data[index])
    def __add__(self, other):
        if isinstance(other, UserString):
            return self.__class__(self.data + other.data)
        elif isinstance(other, str):
            return self.__class__(self.data + other)
        return self.__class__(self.data + str(other))
    def __radd__(self, other):
        if isinstance(other, str):
            return self.__class__(other + self.data)
        return self.__class__(str(other) + self.data)
    def __mul__(self, n):
        return self.__class__(self.data*n)
    __rmul__ = __mul__
    def __mod__(self, args):
        return self.__class__(self.data % args)
    def __rmod__(self, format):
        return self.__class__(format % args)

    # the following methods are defined in alphabetical order:
    def capitalize(self): return self.__class__(self.data.capitalize())
    def casefold(self):
        return self.__class__(self.data.casefold())
    def center(self, width, *args):
        return self.__class__(self.data.center(width, *args))
    def count(self, sub, start=0, end=_sys.maxsize):
        if isinstance(sub, UserString):
            sub = sub.data
        return self.data.count(sub, start, end)
    def encode(self, encoding=None, errors=None): # XXX improve this?
        if encoding:
            if errors:
                return self.__class__(self.data.encode(encoding, errors))
            return self.__class__(self.data.encode(encoding))
        return self.__class__(self.data.encode())
    def endswith(self, suffix, start=0, end=_sys.maxsize):
        return self.data.endswith(suffix, start, end)
    def expandtabs(self, tabsize=8):
        return self.__class__(self.data.expandtabs(tabsize))
    def find(self, sub, start=0, end=_sys.maxsize):
        if isinstance(sub, UserString):
            sub = sub.data
        return self.data.find(sub, start, end)
    def format(self, *args, **kwds):
        return self.data.format(*args, **kwds)
    def format_map(self, mapping):
        return self.data.format_map(mapping)
    def index(self, sub, start=0, end=_sys.maxsize):
        return self.data.index(sub, start, end)
    def isalpha(self): return self.data.isalpha()
    def isalnum(self): return self.data.isalnum()
    def isascii(self): return self.data.isascii()
    def isdecimal(self): return self.data.isdecimal()
    def isdigit(self): return self.data.isdigit()
    def isidentifier(self): return self.data.isidentifier()
    def islower(self): return self.data.islower()
    def isnumeric(self): return self.data.isnumeric()
    def isprintable(self): return self.data.isprintable()
    def isspace(self): return self.data.isspace()
    def istitle(self): return self.data.istitle()
    def isupper(self): return self.data.isupper()
    def join(self, seq): return self.data.join(seq)
    def ljust(self, width, *args):
        return self.__class__(self.data.ljust(width, *args))
    def lower(self): return self.__class__(self.data.lower())
    def lstrip(self, chars=None): return self.__class__(self.data.lstrip(chars))
    maketrans = str.maketrans
    def partition(self, sep):
        return self.data.partition(sep)
    def replace(self, old, new, maxsplit=-1):
        if isinstance(old, UserString):
            old = old.data
        if isinstance(new, UserString):
            new = new.data
        return self.__class__(self.data.replace(old, new, maxsplit))
    def rfind(self, sub, start=0, end=_sys.maxsize):
        if isinstance(sub, UserString):
            sub = sub.data
        return self.data.rfind(sub, start, end)
    def rindex(self, sub, start=0, end=_sys.maxsize):
        return self.data.rindex(sub, start, end)
    def rjust(self, width, *args):
        return self.__class__(self.data.rjust(width, *args))
    def rpartition(self, sep):
        return self.data.rpartition(sep)
    def rstrip(self, chars=None):
        return self.__class__(self.data.rstrip(chars))
    def split(self, sep=None, maxsplit=-1):
        return self.data.split(sep, maxsplit)
    def rsplit(self, sep=None, maxsplit=-1):
        return self.data.rsplit(sep, maxsplit)
    def splitlines(self, keepends=False): return self.data.splitlines(keepends)
    def startswith(self, prefix, start=0, end=_sys.maxsize):
        return self.data.startswith(prefix, start, end)
    def strip(self, chars=None): return self.__class__(self.data.strip(chars))
    def swapcase(self): return self.__class__(self.data.swapcase())
    def title(self): return self.__class__(self.data.title())
    def translate(self, *args):
        return self.__class__(self.data.translate(*args))
    def upper(self): return self.__class__(self.data.upper())
    def zfill(self, width): return self.__class__(self.data.zfill(width))
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>