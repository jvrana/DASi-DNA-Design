<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.alignments.alignment_container &#8212; dasi 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>
    


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/api_reference.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../developer/api_reference.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for dasi.alignments.alignment_container</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;
Alignment container
&quot;&quot;&quot;

from .alignment import Alignment, AlignmentGroup, ComplexAlignmentGroup
from dasi.log import logger
from dasi.utils import Region, bisect_slice_between, sort_with_keys
from dasi.constants import Constants
from dasi.exceptions import AlignmentContainerException
from more_itertools import partition, unique_everseen, flatten
from typing import Dict, List
from Bio.SeqRecord import SeqRecord
from bisect import bisect_left
from copy import deepcopy
from collections.abc import Sized
from uuid import uuid4


<div class="viewcode-block" id="blast_to_region"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.blast_to_region">[docs]</a>def blast_to_region(query_or_subject, seqdb):
    &quot;&quot;&quot;
    Converts a blast data result to a Region. Blast
    results are indicated by two positions with index starting
    at 1 and positions being inclusive. This returns a Region
    with index starting at 0 and the end point position being
    exclusive.

    :param query_or_subject:
    :type query_or_subject:
    :param seqdb:
    :type seqdb:
    :return:
    :rtype:
    &quot;&quot;&quot;
    data = query_or_subject
    record = seqdb[data[&quot;origin_key&quot;]]

    s, e = data[&quot;start&quot;], data[&quot;end&quot;]
    l = len(record)
    # if data[&#39;circular&#39;] and e &gt; l and data[&#39;length&#39;] == 2 * l:
    #     e -= l
    if data[&quot;strand&quot;] == -1:
        s, e = e, s
    region = Region(
        s - 1,
        e,
        length=l,
        cyclic=data[&quot;circular&quot;],
        direction=data[&quot;strand&quot;],
        index=0,
        name=&quot;{}: {}&quot;.format(record.id, record.name),
        allow_wrap=True,
    )
    return region</div>


<div class="viewcode-block" id="AlignmentContainer"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainer">[docs]</a>class AlignmentContainer(Sized):
    &quot;&quot;&quot;
    Container for a set of query-to-subject alignments for a single query.

    Instance Attributes/Properties:
        alignments  list of alignments for the container
                    List[Alignment]
        seqdb       key to SeqRecord dictionary
                    Dict[str, SeqRecord]
        logger      the instance&#39;s logger
                    Loggable

    This class contains:
        1. Methods grouping alignments together according to those
    alignments that share the same starting and ending points.
        2. Methods for &#39;expanding&#39; alignments
    &quot;&quot;&quot;

    valid_types = (
        Constants.PCR_PRODUCT,
        Constants.PRIMER,
        Constants.FRAGMENT,
        Constants.PCR_PRODUCT_WITH_PRIMERS,
        Constants.PCR_PRODUCT_WITH_LEFT_PRIMER,
        Constants.PCR_PRODUCT_WITH_RIGHT_PRIMER,
        Constants.SHARED_FRAGMENT,
    )  # valid fragment types

    def __init__(self, seqdb: Dict[str, SeqRecord], alignments=None):
        self._alignments = []
        if alignments is not None:
            self.alignments = alignments
        self.seqdb = seqdb
        self.logger = logger(self)

    @property
    def alignments(self):
        return self._alignments

    @alignments.setter
    def alignments(self, v):
        self._alignments = v
        self._check_single_query_key(self._alignments)

    @staticmethod
    def _check_single_query_key(alignments):
        keys = set(a.query_key for a in alignments)
        if len(keys) &gt; 1:
            raise AlignmentContainerException(
                &quot;AlignmentContainer cannot contain more than one query. Contains the following&quot;
                &quot;query keys: {}&quot;.format(keys)
            )

    @classmethod
    def filter_alignments_by_span(
        cls, alignments, region, key=None, end_inclusive=True
    ):
        fwd, fwd_keys = sort_with_keys(alignments, key=key)
        found = []
        for a, b in region.ranges():
            if not end_inclusive:
                b = b - 1
            found += bisect_slice_between(fwd, fwd_keys, a, b)
        return found

    def find_groups_by_pos(self, a, b, groups=None):
        if groups is None:
            groups = self.groups()
        found = []
        for g in groups:
            if g.query_region.a == a and g.query_region.b == b:
                found.append(g)
        return found

    def _create_pcr_product_alignment(
        self,
        template_group: AlignmentGroup,
        fwd: Alignment,
        rev: Alignment,
        alignment_type: str,
    ):
        groups = []
        for a in template_group.alignments:
            alignments = [x for x in [fwd, a, rev] if x is not None]
            self._new_grouping_tag(alignments, alignment_type)
            groups.append(ComplexAlignmentGroup(alignments, alignment_type))
        return groups

<div class="viewcode-block" id="AlignmentContainer.expand_primer_pairs"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainer.expand_primer_pairs">[docs]</a>    def expand_primer_pairs(
        self, alignment_groups: List[AlignmentGroup]
    ) -&gt; List[Alignment]:
        &quot;&quot;&quot;
        Creates new alignments for all possible primer pairs. Searches for fwd and
        rev primer pairs that exist within other alignments and produces all combinations
        of alignments that can form from these primer pairs.

        :return: list
        &quot;&quot;&quot;
        primers = self.get_alignments_by_types(Constants.PRIMER)

        rev, fwd = partition(lambda p: p.subject_region.direction == 1, primers)
        fwd, fwd_keys = sort_with_keys(fwd, key=lambda p: p.query_region.b)
        rev, rev_keys = sort_with_keys(rev, key=lambda p: p.query_region.a)
        pairs = []

        for g in self.logger.tqdm(
            alignment_groups, &quot;INFO&quot;, desc=&quot;Expanding primer pair&quot;
        ):
            query_ranges = g.query_region.ranges()
            fwd_bind_region = g.query_region[Constants.PRIMER_MIN_BIND :]
            rev_bind_region = g.query_region[: -Constants.PRIMER_MIN_BIND]
            fwd_bind = self.filter_alignments_by_span(
                fwd, fwd_bind_region, key=lambda p: p.query_region.b
            )
            rev_bind = self.filter_alignments_by_span(
                rev, rev_bind_region, key=lambda p: p.query_region.a
            )
            rev_bind, rkeys = sort_with_keys(rev_bind, key=lambda p: p.query_region.a)

            # both primers
            for f in fwd_bind:
                _rev_bind = []
                if len(query_ranges) == 1:
                    i = bisect_left(rkeys, f.query_region.a)
                    _rev_bind = rev_bind[i:]
                else:
                    try:
                        _rev_span = g.query_region.sub(
                            f.query_region.a, g.query_region.b
                        )
                    except IndexError:
                        _rev_span = deepcopy(g.query_region)

                    for a, b in _rev_span.ranges():
                        _rev_bind += bisect_slice_between(rev_bind, rkeys, a, b)
                for r in _rev_bind:
                    pairs += self._create_pcr_product_alignment(
                        g, f, r, Constants.PCR_PRODUCT_WITH_PRIMERS
                    )

            # left primer
            for f in fwd_bind:
                pairs += self._create_pcr_product_alignment(
                    g, f, None, Constants.PCR_PRODUCT_WITH_LEFT_PRIMER
                )

            # right primer
            for r in rev_bind:
                pairs += self._create_pcr_product_alignment(
                    g, None, r, Constants.PCR_PRODUCT_WITH_RIGHT_PRIMER
                )
        return pairs</div>

<div class="viewcode-block" id="AlignmentContainer.expand_overlaps"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainer.expand_overlaps">[docs]</a>    def expand_overlaps(
        self, alignment_groups: List[AlignmentGroup], type=Constants.PCR_PRODUCT
    ) -&gt; List[Alignment]:
        &quot;&quot;&quot;
        Expand the list of alignments from existing regions. Produces new fragments in
        the following three situations:

        ::

            |--------|          alignment 1
                |--------|      alignment 2
            |---|               new alignment


            |--------|          alignment 1
                 |--------|     alignment 2
                 |---|          new alignment


            |--------|          alignment 1
                 |--------|     alignment 2
                     |----|     new alignment

        :param alignment_groups:
        :return: list
        &quot;&quot;&quot;

        MIN_OVERLAP = Constants.MIN_OVERLAP
        group_sort, group_keys = sort_with_keys(
            alignment_groups, key=lambda x: x.query_region.a
        )
        alignments = []
        for group_a in logger.tqdm(group_sort, &quot;INFO&quot;, desc=&quot;expanding pcr products&quot;):

            overlapping = self.filter_alignments_by_span(
                group_sort,
                group_a.query_region,
                key=lambda p: p.query_region.a,
                end_inclusive=False,
            )

            for group_b in overlapping:
                if group_b is not group_a:
                    left = group_a.sub_region(
                        group_a.query_region.a, group_b.query_region.a, type
                    )
                    overlap = group_a.sub_region(
                        group_b.query_region.a, group_a.query_region.b, type
                    )
                    # right = group_b.sub_region(group_a.query_region.b, group_b.query_region.b, type)

                    if len(left.query_region) &gt; MIN_OVERLAP:
                        alignments += left.alignments

                    if len(overlap.query_region) &gt; MIN_OVERLAP:
                        alignments += overlap.alignments

                    # if len(right.query_region) &gt; MIN_OVERLAP:
                    #     alignments += right.alignments
        return alignments</div>

    # TODO: break apart long alignments
<div class="viewcode-block" id="AlignmentContainer.expand"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainer.expand">[docs]</a>    def expand(self, expand_overlaps=True, expand_primers=True):
        &quot;&quot;&quot;
        Expand the number of alignments in this container using overlaps or primers.

        :param expand_overlaps:
        :param expand_primers:
        :return:
        &quot;&quot;&quot;

        self.logger.info(&quot;=== Expanding alignments ===&quot;)
        # We annotate any original PCR_PRODUCT with FRAGMENT if they are &#39;perfect_subjects&#39;
        # This means they already exist as pre-made fragments
        self.logger.info(&quot;Number of alignments: {}&quot;.format(len(self.alignments)))

        templates = self.get_groups_by_types(
            [Constants.PCR_PRODUCT, Constants.FRAGMENT]
        )

        if expand_primers:
            pairs = self.expand_primer_pairs(templates)
            self.logger.info(&quot;Number of pairs: {}&quot;.format(len(pairs)))

        if expand_overlaps:
            expanded = self.expand_overlaps(templates)
            self.alignments += expanded
            self.logger.info(&quot;Number of new alignments: {}&quot;.format(len(expanded)))
        self.logger.info(&quot;Number of total alignments: {}&quot;.format(len(self.alignments)))
        self.logger.info(&quot;Number of total groups: {}&quot;.format(len(self.groups())))</div>

<div class="viewcode-block" id="AlignmentContainer._new_grouping_tag"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainer._new_grouping_tag">[docs]</a>    @classmethod
    def _new_grouping_tag(cls, alignments, type: str, key=None):
        &quot;&quot;&quot;
        Make a new ordered grouping by type and a uuid.

        :param alignments:
        :type alignments:
        :param type:
        :type type:
        :param key:
        :type key:
        :return:
        :rtype:
        &quot;&quot;&quot;
        if key is None:
            key = str(uuid4())
        group_key = (key, type)
        for i, a in enumerate(alignments):
            if key in a.grouping_tags:
                raise AlignmentContainerException(
                    &quot;Key &#39;{}&#39; already exists in grouping tag&quot;.format(key)
                )
            a.grouping_tags[group_key] = i</div>

<div class="viewcode-block" id="AlignmentContainer._alignment_hash"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainer._alignment_hash">[docs]</a>    @staticmethod
    def _alignment_hash(a):
        &quot;&quot;&quot;A hashable representation of an alignment for grouping.&quot;&quot;&quot;
        return (a.query_region.a, a.query_region.b, a.query_region.direction, a.type)</div>

    @classmethod
    def complex_alignment_groups(
        cls, alignments: List[Alignment]
    ) -&gt; List[AlignmentGroup]:
        key_to_alignments = {}
        for a in alignments:
            if not isinstance(a, Alignment):
                raise Exception
        for a in alignments:
            for (uuid, type), i in a.grouping_tags.items():
                key_to_alignments.setdefault((uuid, type), list()).append((i, a))
        complex_groups = []
        for (uuid, type), alist in key_to_alignments.items():
            sorted_alist = [x[-1] for x in sorted(alist)]
            complex_groups.append(ComplexAlignmentGroup(sorted_alist, type))
        return complex_groups

<div class="viewcode-block" id="AlignmentContainer.redundent_alignment_groups"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainer.redundent_alignment_groups">[docs]</a>    @classmethod
    def redundent_alignment_groups(
        cls, alignments: List[Alignment]
    ) -&gt; List[AlignmentGroup]:
        &quot;&quot;&quot;
        Return AlignmentGroups that have been grouped by alignment_hash

        :param alignments:
        :return:
        &quot;&quot;&quot;
        grouped = {}
        for a in alignments:
            grouped.setdefault(cls._alignment_hash(a), list()).append(a)
        alignment_groups = []
        for group in grouped.values():
            alignment_groups.append(AlignmentGroup(group, group[0].type))
        return alignment_groups</div>

    def groups(self) -&gt; List[AlignmentGroup]:
        allgroups = []
        allgroups += self.redundent_alignment_groups(self.alignments)
        allgroups += self.complex_alignment_groups(self.alignments)
        return allgroups

    @property
    def types(self) -&gt; List[str]:
        &quot;&quot;&quot;
        Return all valid types.

        :return:
        &quot;&quot;&quot;
        return tuple(self.valid_types)

<div class="viewcode-block" id="AlignmentContainer.get_groups_by_types"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainer.get_groups_by_types">[docs]</a>    def get_groups_by_types(self, types: List[str]) -&gt; List[AlignmentGroup]:
        &quot;&quot;&quot;
        Return AlignmentGroups by fragment type

        :param types: list of types
        :return:
        &quot;&quot;&quot;
        groups = self.groups_by_type
        if isinstance(types, str):
            return groups[types]
        else:
            return list(unique_everseen(flatten([groups[t] for t in types])))</div>

    def get_alignments_by_types(self, types: List[str]) -&gt; List[Alignment]:
        groups = self.get_groups_by_types(types)
        return list(flatten([g.alignments for g in groups]))

    # TODO: change from property
    @property
    def groups_by_type(self) -&gt; Dict[str, AlignmentGroup]:
        &quot;&quot;&quot;
        Return alignment groups according to their alignment &#39;type&#39;

        :return: dict
        &quot;&quot;&quot;
        d = {}
        for t in self.valid_types:
            d[t] = []
        for g in self.groups():
            d[g.type].append(g)
        return d

<div class="viewcode-block" id="AlignmentContainer.freeze"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainer.freeze">[docs]</a>    def freeze(self):
        &quot;&quot;&quot;Freeze the container, disallowing further modifications to alignments&quot;&quot;&quot;
        self._alignments = tuple(self._alignments)</div>

<div class="viewcode-block" id="AlignmentContainer.unfreeze"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainer.unfreeze">[docs]</a>    def unfreeze(self):
        &quot;&quot;&quot;Unfreeze the container, allowing modifications to alignments&quot;&quot;&quot;
        self._alignments = list(self._alignments)</div>

    def __len__(self):
        return len(self.alignments)</div>


<div class="viewcode-block" id="AlignmentContainerFactory"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainerFactory">[docs]</a>class AlignmentContainerFactory(object):
    &quot;&quot;&quot;
    Class that maintains a shared list of alignments and shared sequence database.

    AlignmentContainers can be retrieved in a dict grouped by their query via `.containers()`
    &quot;&quot;&quot;

    valid_types = (
        Constants.PCR_PRODUCT,
        Constants.PRIMER,
        Constants.FRAGMENT,
        Constants.PCR_PRODUCT_WITH_PRIMERS,
        Constants.PCR_PRODUCT_WITH_LEFT_PRIMER,
        Constants.PCR_PRODUCT_WITH_RIGHT_PRIMER,
        Constants.SHARED_FRAGMENT,
    )  # valid fragment types

    def __init__(self, seqdb: Dict[str, SeqRecord]):
        self.alignments = (
            {}
        )  # dictionary of query_key to alignment; Dict[str, List[Alignment]]
        self.logger = logger(self)
        self.seqdb = seqdb

<div class="viewcode-block" id="AlignmentContainerFactory.load_blast_json"><a class="viewcode-back" href="../../../developer/_autosummary/_autosummary/dasi.alignments.alignment_container.html#dasi.alignments.alignment_container.AlignmentContainerFactory.load_blast_json">[docs]</a>    def load_blast_json(self, data: List[Dict], type: str):
        &quot;&quot;&quot;
        Create alignments from a formatted BLAST JSON result.

        :param data: formatted BLAST JSON result
        :param type: the type of alignment to initialize
        :return: None
        &quot;&quot;&quot;
        self.logger.info(
            &#39;Loading blast json ({} entries) to fragment type &quot;{}&quot;&#39;.format(
                len(data), type
            )
        )
        assert type in self.valid_types
        for d in data:
            query_region = blast_to_region(d[&quot;query&quot;], self.seqdb)
            subject_region = blast_to_region(d[&quot;subject&quot;], self.seqdb)
            query_key = d[&quot;query&quot;][&quot;origin_key&quot;]
            subject_key = d[&quot;subject&quot;][&quot;origin_key&quot;]

            alignment = Alignment(
                query_region,
                subject_region,
                type=type,
                query_key=query_key,
                subject_key=subject_key,
            )
            self.alignments.setdefault(query_key, list()).append(alignment)</div>

    def containers(self):
        container_dict = {}
        for key, alignments in self.alignments.items():
            container_dict[key] = AlignmentContainer(self.seqdb, alignments=alignments)
        return container_dict</div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>