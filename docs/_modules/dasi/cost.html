<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.cost &#8212; dasi 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>
    


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          Trident</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Trident <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../developer/api_reference.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../developer/api_reference.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for dasi.cost</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;Cost

.. module:: cost

Submodules
==========

.. autosummary::
    :toctree: _autosummary
&quot;&quot;&quot;

import seaborn as sns
import pylab as plt
import numpy as np
import pandas as pd
from typing import Tuple, Any

# TODO: backtrack options
# TODO: ends that are extendable should also be retractable, meaning if there is a more optimal

class JxnParams(object):

    # jxn_efficiency[30:40] = 0.9&quot; means for 30 &lt;= bp &lt; 40, junction efficiency is 90%
    jxn_efficiency = np.zeros(301, dtype=np.float)
    jxn_efficiency[:10] = 0.0
    jxn_efficiency[10:20] = 0.1
    jxn_efficiency[20:30] = 0.8
    jxn_efficiency[30:40] = 0.9
    jxn_efficiency[40:50] = 0.8
    jxn_efficiency[50:100] = 0.75
    jxn_efficiency[100:120] = 0.5
    jxn_efficiency[120:150] = 0.3
    jxn_efficiency[150:250] = 0.1
    jxn_efficiency[250:300] = 0.0

    min_jxn_span = -300  # the minimum spanning junction we evaluate
    min_anneal = 16  # the minimum annealing of each primer
    primers = np.array(
        [
            [16.0, 60.0, 0.0, 0.3, 1.5],
            [45.0, 200.0, 0.0, 0.8, 2.5],
            [min_anneal, min_anneal + 1, 0.0, 0.0, 0.5],  # special case
        ]
    )
    primer_rows = [&quot;IDTPrimer&quot;, &quot;IDTUltramer&quot;, &quot;NoPrimer(Free)&quot;]
    primer_cols = [&quot;min_bp&quot;, &quot;max_bp&quot;, &quot;base_cost&quot;, &quot;bp_cost&quot;, &quot;time (days)&quot;]

    # sanity check
    assert len(primer_rows) == len(primers)
    assert len(primer_cols) == len(primers[0])


class Slicer(object):
    def __getitem__(self, item):
        return item


slicer = Slicer()


<div class="viewcode-block" id="SynParams"><a class="viewcode-back" href="../../developer/_autosummary/dasi.cost.html#dasi.cost.SynParams">[docs]</a>class SynParams(object):
    &quot;&quot;&quot;Synthesis parameters&quot;&quot;&quot;

    gene_synthesis_cost = np.zeros((2250, 2))
    d = {
        (0, 1): {&quot;base&quot;: 0.0, &quot;time&quot;: 0},
        (1, 100): {&quot;base&quot;: np.Inf, &quot;time&quot;: np.Inf},
        (100, 500): {&quot;base&quot;: 89.0, &quot;time&quot;: 3.0},
        (500, 750): {&quot;base&quot;: 129.0, &quot;time&quot;: 3.0},
        (750, 1000): {&quot;base&quot;: 149.0, &quot;time&quot;: 4.0},
        (1000, 1250): {&quot;base&quot;: 209.0, &quot;time&quot;: 7.0},
        (1250, 1500): {&quot;base&quot;: 249.0, &quot;time&quot;: 7.0},
        (1500, 1750): {&quot;base&quot;: 289.0, &quot;time&quot;: 7.0},
        (1750, 2000): {&quot;base&quot;: 329.0, &quot;time&quot;: 7.0},
        (2000, 2250): {&quot;base&quot;: 399.0, &quot;time&quot;: 7.0},
    }
    for k, v in d.items():
        gene_synthesis_cost[k[0] : k[1]] = np.array([v[&quot;base&quot;], v[&quot;time&quot;]])

    synthesis_span_range = (0, 3000)
    gene_sizes = np.arange(len(gene_synthesis_cost)).reshape(-1, 1)
    gene_costs = gene_synthesis_cost[:, 0].reshape(-1, 1)
    gene_times = gene_synthesis_cost[:, 1].reshape(-1, 1)
    synthesis_step_size = 10
    synthesis_left_span_range = (-500, 500)</div>


<div class="viewcode-block" id="CostParams"><a class="viewcode-back" href="../../developer/_autosummary/dasi.cost.html#dasi.cost.CostParams">[docs]</a>class CostParams(object):
    &quot;&quot;&quot;Global cost parameters&quot;&quot;&quot;

    time = 50.0  # dollar cost of 24 hours
    material = 1.0  # multiply material cost by this amount</div>


<div class="viewcode-block" id="JunctionCost"><a class="viewcode-back" href="../../developer/_autosummary/dasi.cost.html#dasi.cost.JunctionCost">[docs]</a>class JunctionCost(object):
    &quot;&quot;&quot;Junction cost calculations.&quot;&quot;&quot;

    def __init__(self):
        # the min and max spans to evaluate
        min_span = JxnParams.min_jxn_span
        max_span = JxnParams.primers[:, 1].max() * 2 - min_span
        self.span = np.arange(min_span, max_span, dtype=np.int64)

        p = []  # cost array
        a = []  # ranges array
        for row in JxnParams.primers:
            _a = np.arange(row[0], row[1], dtype=np.int64)
            a.append(_a)
            p.append(np.broadcast_to(row[2:], (_a.shape[0], row[2:].shape[0])))
        a = np.concatenate(a).reshape(-1, 1)
        self.primer_lengths_array = a
        p = np.concatenate(p)

        assert len(a) == len(p)

        # 2D materials cost matrix
        m = p[:, 1, np.newaxis] * a + p[:, 0, np.newaxis]
        m = m + m.T

        # 2D time cost matrix
        t = p[:, 2, np.newaxis]
        t = np.maximum(t, t.T)

        # extension array
        ext = a - JxnParams.min_anneal

        # the span relative to extensions (i.e. the overlap)
        # overlap (sum of extensions - span) for primers of lengths a[x], a[y]
        relative_span = self.span - (ext + ext.T)[:, :, np.newaxis]
        relative_span = relative_span.swapaxes(2, 0).swapaxes(1, 2)

        # sanity checks
        # span=0, left_size = 200, right_size
        assert relative_span[0].shape == (ext.shape[0], ext.shape[0])
        # span=-300, primer_length=0, primer_length=0
        assert (
            relative_span[0, 0, 0] == self.span.min()
        )  # span=-300, primer_length=0, primer_length=0
        assert relative_span[0, 1, 0] == self.span.min() - 1
        assert relative_span[0, 0, 1] == self.span.min() - 1
        assert relative_span[0, 1, 1] == self.span.min() - 2

        # final costs
        e = JxnParams.jxn_efficiency[
            np.clip(-relative_span, 0, len(JxnParams.jxn_efficiency) - 1)
        ]
        self.xyz_labels = [&quot;span&quot;, &quot;left_ext&quot;, &quot;right_ext&quot;]
        self.cost_matrix = (m * CostParams.material + t * CostParams.time) * 1.0 / e

        self.slice_dict = {
            (0, 0): slicer[:, -1:, -1:],
            (0, 1): slicer[:, -1:, :-1],
            (1, 0): slicer[:, :-1, -1:],
            (1, 1): slicer[:, :-1, :-1],
        }
        self.cost_dict = {
            k: self.cost_matrix[self.slice_dict[k]] for k in self.slice_dict
        }
        self.min_cost_dict = {k: v.min(axis=(1, 2)) for k, v in self.cost_dict.items()}

        def argmin_and_unravel(m):
            dims = m.shape

            # flatten along first axis
            x = m.reshape(m.shape[0], -1)

            # TODO: this could be many options...
            # unravel
            g = x.argmin(axis=1)
            unraveled = np.unravel_index(g, dims)

            # convert to array of 3s, one for each index
            min_indices = np.dstack(unraveled).reshape(-1, 3)
            assert min_indices.shape[0] == m.shape[0]
            return min_indices

        # TODO: meanings behind the args...
        # there are &#39;200&#39; choices for primer lengths
        self.ext_dict = {k: a.flatten()[argmin_and_unravel(v)] for k, v in self.cost_dict.items()}

    def plot(self):
        df = pd.DataFrame()
        df[&quot;span&quot;] = self.span
        df[&quot;none&quot;] = self.min_cost_dict[(0, 0)]
        df[&quot;one&quot;] = self.min_cost_dict[(1, 0)]
        df[&quot;two&quot;] = self.min_cost_dict[(1, 1)]
        df = pd.melt(
            df, id_vars=[&quot;span&quot;], value_vars=[&quot;none&quot;, &quot;one&quot;, &quot;two&quot;], value_name=&quot;cost&quot;
        )

        print(df.columns)
        fig = plt.figure(figsize=(6, 5))
        ax = fig.gca()
        sns.lineplot(y=&quot;cost&quot;, x=&quot;span&quot;, hue=&quot;variable&quot;, data=df, ax=ax)
        ax.set_title(&quot;cost vs spanning distance (bp)&quot;)
        plt.show()

<div class="viewcode-block" id="JunctionCost.plot_design_flexibility"><a class="viewcode-back" href="../../developer/_autosummary/dasi.cost.html#dasi.cost.JunctionCost.plot_design_flexibility">[docs]</a>    def plot_design_flexibility(self):
        &quot;&quot;&quot;Makes a plot of the design flexibility for a given bp span&quot;&quot;&quot;
        options_arr = []
        for x in self.cost_matrix:
            if x.min() != np.Inf:
                opts = np.argwhere(x &lt; x.min() + 10.0)
                options_arr.append(len(opts))
            else:
                options_arr.append(0)

        df = pd.DataFrame()
        df[&quot;span&quot;] = self.span
        df[&quot;options&quot;] = options_arr

        fig = plt.figure(figsize=(6, 5))
        ax = fig.gca()

        sns.lineplot(x=&quot;span&quot;, y=&quot;options&quot;, ax=ax, data=df)
        plt.title(&quot;Design Flexibility&quot;)
        plt.show()</div>

    # def options(self, span, ext, max_cost):
    #     m = self.cost_dict[ext][span]
    #     print(m.min())
    #     indices = np.argwhere(m &lt;= max_cost)
    #     return indices
    #
    # def _span_to_index(self, span):
    #     i = span - self.span.min()
    #     i = np.clip(i, 0, self.cost_dict.shape[0] - 1)
    #     return i
    #
    #
    #
    # def cost_matrix(self, span, ext):
    #     return self.cost_dict[ext][self._span_to_index(span)]

    def cost(self, span, ext):
        i = span - self.span.min()
        i = np.clip(i, 0, self.min_cost_dict[ext].shape[0] - 1)
        return self.min_cost_dict[ext][i]

    def cost_and_desc(self, span, ext):
        i = span - self.span.min()
        i = np.clip(i, 0, self.min_cost_dict[ext].shape[0] - 1)
        cost = self.min_cost_dict[ext][i]
        ext = self.ext_dict[ext][i]
        return cost, ext</div>


<div class="viewcode-block" id="SynthesisCost"><a class="viewcode-back" href="../../developer/_autosummary/dasi.cost.html#dasi.cost.SynthesisCost">[docs]</a>class SynthesisCost(object):
    &quot;&quot;&quot;Synthesis cost calculations&quot;&quot;&quot;

    def __init__(self, jxn_cost: JunctionCost):
        self.jxn_cost = jxn_cost
        self.cost_dict = None
        self.cost_min_dict = None
        self.span = np.arange(
            SynParams.synthesis_span_range[0],
            SynParams.synthesis_span_range[1],
            SynParams.synthesis_step_size,
        )
        self.sizes = SynParams.gene_sizes[:: SynParams.synthesis_step_size, :]
        self.make_cost_dict()

    # TODO: synthesis means another fragment which reduces efficiency
    def compute_synthesis_costs(self, left_ext=0, right_ext=0):
        sizes = self.sizes
        span = self.span.reshape(1, -1)

        left_span = np.arange(
            SynParams.synthesis_left_span_range[0],
            SynParams.synthesis_left_span_range[1],
            SynParams.synthesis_step_size,
        ).reshape(-1, 1)[:, np.newaxis]
        left_cost, left_ext_choice = self.jxn_cost.cost_and_desc(left_span, ext=(left_ext, 0))
        right_span = span - sizes - left_span

        # sanity check
        # left_span[0] == -500
        # gene_sizes[0] * step_size == 0
        # span[0] * step_size == 0
        assert right_span[0, 100, 100] == 500

        # left_span[10] == -400
        # gene_sizes[100] == 1000
        # span[50] == 500
        assert right_span[10, 100, 50] == -100

        right_cost, right_ext_choice = self.jxn_cost.cost_and_desc(right_span, ext=(0, right_ext))
        gene_cost = SynParams.gene_costs[sizes]
        gene_time = SynParams.gene_times[sizes]

        # TODO:should just get the material costs here and multiply the efficiencies later
        # auto broadcast
        ext_costs = left_cost + right_cost

        # TODO: need to broadcast left and right ext_choice

        # size, left span, span
        ext_costs = ext_costs.swapaxes(0, 1)
        material = ext_costs + gene_cost
        total = material * CostParams.material + gene_time * CostParams.time
        # axes are [gene_size, left_span, span]
        return total

    def optimize_step_size(self, s, ds):
        step_size = s
        delta_step = ds
        y1 = self.compute_synthesis_costs(0, 0, step_size).min(axis=(0, 1)).flatten()
        x1 = np.arange(len(y1)) * step_size

        y2 = (
            self.compute_synthesis_costs(0, 0, step_size - delta_step)
            .min(axis=(0, 1))
            .flatten()
        )
        x2 = np.arange(len(y2)) * (step_size - delta_step)
        y2_interp = np.interp(x1, x2, y2)
        diff = ((y1 - y2_interp) ** 2).sum() / len(y1)
        return diff

    def make_cost_dict(self):
        d = {}
        d[(0, 0)] = self.compute_synthesis_costs(0, 0)
        d[(1, 0)] = self.compute_synthesis_costs(1, 0)
        d[(0, 1)] = self.compute_synthesis_costs(0, 1)
        d[(1, 1)] = self.compute_synthesis_costs(1, 1)
        self.cost_dict = d
        self.cost_min_dict = {
            k: v.min(axis=(0, 1)).flatten() for k, v in self.cost_dict.items()
        }
        self.cost_dict[&quot;step&quot;] = SynParams.synthesis_step_size
        self.cost_min_dict[&quot;step&quot;] = SynParams.synthesis_step_size

    def cost(self, span, ext):
        assert self.span[0] == 0
        step_size = self.cost_dict[&quot;step&quot;]
        i = np.array(span / step_size, dtype=np.int64)
        i = np.clip(i, 0, len(self.span) - 1)
        return self.cost_min_dict[ext][i]

    def plot(self):
        df = pd.DataFrame()
        df[&quot;e0&quot;] = self.cost_min_dict[(0, 0)]
        df[&quot;e1&quot;] = self.cost_min_dict[(1, 0)]
        df[&quot;e2&quot;] = self.cost_min_dict[(1, 1)]
        df[&quot;span&quot;] = np.arange(
            SynParams.synthesis_span_range[0],
            SynParams.synthesis_span_range[1],
            SynParams.synthesis_step_size,
        )
        df = pd.melt(
            df, id_vars=[&quot;span&quot;], value_vars=[&quot;e0&quot;, &quot;e1&quot;, &quot;e2&quot;], value_name=&quot;cost&quot;
        )
        fig = plt.figure(figsize=(6, 5))
        ax = fig.gca()
        ax.set_ylim(0, 1000)
        sns.lineplot(x=&quot;span&quot;, y=&quot;cost&quot;, hue=&quot;variable&quot;, data=df, ax=ax)
        plt.show()</div>


<div class="viewcode-block" id="SpanCost"><a class="viewcode-back" href="../../developer/_autosummary/dasi.cost.html#dasi.cost.SpanCost">[docs]</a>class SpanCost(object):
    &quot;&quot;&quot;Span cost calculations&quot;&quot;&quot;

    JUNCTION_BY_PRIMERS = &quot;JUNCTION_BY_PRIMERS&quot;
    JUNCTION_BY_SYNTHESIS = &quot;JUNCTION_BY_SYNTHESIS&quot;

    def __init__(self):
        self.junction_cost = JunctionCost()
        self.synthesis_cost = SynthesisCost(self.junction_cost)
        self.min_cost_dict = {}
        self.argmin_cost_dict = {}

        # TODO make sure this matches with the np.stack below
        self.arg_desc = np.array([
                self.JUNCTION_BY_PRIMERS,
                self.JUNCTION_BY_SYNTHESIS
            ])
        x = [
            self.junction_cost.span.min(),
            self.junction_cost.span.max(),
            self.synthesis_cost.span.min(),
            self.synthesis_cost.span.max()
        ]
        self._span = (min(x), max(x))
        self._span_range = np.arange(min(x), max(x)+1)

        # TODO: here return whether we are synthesizing or using primers
        for ext in [(0, 0), (0, 1), (1, 0), (1, 1)]:
            a = self.junction_cost.cost(self._span_range, ext)
            b = self.synthesis_cost.cost(self._span_range, ext)
            c = np.stack([a, b])

            d = c.min(axis=0)
            darg = c.argmin(axis=0)
            self.argmin_cost_dict[ext] = darg
            self.min_cost_dict[ext] = d

<div class="viewcode-block" id="SpanCost.cost"><a class="viewcode-back" href="../../developer/_autosummary/dasi.cost.html#dasi.cost.SpanCost.cost">[docs]</a>    def cost(self, span: int, ext: Tuple[int, int]) -&gt; float:
        &quot;&quot;&quot;
        Return cost of span. Span may be a np.ndarray

        :param span:
        :type span:
        :param ext:
        :type ext:
        :return:
        :rtype:
        &quot;&quot;&quot;
        self.cost_and_desc(span, ext)[0]</div>

    # TODO: cost_and_desc is broken somehow
    def cost_and_desc(self, span: int, ext: Tuple[int, int]) -&gt; Tuple[float, Any]:
        # need to convert span to span index
        i = np.where(self._span_range == span)[0]
        if not i:
            return np.Inf, &quot;out of bounds, not able to evaluate&quot;
        cost = self.min_cost_dict[ext][i[0]]
        desc = self.arg_desc[self.argmin_cost_dict[ext][i[0]]]
        return cost, desc</div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>