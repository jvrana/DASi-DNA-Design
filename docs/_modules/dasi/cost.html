<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.cost &#8212; dasi 0.0.4 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"equationNumbers": {"autoNumber": "AMS", "useLabelIds": true}}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>



  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.4</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../developer/api_reference.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.design">Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.alignments">Alignments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.cost">Cost Calculations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.cost.params">Parameters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.utils">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.cost.utils">Cost utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.utils.networkx">Networkx utilities</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for dasi.cost</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;Classes and methods for estimating assembly costs.&quot;&quot;&quot;
from abc import ABC
from abc import abstractmethod
from functools import partial
from typing import Tuple
from typing import Type
from typing import Union

import msgpack
import numpy as np
import pandas as pd
import seaborn as sns

from .params import Globals
from .params import PrimerParams
from .params import SynthesisParams
from .utils import df_to_np_ranged
from .utils import lexargmin
from .utils import slicer
from dasi.utils import NumpyDataFrame

slice_dict = {
    (0, 0): slicer[:, :1, :1],
    (0, 1): slicer[:, :1, 1:],
    (1, 0): slicer[:, 1:, :1],
    (1, 1): slicer[:, 1:, 1:],
}


<div class="viewcode-block" id="encoder"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.encoder">[docs]</a>def encoder(obj):
    &quot;&quot;&quot;msgpack encoder for cost functions.

    :param obj:
    :return:
    &quot;&quot;&quot;
    if isinstance(obj, NumpyDataFrame):
        return {&quot;__numpydataframe__&quot;: True, &quot;data&quot;: obj.data}
    elif isinstance(obj, SpanCost):
        return {
            &quot;__spancost__&quot;: True,
            &quot;cost_dict&quot;: {k: v for k, v in obj.cost_dict.items()},
            &quot;span&quot;: obj.span,
        }
    return obj</div>


<div class="viewcode-block" id="decoder"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.decoder">[docs]</a>def decoder(obj):
    &quot;&quot;&quot;msgpack decoder for cost functions.

    :param obj:
    :return:
    &quot;&quot;&quot;
    if b&quot;__numpydataframe__&quot; in obj:
        data = obj[b&quot;data&quot;]
        data = {k.decode(): v for k, v in data.items()}
        obj = NumpyDataFrame(data=data)
    elif b&quot;__spancost__&quot; in obj:
        cost_dict = {tuple(k): v for k, v in obj[b&quot;cost_dict&quot;].items()}
        span = obj[b&quot;span&quot;]
        obj = SpanCost.__new__(SpanCost)
        obj.cost_dict = cost_dict
        obj.span = span
    return obj</div>


<div class="viewcode-block" id="CostBuilder"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.CostBuilder">[docs]</a>class CostBuilder(ABC):
    &quot;&quot;&quot;Abstract base class for building a cost model.&quot;&quot;&quot;

    def __init__(self, span: np.ndarray):
        &quot;&quot;&quot;Initialize cost builder from a &#39;span&#39;, or a list of indices for
        which the model is valid.

        :param span: the list of indices (span) for which this cost model is evaluated.
        &quot;&quot;&quot;
        self.cost_dict = {}
        self.span = span

<div class="viewcode-block" id="CostBuilder.from_params"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.CostBuilder.from_params">[docs]</a>    @classmethod
    @abstractmethod
    def from_params(cls, *args):
        &quot;&quot;&quot;Initialize from parameters.&quot;&quot;&quot;
        pass</div>

<div class="viewcode-block" id="CostBuilder.compute"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.CostBuilder.compute">[docs]</a>    @abstractmethod
    def compute(self):
        &quot;&quot;&quot;Before the numpy-based cost calculations.&quot;&quot;&quot;
        pass</div>

<div class="viewcode-block" id="CostBuilder.to_df"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.CostBuilder.to_df">[docs]</a>    def to_df(self):
        &quot;&quot;&quot;Convert the cost builder to a pandas.DataFrame.&quot;&quot;&quot;
        dfs = []
        for ext, jxn in self.cost_dict.items():
            df = jxn.to_df()
            df[&quot;condition&quot;] = [ext] * len(df)
            dfs.append(df)
        df = pd.concat(dfs)
        return df</div>

    @property
    def plot(self):
        &quot;&quot;&quot;Plot attributes across &#39;span&#39; from the pandas.DataFrame.&quot;&quot;&quot;
        return partial(
            sns.lineplot, data=self.to_df(), x=&quot;span&quot;, y=&quot;cost&quot;, hue=&quot;condition&quot;
        )

    # TODO: what if there is a gap in the span?
<div class="viewcode-block" id="CostBuilder.cost"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.CostBuilder.cost">[docs]</a>    def cost(
        self, bp: Union[np.ndarray, int], ext: Tuple[int, int], invalidate=False
    ) -&gt; NumpyDataFrame:
        &quot;&quot;&quot;Return the :class:`NumpyDataFrame &lt;dasi.usil.NumpyDataFrame&gt;` across
        the provided span.

        :param bp: either a integer or np.ndarray of integers to compute.
        :param ext: The extension design parameters (bool, bool) that represent
                    whether the left or right primer is &#39;extendable&#39;. Primers
                    that have been provided are not extendable. If we had,
                    for example, an existing right primer and flexibility to
                    design the left primer, this would be `(1, 0)`.
        :param invalidate: Whether to invalidate indicies that go beyond the provided
                            span for the cost builder (`CostModelBase.span`). Any
                            invalid indices cost will be set to `np.inf` and efficiency
                            to `0.0`
        :return: NumpyDataFrame representing the cost of from the input span.
        &quot;&quot;&quot;
        if isinstance(bp, int):
            bp = np.array([bp])
        _span = self.span.flatten()
        index = np.array(bp - _span.min(), dtype=np.int64)

        # clipped index
        clipped = np.clip(index, 0, len(_span) - 1)
        if isinstance(clipped, int):
            index = np.array([clipped])

        # get junction
        jxn = self.cost_dict[ext][clipped]

        if invalidate:
            # invalidated indices
            invalid_i1 = index &lt; 0
            invalid_i2 = index &gt;= len(_span)

            # invalidate extremes
            for invalid in [invalid_i1, invalid_i2]:
                jxn.data[&quot;cost&quot;][invalid] = np.inf
                jxn.data[&quot;efficiency&quot;][invalid] = 0.0

        # add span
        jxn.col[&quot;span&quot;] = np.array(bp)
        return jxn</div>

    def __call__(
        self, bp: Union[int, np.ndarray], ext: Tuple[int, int]
    ) -&gt; NumpyDataFrame:
        &quot;&quot;&quot;Short hand for calling :meth:`cost`&quot;&quot;&quot;
        return self.cost(bp, ext)</div>


<div class="viewcode-block" id="PrimerCostModel"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.PrimerCostModel">[docs]</a>class PrimerCostModel(CostBuilder):
    def __init__(
        self,
        pdf: pd.DataFrame,
        edf: pd.DataFrame,
        min_anneal: int,
        time_cost: float,
        material_mod: float,
        min_span: int,
    ):
        &quot;&quot;&quot;Initialize the cost model for primer designs.

        :param pdf: a pandas DataFrame representing costs for primers.
                    Example parameters found at
                    :attr:`dasi.cost.params.PrimerParams.primer_df`
        :param edf: a pandas DataFrame representing efficiencies for spans.
                    Example parameters found at
                    :attr:`dasi.cost.params.PrimerParams.eff_df`
        :param min_anneal: the number of bases to consider for annealing a primer.
        :param time_cost: the cost to produce a primer
        :param material_mod:
        :param min_span:
        &quot;&quot;&quot;
        self.primer_df = pdf
        self.eff_df = edf
        self.time_cost = time_cost
        self.min_anneal = min_anneal
        max_span = self.primer_df[&quot;max&quot;].max() * 2 - min_span
        span = np.arange(min_span, max_span, dtype=np.int32)
        super().__init__(span)
        self.material_modifier = material_mod
        self.compute()

<div class="viewcode-block" id="PrimerCostModel.from_params"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.PrimerCostModel.from_params">[docs]</a>    @classmethod
    def from_params(cls, primer_params: Type[PrimerParams]) -&gt; &quot;PrimerCostModel&quot;:
        &quot;&quot;&quot;Load from :class:`dasi.cost.params.PrimerParams`.

        :param primer_params: parameters
        :return: PrimerCostModel
        &quot;&quot;&quot;
        return cls(
            pdf=primer_params.primer_df,
            edf=primer_params.eff_df,
            min_anneal=primer_params.min_anneal,
            time_cost=primer_params.time_cost,
            material_mod=primer_params.material_modifier,
            min_span=primer_params.min_span,
        )</div>

<div class="viewcode-block" id="PrimerCostModel.compute"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.PrimerCostModel.compute">[docs]</a>    def compute(self):
        span = self.span

        # span, base cost, cost per bp, time (days)
        p = df_to_np_ranged(
            &quot;min&quot;,
            &quot;max&quot;,
            self.primer_df,
            cols=[&quot;base cost&quot;, &quot;cost per bp&quot;, &quot;time (days)&quot;],
            dtype=np.float64,
        )

        # flattened extension array
        ext = p[:, 0].reshape(-1, 1) - self.min_anneal
        ext = ext.astype(np.int32)

        # relative span (i.e. the overlap)
        rel_span = span[:, np.newaxis, np.newaxis] - (ext + ext.T)[np.newaxis, :, :]

        # efficiency, the same shape as rel_span
        eff_arr = df_to_np_ranged(&quot;min&quot;, &quot;max&quot;, self.eff_df, dtype=np.float64)[:, 1]
        eff = eff_arr[np.clip(-rel_span, 0, len(eff_arr) - 1)]

        # material cost
        m = p[:, 0, np.newaxis] * p[:, 2, np.newaxis] + p[:, 1, np.newaxis]
        t = p[:, 3, np.newaxis]
        t = np.maximum(t, t.T)
        x = m * self.material_modifier + t * self.time_cost
        material_cost = x + x.T

        # cost
        cost = material_cost / eff
        cost[np.where(np.isnan(cost))] = np.inf

        for slice_index, slice_obj in slice_dict.items():
            s_eff = eff[slice_obj]
            s_cost = cost[slice_obj]
            s_mat = material_cost[slice_obj[1], slice_obj[2]]

            idx = lexargmin((s_eff, s_cost), axis=0)
            self.cost_dict[slice_index] = NumpyDataFrame(
                dict(
                    span=span[idx[0]],
                    cost=s_cost[idx],
                    efficiency=s_eff[idx],
                    material=s_mat[idx[1], idx[2]],
                    left_ext=ext[idx[1]],
                    right_ext=ext[idx[2]],
                    time=t[idx[1], idx[2]],
                ),
                apply=np.squeeze,
            )</div></div>


<div class="viewcode-block" id="SynthesisCostModel"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.SynthesisCostModel">[docs]</a>class SynthesisCostModel(CostBuilder):
    def __init__(
        self,
        sdf: pd.DataFrame,
        primer_cost: PrimerCostModel,
        time_cost: float,
        material_modifier: float,
        step_size=10,
        left_span_range=(-500, 500),
    ):
        &quot;&quot;&quot;

        :param sdf: synthesis parameter pandas dataframe. Example parameters found
                    at :attr:`dasi.cost.params.SynthesisParams.synthesis_df`
        :param primer_cost: primer cost builder
        :param time_cost: time cost per day
        :param material_modifier: material multiplier (default: 1.0)
        :param step_size: step size to consider (default: 10)
        :param left_span_range: span range for left primer to consider
                (default: -500, 500)
        &quot;&quot;&quot;
        self.synthesis_df = sdf
        self.step_size = step_size
        self.material_modifier = (material_modifier,)
        self.lspanrange = left_span_range
        self.primer_cost = primer_cost
        self.time_cost = time_cost
        super().__init__(None)
        # self.logger = logger(self)
        self.compute()

<div class="viewcode-block" id="SynthesisCostModel.from_params"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.SynthesisCostModel.from_params">[docs]</a>    @classmethod
    def from_params(cls, syn_params: SynthesisParams, primer_cost: PrimerCostModel):
        return cls(
            sdf=syn_params.synthesis_df,
            primer_cost=primer_cost,
            time_cost=syn_params.time_cost,
            material_modifier=syn_params.material_modifier,
            step_size=syn_params.step_size,
            left_span_range=syn_params.left_span_range,
        )</div>

<div class="viewcode-block" id="SynthesisCostModel.compute"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.SynthesisCostModel.compute">[docs]</a>    def compute(self):
        syn = df_to_np_ranged(&quot;min&quot;, &quot;max&quot;, self.synthesis_df, dtype=np.float32)
        gene_sizes = syn[:, 0].reshape(-1, 1)[:: self.step_size, :].astype(np.int32)
        gene_costs = syn[:, 1][gene_sizes]
        gene_times = syn[:, 2][gene_sizes]

        self.span = syn[:, 0].reshape(1, -1).astype(np.int32)

        left_span = np.arange(self.lspanrange[0], self.lspanrange[1], self.step_size)[
            ..., np.newaxis, np.newaxis
        ]

        for i, j in [(0, 0), (1, 0), (0, 1), (1, 1)]:
            jxn = self._compute(gene_costs, gene_sizes, gene_times, i, j, left_span)
            self.cost_dict[(i, j)] = jxn</div>

    def _compute(
        self,
        gene_costs,
        gene_sizes,
        gene_times,
        i: Union[bool, int],
        j: Union[bool, int],
        left_span,
    ):
        # extension conditions
        left_ext = (i, 0)
        right_ext = (0, j)
        # left primer
        left_jxn = self.primer_cost(left_span, ext=left_ext)
        left_eff = left_jxn.data[&quot;efficiency&quot;]
        left_material = left_jxn.data[&quot;material&quot;]

        # right primer
        right_span = self.span - gene_sizes - left_span
        right_jxn = self.primer_cost(right_span, ext=right_ext)
        right_eff = right_jxn.data[&quot;efficiency&quot;]
        right_material = right_jxn.data[&quot;material&quot;]
        ext_material = left_material + right_material
        ext_eff = np.multiply(left_eff, right_eff)

        # swap axes
        # span, size, left_span
        ext_material = ext_material.swapaxes(0, 2)
        ext_eff = ext_eff.swapaxes(0, 2)
        syn_eff = ext_eff * 1.0  # here place probability of success for gene synthesis
        # could even use sequence to compute this later???
        syn_material_cost = (
            ext_material + gene_costs[np.newaxis, ...] * self.material_modifier
        )
        syn_time_cost = gene_times * self.time_cost
        syn_total_cost = (syn_material_cost + syn_time_cost[np.newaxis, ...]) / syn_eff
        idx = lexargmin((syn_eff, syn_total_cost), axis=0)

        _gcosts = gene_costs[idx[1]]
        _span = np.squeeze(self.span)[idx[0]]

        gene_df = NumpyDataFrame(
            dict(
                cost=_gcosts,
                material=_gcosts,
                efficiency=np.ones(idx[0].shape[0]),
                size=gene_sizes[idx[1]],
            ),
            apply=np.squeeze,
        )

        gap_df = NumpyDataFrame(
            dict(
                span=_span,
                cost=syn_total_cost[idx],
                efficiency=syn_eff[idx],
                material=syn_material_cost[idx],
                lshift=left_span[idx[2]],
            ),
            apply=np.squeeze,
        )

        gap_df.update(left_jxn[idx[2]].apply(np.squeeze).prefix(&quot;lprimer_&quot;))
        gap_df.update(right_jxn[idx[2], idx[1], idx[0]].prefix(&quot;rprimer_&quot;))
        gap_df.update(gene_df.prefix(&quot;gene_&quot;))

        return gap_df

<div class="viewcode-block" id="SynthesisCostModel.cost"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.SynthesisCostModel.cost">[docs]</a>    def cost(
        self, bp: Union[int, np.ndarray], ext: Tuple[int, int], invalidate=True
    ) -&gt; NumpyDataFrame:
        return super().cost(bp, ext, invalidate=invalidate)</div>

    def __call__(self, bp, ext):
        return self.cost(bp, ext)</div>


<div class="viewcode-block" id="SpanCost"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.SpanCost">[docs]</a>class SpanCost(CostBuilder):
    def __init__(self, syn_cost):
        self.syn_cost = syn_cost
        self.primer_cost = self.syn_cost.primer_cost
        x = [
            syn_cost.span.min(),
            syn_cost.span.max(),
            self.primer_cost.span.min(),
            self.primer_cost.span.max(),
        ]
        span = np.arange(min(x), max(x))
        super().__init__(span)
        self.compute()

<div class="viewcode-block" id="SpanCost.from_params"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.SpanCost.from_params">[docs]</a>    @classmethod
    def from_params(cls):
        pass</div>

    @classmethod
    def default(cls):
        primer_cost = PrimerCostModel.from_params(PrimerParams)
        syn_cost = SynthesisCostModel.from_params(SynthesisParams, primer_cost)
        return cls(syn_cost)

<div class="viewcode-block" id="SpanCost.compute"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.SpanCost.compute">[docs]</a>    def compute(self):
        def choose(a, i):
            return np.choose(i, a)

        for s in [(0, 0), (0, 1), (1, 0), (1, 1)]:
            # numpy data frames for primer cost and syn cost over span
            df1 = self.primer_cost(self.span, s)
            df2 = self.syn_cost(self.span, s)

            # determine the indices of the min cost (0=primer, 1=syn)
            c1 = df1.data[&quot;cost&quot;]
            c2 = df2.data[&quot;cost&quot;]
            c3 = np.stack((c1, c2), axis=1)
            y = c3.argmin(axis=1)

            # select between primer_cost and syn_cost based on the min cost
            df4 = NumpyDataFrame.group_apply(
                (df1, df2), choose, i=y, _fill_value=np.nan
            )
            self.cost_dict[s] = df4</div>

<div class="viewcode-block" id="SpanCost.cost"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.cost.SpanCost.cost">[docs]</a>    def cost(
        self, bp: Union[int, np.ndarray], ext: Tuple[int, int], invalidate=True
    ) -&gt; NumpyDataFrame:
        return super().cost(bp, ext, invalidate=invalidate)</div>

    def dumpb(self) -&gt; bytes:
        return msgpack.packb(self, default=encoder, use_bin_type=True)

    @classmethod
    def loadb(cls, s: bytes):
        return msgpack.unpackb(s, object_hook=decoder, raw=True, use_list=False)

    def dump(self, path: str):
        with open(path, &quot;wb&quot;) as f:
            f.write(self.dumpb())

    @classmethod
    def load(cls, path: str):
        with open(path, &quot;rb&quot;) as f:
            return cls.loadb(f.read())</div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>