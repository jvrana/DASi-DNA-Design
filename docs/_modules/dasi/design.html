<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.design &#8212; dasi 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>
    


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../developer/api_reference.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../developer/api_reference.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for dasi.design</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;Primer and synthesis design

.. module:: dasi.design

Submodules
==========

.. autosummary::
    :toctree: _autosummary

    graph_builder
    plotter
    design_algorithms
&quot;&quot;&quot;
from __future__ import annotations

import bisect
from collections.abc import Iterable
from copy import deepcopy
from itertools import zip_longest
from typing import List, Tuple, Dict

import networkx as nx
import numpy as np
import pandas as pd
from Bio.SeqRecord import SeqRecord
from more_itertools import pairwise
from pyblast import BioBlastFactory
from pyblast.utils import Span, is_circular
from multiprocessing import Pool
from dasi.alignments import (
    Alignment,
    AlignmentContainerFactory,
    AlignmentContainer,
    AlignmentGroup,
    ComplexAlignmentGroup,
)
from dasi.constants import Constants
from dasi.design.graph_builder import AssemblyNode
from dasi.log import logger
from dasi.utils import perfect_subject, sort_cycle
from .design_algorithms import (
    assemble_graph,
    optimize_graph,
    multiprocessing_assemble_graph,
    multiprocessing_optimize_graph,
)
from .graph_builder import AssemblyGraphBuilder

BLAST_PENALTY_CONFIG = {&quot;gapopen&quot;: 3, &quot;gapextend&quot;: 3, &quot;reward&quot;: 1, &quot;penalty&quot;: -5}


<div class="viewcode-block" id="DesignResult"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.DesignResult">[docs]</a>class DesignResult(Iterable):
    &quot;&quot;&quot;DesignResult container.&quot;&quot;&quot;

    def __init__(self, container, graph, query_key):
        self.container = container
        self.graph = graph
        self.query_key = query_key
        self.query = self.container.seqdb[query_key]
        self._assemblies = []
        self._keys = []

    @property
    def assemblies(self):
        return tuple(self._assemblies)

    def _new(self, path: List[AssemblyNode]):
        return Assembly(path, self.container, self.graph, self.query_key, self.query)

    def add_assembly(self, path: List[AssemblyNode]):
        assembly = self._new(path)
        cost = assembly.cost()
        n_nodes = len(assembly._nodes)
        k = (cost, n_nodes)
        i = bisect.bisect_left(self._keys, k)
        self._assemblies.insert(i, assembly)
        self._keys.insert(i, k)

    def add_assemblies(self, paths: List[List[AssemblyNode]]):
        for path in paths:
            self.add_assembly(path)

    def __iter__(self):
        for assembly in self.assemblies:
            yield assembly

    def __getitem__(self, item):
        return list(self)[item]</div>


<div class="viewcode-block" id="Assembly"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Assembly">[docs]</a>class Assembly(Iterable):
    &quot;&quot;&quot;
    Should take in a path, graph, container, seqdb to produce relevant information
    &quot;&quot;&quot;

    def __init__(
        self,
        nodes: List[AssemblyNode],
        container: AlignmentContainer,
        full_assembly_graph: nx.DiGraph,
        query_key: str,
        query: SeqRecord,
    ):
        self.container = container
        self.groups = container.groups()
        self.query_key = query_key
        self.query = query
        self._nodes = tuple(nodes)
        self._full_graph = full_assembly_graph
        self.graph = self._subgraph(self._full_graph, nodes)
        nx.freeze(self.graph)

    def _subgraph(self, graph: nx.DiGraph, nodes: List[AssemblyNode]):
        def _resolve(node: AssemblyNode, query_region) -&gt; Tuple[int, dict]:
            new_node = AssemblyNode(query_region.t(node.index), *list(node)[1:])
            return new_node, {}

        SG = nx.OrderedDiGraph()
        nodes = [AssemblyNode(*n) for n in nodes]
        example_query_region = self.container.alignments[0].query_region

        resolved_nodes = [_resolve(node, example_query_region) for node in nodes]
        if self.cyclic:
            resolved_nodes = sort_cycle(
                resolved_nodes, key=lambda n: (n[0].type, n[0].index, n)
            )
        SG.add_nodes_from(resolved_nodes)

        if self.cyclic:
            pair_iter = list(pairwise(nodes + nodes[:1]))
        else:
            pair_iter = list(pairwise(nodes))

        for n1, n2 in pair_iter:
            edata = deepcopy(graph.get_edge_data(n1, n2))
            if edata is None:
                edata = {
                    &quot;cost&quot;: np.inf,
                    &quot;weight&quot;: np.inf,
                    &quot;type&quot;: &quot;missing&quot;,
                    &quot;span&quot;: np.inf,
                    &quot;name&quot;: &quot;missing&quot;,
                }

            # TODO: fix query_region (overlaps are backwards)
            query_region = self.container.alignments[0].query_region.new(
                n1.index, n2.index, allow_wrap=True
            )
            groups = self.container.find_groups_by_pos(
                query_region.a, query_region.b, groups=self.groups
            )
            edata[&quot;groups&quot;] = groups
            edata[&quot;query_region&quot;] = query_region
            SG.add_edge(
                _resolve(n1, query_region)[0], _resolve(n2, query_region)[0], **edata
            )
        return SG

    @property
    def cyclic(self):
        return is_circular(self.query)

    # TODO: this cost is no longer true...
    def cost(self):
        total = 0
        for _, _, edata in self.edges():
            if &quot;cost&quot; not in edata:
                x = 1
            total += edata[&quot;cost&quot;]
        return total

    def edges(self, data=True) -&gt; Iterable[Tuple[AssemblyNode, AssemblyNode, Dict]]:
        return self.graph.edges(data=data)

    def nodes(self, data=True) -&gt; Iterable[Tuple[AssemblyNode, Dict]]:
        return self.graph.nodes(data=data)

    def edit_distance(
        self, other: Assembly, explain=False
    ) -&gt; Tuple[int, List[Tuple[int, str]]]:
        differences = []
        for i, (n1, n2) in enumerate(
            zip_longest(self.nodes(data=False), other.nodes(data=False))
        ):
            if n1 is None or n2 is None:
                differences.append((i, &quot;{} != {}&quot;.format(n1, n2)))
                continue
            if n1.index != n2.index:
                differences.append((i, &quot;Index: {} != {}&quot;.format(n1.index, n2.index)))
            if n1.expandable != n2.expandable:
                differences.append(
                    (i, &quot;Expandable: {} != {}&quot;.format(n1.expandable, n2.expandable))
                )
            if n1.type != n2.type:
                differences.append((i, &quot;Type: {} != {}&quot;.format(n1.type, n2.type)))
            if n1.overhang != n2.overhang:
                differences.append(
                    (i, &quot;Overhang: {} != {}&quot;.format(n1.overhang, n2.overhang))
                )
        dist = len(differences)
        if explain:
            return dist, differences
        return dist

    def print(self):
        print(&quot;query_name: {}&quot;.format(self.query.name))
        print(&quot;query_key: {}&quot;.format(self.query_key))
        print(&quot;Cost: {}&quot;.format(self.cost()))
        df = self.to_df()
        print(df)

    def print_diff(self, other: Assembly):
        for i, (n1, n2) in enumerate(
            zip_longest(self.nodes(data=False), other.nodes(data=False))
        ):
            if n1 != n2:
                desc = False
            else:
                desc = True
            print(&quot;{} {} {}&quot;.format(desc, n1, n2))

    def to_df(self):
        rows = []
        for n1, n2, edata in self.edges():
            groups = edata[&quot;groups&quot;]
            if groups:
                group = groups[0]
                if isinstance(group, ComplexAlignmentGroup):
                    alignments = group.alignments
                else:
                    alignments = group.alignments[:1]
            else:
                alignments = []
            subject_keys = [a.subject_key for a in alignments]
            subject_names = [self.container.seqdb[key].name for key in subject_keys]
            subject_starts = [a.subject_region.a for a in alignments]
            subject_ends = [a.subject_region.b for a in alignments]

            rows.append(
                {
                    &quot;query_start&quot;: edata[&quot;query_region&quot;].a,
                    &quot;query_end&quot;: edata[&quot;query_region&quot;].b,
                    &quot;subject_names&quot;: subject_names,
                    &quot;subject_keys&quot;: subject_keys,
                    &quot;subject_start&quot;: subject_starts,
                    &quot;subject_ends&quot;: subject_ends,
                    &quot;cost&quot;: edata[&quot;cost&quot;],
                    &quot;span&quot;: edata[&quot;span&quot;],
                    &quot;type&quot;: edata[&quot;type&quot;],
                    &quot;name&quot;: edata[&quot;name&quot;],
                    &quot;efficiency&quot;: edata.get(&quot;efficiency&quot;, np.nan),
                }
            )

        df = pd.DataFrame(rows)
        return df

    def __eq__(self, other: Assembly) -&gt; bool:
        return self.edit_distance(other) == 0

    def __iter__(self):
        for n in self.nodes(data=False):
            yield n</div>


def run_blast(args):
    if args is None or args[0] is None:
        return []
    blast, func_str = args
    func = getattr(blast, func_str)
    func()
    return blast.get_perfect()


class FakePool(object):
    def __init__(self, *args, **kwargs):
        pass

    def __enter__(self):
        return FakePool()

    def __exit__(self, a, b, c):
        pass

    def map(self, func, args):
        return [func(arg) for arg in args]


<div class="viewcode-block" id="Design"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design">[docs]</a>class Design(object):
    &quot;&quot;&quot;
    Design class that returns optimal assemblies from a set of materials.
    &quot;&quot;&quot;

    PRIMERS = &quot;primers&quot;
    TEMPLATES = &quot;templates&quot;
    QUERIES = &quot;queries&quot;
    FRAGMENTS = &quot;fragments&quot;
    DEFAULT_N_THREADS = 1

    def __init__(self, span_cost=None, seqdb=None, n_threads=None):
        self.blast_factory = BioBlastFactory()
        self.logger = logger(self)

        # graph by query_key
        if seqdb is None:
            seqdb = {}
        self._seqdb = seqdb
        self.span_cost = span_cost
        self.graphs = {}
        self.results = {}
        self.container_factory = AlignmentContainerFactory(self.seqdb)
        self.n_threads = n_threads or self.DEFAULT_N_THREADS

    @property
    def seqdb(self):
        return self._seqdb

    def add_materials(
        self,
        primers: List[SeqRecord],
        templates: List[SeqRecord],
        queries: List[SeqRecord],
        fragments=None,
    ):
        if fragments is None:
            fragments = []
        self.add_primers(primers)
        fragments = self.filter_linear_records(fragments)
        self.add_templates(templates + fragments)
        self.add_queries(queries)
        self.add_fragments(fragments)

        self.template_results = []
        self.fragment_results = []
        self.primer_results = []

<div class="viewcode-block" id="Design.add_primers"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design.add_primers">[docs]</a>    def add_primers(self, primers: List[SeqRecord]):
        &quot;&quot;&quot;Add primer sequences to materials list&quot;&quot;&quot;
        self.logger.info(&quot;Adding primers&quot;)
        self.blast_factory.add_records(primers, self.PRIMERS)</div>

<div class="viewcode-block" id="Design.add_templates"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design.add_templates">[docs]</a>    def add_templates(self, templates: List[SeqRecord]):
        &quot;&quot;&quot;Add template sequences to materials list&quot;&quot;&quot;
        self.logger.info(&quot;Adding templates&quot;)
        self.blast_factory.add_records(templates, self.TEMPLATES)</div>

<div class="viewcode-block" id="Design.add_queries"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design.add_queries">[docs]</a>    def add_queries(self, queries: List[SeqRecord]):
        &quot;&quot;&quot;Add goal/query sequences to materials list&quot;&quot;&quot;
        self.logger.info(&quot;Adding queries&quot;)
        self.blast_factory.add_records(queries, self.QUERIES)</div>

<div class="viewcode-block" id="Design.add_fragments"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design.add_fragments">[docs]</a>    def add_fragments(self, fragments: List[SeqRecord]):
        &quot;&quot;&quot;Add fragment sequences to materials list&quot;&quot;&quot;
        self.logger.info(&quot;Adding fragments&quot;)
        self.blast_factory.add_records(fragments, self.FRAGMENTS)</div>
        # self.blast_factory.add_records(fragments, self.TEMPLATES)

<div class="viewcode-block" id="Design.filter_linear_records"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design.filter_linear_records">[docs]</a>    @classmethod
    def filter_linear_records(cls, records):
        &quot;&quot;&quot;Return only linear records&quot;&quot;&quot;
        return [r for r in records if not is_circular(r)]</div>

<div class="viewcode-block" id="Design.filter_perfect_subject"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design.filter_perfect_subject">[docs]</a>    @classmethod
    def filter_perfect_subject(cls, results):
        &quot;&quot;&quot;return only results whose subject is 100% aligned to query&quot;&quot;&quot;
        return [r for r in results if perfect_subject(r[&quot;subject&quot;])]</div>

    # # TODO: do a single blast and sort results based on record keys
    # def _blast(self):
    #     &quot;&quot;&quot;Preform blast of materials against queries.&quot;&quot;&quot;
    #     self.logger.info(&quot;Compiling assembly graph&quot;)
    #
    #     with Pool(processes=3) as pool:
    #         template_blast = self.blast_factory(self.TEMPLATES, self.QUERIES)
    #         template_blast.update_config(BLAST_PENALTY_CONFIG)
    #         self.container_factory.seqdb.update(template_blast.seq_db.records)
    #
    #         if self.blast_factory.record_groups[self.FRAGMENTS]:
    #             fragment_blast = self.blast_factory(self.FRAGMENTS, self.QUERIES)
    #             fragment_blast.update_config(BLAST_PENALTY_CONFIG)
    #             self.container_factory.seqdb.update(fragment_blast.seq_db.records)
    #         else:
    #             fragment_blast = None
    #
    #         if self.blast_factory.record_groups[self.PRIMERS]:
    #             primer_blast = self.blast_factory(self.PRIMERS, self.QUERIES)
    #             primer_blast.update_config(BLAST_PENALTY_CONFIG)
    #             self.container_factory.seqdb.update(primer_blast.seq_db.records)
    #         else:
    #             primer_blast = None
    #
    #         template_results, fragment_results, primer_results = pool.map(run_blast, (
    #             (template_blast, &#39;quick_blastn&#39;),
    #             (fragment_blast, &#39;quick_blastn&#39;),
    #             (primer_blast, &#39;quick_blastn_short&#39;)
    #         ))
    #
    #         fragment_results = self.filter_perfect_subject(fragment_results)
    #         primer_results = self.filter_perfect_subject(primer_results)
    #
    #         self.container_factory.load_blast_json(fragment_results, Constants.FRAGMENT)
    #         self.container_factory.load_blast_json(template_results, Constants.PCR_PRODUCT)
    #         self.container_factory.load_blast_json(primer_results, Constants.PRIMER)

    # non-threaded blast
    def _blast(self):
        # align templates
        template_blast = self.blast_factory(self.TEMPLATES, self.QUERIES)
        template_blast.update_config(BLAST_PENALTY_CONFIG)
        template_blast.quick_blastn()
        template_results = template_blast.get_perfect()
        self.template_results = template_results
        self.logger.info(&quot;Number of template matches: {}&quot;.format(len(template_results)))
        self.container_factory.seqdb.update(template_blast.seq_db.records)

        # align fragments
        if self.blast_factory.record_groups[self.FRAGMENTS]:
            fragment_blast = self.blast_factory(self.FRAGMENTS, self.QUERIES)
            fragment_blast.update_config(BLAST_PENALTY_CONFIG)
            fragment_blast.quick_blastn()
            fragment_results = self.filter_perfect_subject(fragment_blast.get_perfect())
            self.container_factory.seqdb.update(fragment_blast.seq_db.records)
            self.logger.info(
                &quot;Number of perfect fragment matches: {}&quot;.format(len(fragment_results))
            )
        else:
            fragment_results = []
        self.fragment_results = fragment_results

        # align primers
        if self.blast_factory.record_groups[self.PRIMERS]:
            primer_blast = self.blast_factory(self.PRIMERS, self.QUERIES)
            primer_blast.update_config(BLAST_PENALTY_CONFIG)
            primer_blast.quick_blastn_short()
            primer_results = self.filter_perfect_subject(primer_blast.get_perfect())
            self.container_factory.seqdb.update(primer_blast.seq_db.records)
            self.logger.info(
                &quot;Number of perfect primers: {}&quot;.format(len(primer_results))
            )
        else:
            primer_results = []
        self.primer_results = primer_results

        self.container_factory.load_blast_json(fragment_results, Constants.FRAGMENT)
        self.container_factory.load_blast_json(template_results, Constants.PCR_PRODUCT)
        self.container_factory.load_blast_json(primer_results, Constants.PRIMER)

    @property
    def containers(self):
        &quot;&quot;&quot;Iterable of alignment containers in this design.&quot;&quot;&quot;
        return self.container_factory.containers()

<div class="viewcode-block" id="Design.container_list"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design.container_list">[docs]</a>    def container_list(self):
        &quot;&quot;&quot;List of alignment containers in this design.&quot;&quot;&quot;
        return list(self.container_factory.containers().values())</div>

<div class="viewcode-block" id="Design.query_keys"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design.query_keys">[docs]</a>    def query_keys(self):
        &quot;&quot;&quot;List of query keys in this design.&quot;&quot;&quot;
        return list(self.container_factory.containers())</div>

    def assemble_graphs(self, n_cores=None):
        n_cores = n_cores or self.n_threads
        if n_cores &gt; 1:
            # with self.logger.timeit(&quot;INFO&quot;,
            #                         &quot;assembling graphs (n_graphs={}, threads={})&quot;.format(len(self.container_list()),
            #                                                                              n_cores)):
            graphs = self._assemble_graphs_with_threads(n_cores)
            return graphs
        return self._assemble_graphs_without_threads()

<div class="viewcode-block" id="Design._assemble_graphs_without_threads"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design._assemble_graphs_without_threads">[docs]</a>    def _assemble_graphs_without_threads(self):
        &quot;&quot;&quot;Assemble all assembly graphs for all queries in this design.&quot;&quot;&quot;
        for query_key, container in self.logger.tqdm(
            self.container_factory.containers().items(),
            &quot;INFO&quot;,
            desc=&quot;assembling graphs (threads=1)&quot;,
        ):
            self.graphs[query_key] = assemble_graph(container, self.span_cost)</div>

    def _assemble_graphs_with_threads(self, n_cores=None):
        query_keys, containers = zip(*self.container_factory.containers().items())
        graphs = multiprocessing_assemble_graph(
            containers, self.span_cost, n_cores=n_cores
        )
        for qk, g in zip(query_keys, graphs):
            self.graphs[qk] = g

<div class="viewcode-block" id="Design.compile"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design.compile">[docs]</a>    def compile(self, n_cores=None):
        &quot;&quot;&quot;Compile materials to assembly graph&quot;&quot;&quot;
        self.results = {}
        with self.logger.timeit(&quot;INFO&quot;, &quot;running blast&quot;):
            self._blast()
        self.assemble_graphs(n_cores=n_cores)</div>

    # def plot_matrix(self, matrix):
    # plot matrix
    # import pylab as plt
    # import seaborn as sns
    # import numpy as np
    #
    # plot_matrix = matrix.copy()
    # plot_matrix[plot_matrix == np.inf] = 10000
    # plot_matrix = np.nan_to_num(plot_matrix)
    #
    # fig = plt.figure(figsize=(24, 20))
    # ax = fig.gca()
    # step = 1
    # sns.heatmap(plot_matrix[::step, ::step], ax=ax)

    @staticmethod
    def _find_iter_alignment(a, b, alignments):
        for align in alignments:
            if a == align.query_region.a and b == align.query_region.b:
                yield align

    def path_to_edge_costs(self, path, graph):
        arr = []
        for n1, n2 in pairwise(path):
            edata = graph[n1][n2]
            arr.append((n1, n2, edata))
        return arr

    def path_to_df(self, paths_dict):

        fragments = []
        primers = []

        for qk, paths in paths_dict.items():
            paths = paths
            G = self.graphs[qk]
            container = self.container_factory.containers()[qk]

            record = self.container_factory.seqdb[qk]
            path = paths[0] + paths[0][:1]

            for n1, n2 in pairwise(path):
                edata = G[n1][n2]
                cost = edata[&quot;weight&quot;]
                if n1[2] == &quot;A&quot; and n2[2] == &quot;B&quot;:
                    A = n1[0]
                    B = n2[0]
                    group = container.find_groups_by_pos(A, B)[0]

                    if isinstance(group, AlignmentGroup):
                        align = group.alignments[0]
                        subject = align.subject_key
                        subject_rec = self.container_factory.seqdb[align.subject_key]
                        subject_rec_name = subject_rec.name
                        subject_seq = str(
                            subject_rec[
                                align.subject_region.a : align.subject_region.b
                            ].seq
                        )
                        subject_region = (
                            align.subject_region.a,
                            align.subject_region.b,
                        )
                    elif isinstance(group, ComplexAlignmentGroup):
                        names = []
                        seqs = []
                        regions = []
                        subject = []
                        for align in group.alignments:
                            subject.append(align.subject_key)
                            rec = self.container_factory.seqdb[align.subject_key]
                            seqs.append(
                                str(
                                    rec[
                                        align.subject_region.a : align.subject_region.b
                                    ].seq
                                )
                            )
                            regions.append(
                                (align.subject_region.a, align.subject_region.b)
                            )
                            names.append(rec.name)
                        subject_rec_name = &quot;, &quot;.join(names)
                        subject_seq = &quot;, &quot;.join(seqs)
                        subject_region = regions[:]
                        subject = &quot;,&quot;.join(subject)

                    fragments.append(
                        {
                            &quot;query&quot;: qk,
                            &quot;query_name&quot;: record.name,
                            &quot;query_region&quot;: (
                                group.query_region.a,
                                group.query_region.b,
                            ),
                            &quot;subject&quot;: subject,
                            &quot;subject_name&quot;: subject_rec_name,
                            &quot;subject_region&quot;: subject_region,
                            &quot;fragment_length&quot;: len(group.query_region),
                            &quot;fragment_seq&quot;: subject_seq,
                            &quot;cost&quot;: cost,
                            &quot;type&quot;: edata[&quot;type&quot;],
                        }
                    )

                    # TODO: design overhangs (how long?)
                    # if n1[1]:
                    #     primers.append({
                    #         &#39;query&#39;: qk,
                    #         &#39;query_name&#39;: record.name,
                    #         &#39;query_region&#39;: (align.query_region.a, align.query_region.b),
                    #         &#39;subject&#39;: sk,
                    #         &#39;subject_name&#39;: subject_rec.name,
                    #         &#39;subject_region&#39;: (align.subject_region.a, align.subject_region.a + 20),
                    #         &#39;anneal_seq&#39;: str(subject_rec[align.subject_region.a:align.subject_region.a + 20].seq),
                    #         &#39;overhang_seq&#39;: &#39;?&#39;,
                    #         &#39;cost&#39;: &#39;?&#39;,
                    #         &#39;type&#39;: &#39;PRIMER&#39;
                    #     })
                    # if n2[1]:
                    #     primers.append({
                    #         &#39;query&#39;: qk,
                    #         &#39;query_name&#39;: record.name,
                    #         &#39;query_region&#39;: (align.query_region.a, align.query_region.b),
                    #         &#39;subject&#39;: sk,
                    #         &#39;subject_name&#39;: subject_rec.name,
                    #         &#39;subject_region&#39;: (align.subject_region.b - 20, align.subject_region.b),
                    #         &#39;fragment_length&#39;: 0,
                    #         &#39;anneal_seq&#39;: str(subject_rec[align.subject_region.b-20:align.subject_region.b].reverse_complement().seq),
                    #         &#39;overhang_seq&#39;: &#39;?&#39;,
                    #         &#39;cost&#39;: &#39;?&#39;,
                    #         &#39;type&#39;: &#39;PRIMER&#39;
                    #     })

                else:
                    B = n1[0]
                    A = n2[0]
                    span = Span(
                        B, A, len(record), cyclic=is_circular(record), allow_wrap=True
                    )

                    # TODO: extending the gene synthesis
                    if not n1[1]:
                        span.b = span.b - 20
                    if not n2[1]:
                        span.a = span.a + 20

                    ranges = span.ranges()
                    frag_seq = record[ranges[0][0] : ranges[0][1]]
                    for r in ranges[1:]:
                        frag_seq += record[r[0] : r[1]]

                    fragments.append(
                        {
                            &quot;query&quot;: qk,
                            &quot;query_name&quot;: record.name,
                            &quot;query_region&quot;: (B, A),
                            &quot;subject&quot;: None,
                            &quot;subject_name&quot;: &quot;SYNTHESIS&quot;,
                            &quot;subject_region&quot;: None,
                            &quot;fragment_length&quot;: len(span),
                            &quot;fragment_seq&quot;: str(frag_seq.seq),
                            &quot;cost&quot;: cost,
                            &quot;type&quot;: edata[&quot;type&quot;],
                        }
                    )
        return pd.DataFrame(fragments), pd.DataFrame(primers)

    def optimize(self, n_paths=3, n_cores=None):
        n_cores = n_cores or self.n_threads
        if n_cores &gt; 1:
            with self.logger.timeit(
                &quot;INFO&quot;,
                &quot;optimizing graphs (n_graphs={}, threads={})&quot;.format(
                    len(self.graphs), n_cores
                ),
            ):
                return self._optimize_with_threads(n_paths, n_cores)
        return self._optimize_without_threads(n_paths)

    # TODO: n_paths to class attribute
<div class="viewcode-block" id="Design._optimize_without_threads"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.Design._optimize_without_threads">[docs]</a>    def _optimize_without_threads(
        self, n_paths=5
    ) -&gt; Dict[str, List[List[AssemblyNode]]]:
        &quot;&quot;&quot;Finds the optimal paths for each query in the design.&quot;&quot;&quot;
        results_dict = {}
        for query_key, graph, query_length, cyclic, result in self.logger.tqdm(
            self._collect_optimize_args(self.graphs),
            &quot;INFO&quot;,
            desc=&quot;optimizing graphs (n_graphs={}, threads=1)&quot;.format(len(self.graphs)),
        ):
            container = self.containers[query_key]
            query = container.seqdb[query_key]
            cyclic = is_circular(query)
            results_dict[query_key] = result
            paths = optimize_graph(graph, len(query), cyclic, n_paths)
            if not paths:
                query_rec = self.blast_factory.db.records[query_key]
                self.logger.error(
                    &quot;\n\tThere were no solutions found for design &#39;{}&#39; ({}).\n\tThis sequence may&quot;
                    &quot; be better synthesized. Use a tool such as JBEI&#39;s BOOST.&quot;.format(
                        query_rec.name, query_key
                    )
                )
            result.add_assemblies(paths)
        return results_dict</div>

    def _optimize_with_threads(self, n_paths=5, n_cores=10):
        results_dict = {}
        query_keys, graphs, query_lengths, cyclics, results = zip(
            *list(self._collect_optimize_args(self.graphs))
        )

        list_of_paths = multiprocessing_optimize_graph(
            graphs=graphs,
            query_lengths=query_lengths,
            cyclics=cyclics,
            n_paths=n_paths,
            n_cores=n_cores,
        )
        for qk, paths, result in zip(query_keys, list_of_paths, results):
            result.add_assemblies(paths)
            results_dict[qk] = result
        return results_dict

    def _collect_optimize_args(self, graphs):
        for query_key, graph in self.logger.tqdm(
            graphs.items(), &quot;INFO&quot;, desc=&quot;optimizing graphs&quot;
        ):
            container = self.containers[query_key]
            query = container.seqdb[query_key]
            cyclic = is_circular(query)
            result = DesignResult(container=container, query_key=query_key, graph=graph)
            yield query_key, graph, len(query), cyclic, result</div>

    # TODO: make this a method outside of class scope for multithreading.
    #       In order to do this, all of the methods will need to be scoped
    #       outside of the class, probably in its own file as &#39;design_algorithms.py&#39;


<div class="viewcode-block" id="LibraryDesign"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.LibraryDesign">[docs]</a>class LibraryDesign(Design):
    &quot;&quot;&quot;
    Design class for producing assemblies for libraries.
    &quot;&quot;&quot;

    DEFAULT_N_THREADS = 10

    def __init__(self, span_cost=None, n_threads=None):
        super().__init__(span_cost=span_cost, n_threads=n_threads)
        self.shared_alignments = []
        self._edges = []

    # @staticmethod
    # def _get_repeats_from_results(results):
    #     repeats = []
    #     for r in results:
    #         qk = r[&#39;query&#39;][&#39;origin_key&#39;]
    #         sk = r[&#39;subject&#39;][&#39;origin_key&#39;]
    #         if qk == sk:
    #             repeats.append((qk, r[&#39;query&#39;][&#39;start&#39;], r[&#39;query&#39;][&#39;end&#39;]))
    #     return repeats

    # TODO: why?
<div class="viewcode-block" id="LibraryDesign._get_iter_non_repeats"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.LibraryDesign._get_iter_non_repeats">[docs]</a>    def _get_iter_non_repeats(self, alignments: List[Alignment]):
        &quot;&quot;&quot;
        Return repeat regions of alignments. These are alignments that align
        to themselves.

        :param alignments:
        :return:
        &quot;&quot;&quot;
        for align in alignments:
            qk = align.query_key
            sk = align.subject_key
            if qk == sk:
                yield (qk, align.query_region.a, align.query_region.b)</div>

<div class="viewcode-block" id="LibraryDesign._share_query_blast"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.LibraryDesign._share_query_blast">[docs]</a>    def _share_query_blast(self):
        &quot;&quot;&quot;
        Find and use shared fragments across queries.

        :return:
        &quot;&quot;&quot;
        self.logger.info(&quot;=== Expanding shared library fragments ===&quot;)

        blast = self.blast_factory(self.QUERIES, self.QUERIES)
        blast.update_config(BLAST_PENALTY_CONFIG)
        blast.quick_blastn()

        results = blast.get_perfect()

        self.logger.info(
            &quot;Found {} shared alignments between the queries&quot;.format(len(results))
        )
        self.shared_alignments = results

        self.container_factory.seqdb.update(blast.seq_db.records)
        self.container_factory.load_blast_json(results, Constants.SHARED_FRAGMENT)

        # TODO: expand the normal fragments with the shared fragments
        for query_key, container in self.container_factory.containers().items():
            # expand the share fragments using their own endpoints
            original_shared_fragments = container.get_groups_by_types(
                Constants.SHARED_FRAGMENT
            )
            new_shared_fragments = container.expand_overlaps(
                original_shared_fragments, Constants.SHARED_FRAGMENT
            )

            self.logger.info(
                &quot;{}: Expanded {} shared from original {} shared fragments&quot;.format(
                    query_key, len(new_shared_fragments), len(original_shared_fragments)
                )
            )

            # expand the existing fragments with endpoints from the share alignments

            # TODO: what if there is no template for shared fragment?
            # TODO: shared fragment has to be contained wholly in another fragment
            new_alignments = container.expand_overlaps(
                container.get_groups_by_types(
                    [
                        Constants.FRAGMENT,
                        Constants.PCR_PRODUCT,
                        Constants.SHARED_FRAGMENT,
                    ]
                ),
                Constants.PCR_PRODUCT,
            )
            self.logger.info(
                &quot;{}: Expanded {} using {} and found {} new alignments.&quot;.format(
                    query_key,
                    Constants.PCR_PRODUCT,
                    Constants.SHARED_FRAGMENT,
                    len(new_alignments),
                )
            )
            # grab the pcr products and expand primer pairs (again)
            templates = container.get_groups_by_types(Constants.PCR_PRODUCT)
            new_primer_pairs = container.expand_primer_pairs(templates)
            self.logger.info(
                &quot;{}: Expanded {} {} using {}&quot;.format(
                    query_key,
                    len(new_primer_pairs),
                    &quot;PRODUCTS_WITH_PRIMERS&quot;,
                    Constants.SHARED_FRAGMENT,
                )
            )

        repeats = []
        for query_key, container in self.container_factory.containers().items():
            # get all shared fragments
            alignments = container.get_alignments_by_types(Constants.SHARED_FRAGMENT)
            self.logger.info(
                &quot;{} shared fragments for {}&quot;.format(len(alignments), query_key)
            )
            non_repeats = list(self._get_iter_non_repeats(alignments))
            self.logger.info(
                &quot;{} non repeats for {}&quot;.format(len(non_repeats), query_key)
            )
            # add to list of possible repeats
            # repeats += list(self._get_iter_non_repeats(alignments))
        self.repeats = repeats</div>

<div class="viewcode-block" id="LibraryDesign.compile_library"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.LibraryDesign.compile_library">[docs]</a>    def compile_library(self, n_cores=None):
        &quot;&quot;&quot;Compile the materials list into assembly graphs.&quot;&quot;&quot;
        n_cores = n_cores or self.DEFAULT_N_THREADS
        self.graphs = {}
        self._blast()
        self._share_query_blast()
        self.assemble_graphs(n_cores=n_cores)</div>

<div class="viewcode-block" id="LibraryDesign.optimize_library"><a class="viewcode-back" href="../../developer/_autosummary/dasi.design.html#dasi.design.LibraryDesign.optimize_library">[docs]</a>    def optimize_library(self):
        &quot;&quot;&quot;Optimize the assembly graph for library assembly.&quot;&quot;&quot;
        raise NotImplementedError</div></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>