<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.design &#8212; dasi 0.0.2 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"equationNumbers": {"autoNumber": "AMS", "useLabelIds": true}}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>



  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../developer/api_reference.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.design">Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.alignments">Alignments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.cost">Cost Calculations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.cost.params">Parameters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.utils">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.cost.utils">Cost utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../developer/api_reference.html#module-dasi.utils.networkx">Networkx utilities</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for dasi.design</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;Primer and synthesis design.&quot;&quot;&quot;
from __future__ import annotations

import bisect
from collections.abc import Iterable
from itertools import zip_longest
from typing import Dict
from typing import Generator
from typing import List
from typing import Sized
from typing import Tuple
from typing import Union

import networkx as nx
import numpy as np
import pandas as pd
from Bio.SeqRecord import SeqRecord
from more_itertools import pairwise
from pyblast import BioBlastFactory
from pyblast.utils import is_circular

from .design_algorithms import assemble_graph
from .design_algorithms import multiprocessing_assemble_graph
from .design_algorithms import multiprocessing_optimize_graph
from .design_algorithms import optimize_graph
from .graph_builder import AssemblyGraphBuilder
from dasi.alignments import Alignment
from dasi.alignments import AlignmentContainer
from dasi.alignments import AlignmentContainerFactory
from dasi.alignments import ComplexAlignmentGroup
from dasi.constants import Constants
from dasi.design.graph_builder import AssemblyNode
from dasi.exceptions import DasiDesignException
from dasi.log import logger
from dasi.utils import perfect_subject
from dasi.utils import sort_cycle

BLAST_PENALTY_CONFIG = {&quot;gapopen&quot;: 3, &quot;gapextend&quot;: 3, &quot;reward&quot;: 1, &quot;penalty&quot;: -5}


<div class="viewcode-block" id="DesignResult"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.DesignResult">[docs]</a>class DesignResult(Iterable):
    &quot;&quot;&quot;DesignResult container.

    Maintains a list of top assemblies.
    &quot;&quot;&quot;

    def __init__(
        self, container: AlignmentContainer, graph: nx.DiGraph, query_key: str
    ):
        self.container = container
        self.graph = graph
        self.query_key = query_key
        self.query = self.container.seqdb[query_key]
        self._assemblies = []
        self._keys = []

    @property
    def assemblies(self) -&gt; Tuple[Assembly, ...]:
        &quot;&quot;&quot;Return a tuple of all assemblies.

        :return: tuple of all assemblies.
        &quot;&quot;&quot;
        return tuple(self._assemblies)

    def _new(self, path: List[AssemblyNode]):
        return Assembly(path, self.container, self.graph, self.query_key, self.query)

<div class="viewcode-block" id="DesignResult.add_assembly"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.DesignResult.add_assembly">[docs]</a>    def add_assembly(self, path: List[AssemblyNode]):
        &quot;&quot;&quot;Add an assembly from a list of nodes.

        :param path: list of nodes
        :return: None
        &quot;&quot;&quot;
        assembly = self._new(path)
        cost = assembly.cost()
        n_nodes = len(assembly._nodes)
        k = (cost, n_nodes)
        i = bisect.bisect_left(self._keys, k)
        self._assemblies.insert(i, assembly)
        self._keys.insert(i, k)</div>

<div class="viewcode-block" id="DesignResult.add_assemblies"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.DesignResult.add_assemblies">[docs]</a>    def add_assemblies(self, paths: List[List[AssemblyNode]]):
        &quot;&quot;&quot;Adds a list of assemblies.

        :param paths: list of list of paths
        :return: None
        &quot;&quot;&quot;
        for path in paths:
            self.add_assembly(path)</div>

    def __iter__(self) -&gt; Generator[Assembly]:
        &quot;&quot;&quot;Yield assemblies.

        :yield: assembly
        &quot;&quot;&quot;
        for assembly in self.assemblies:
            yield assembly

    def __getitem__(self, item: str) -&gt; Assembly:
        return list(self)[item]

    def __str__(self):
        return &quot;&lt;{cls} query={qname} {qk} nassemblies={n}&gt;&quot;.format(
            cls=self.__class__.__name__,
            qname=self.query.name,
            qk=self.query_key,
            n=len(self.assemblies),
        )</div>


<div class="viewcode-block" id="Assembly"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Assembly">[docs]</a>class Assembly(Iterable):
    &quot;&quot;&quot;Should take in a path, graph, container, seqdb to produce relevant
    information.&quot;&quot;&quot;

    def __init__(
        self,
        nodes: List[AssemblyNode],
        container: AlignmentContainer,
        full_assembly_graph: nx.DiGraph,
        query_key: str,
        query: SeqRecord,
    ):
        self.logger = logger(self)
        self.container = container
        self.groups = container.groups()
        if len(self.groups) == 0:
            raise DasiDesignException(&quot;No groups were found in container.&quot;)
        self.query_key = query_key
        self.query = query
        self._nodes = tuple(nodes)
        self._full_graph = full_assembly_graph
        self.graph = self._subgraph(self._full_graph, nodes)
        nx.freeze(self.graph)

    @staticmethod
    def _missing_edata():
        return {
            &quot;cost&quot;: np.inf,
            &quot;weight&quot;: np.inf,
            &quot;material&quot;: np.inf,
            &quot;efficiency&quot;: 0.0,
            &quot;type&quot;: Constants.MISSING,
            &quot;span&quot;: np.inf,
            &quot;name&quot;: &quot;missing&quot;,
            &quot;internal_or_external&quot;: &quot;missing&quot;,
        }

    def _subgraph(self, graph: nx.DiGraph, nodes: List[AssemblyNode]):
        def _resolve(node: AssemblyNode, qregion) -&gt; Tuple[AssemblyNode, dict]:
            new_node = AssemblyNode(qregion.t(node.index), *list(node)[1:])
            return new_node, {}

        subgraph = nx.OrderedDiGraph()
        nodes = [AssemblyNode(*n) for n in nodes]
        example_query_region = self.container.alignments[0].query_region

        resolved_nodes = [_resolve(node, example_query_region) for node in nodes]
        if self.cyclic:
            resolved_nodes = sort_cycle(
                resolved_nodes, key=lambda n: (n[0].type, n[0].index, n)
            )
        subgraph.add_nodes_from(resolved_nodes)

        if self.cyclic:
            pair_iter = list(pairwise(nodes + nodes[:1]))
        else:
            pair_iter = list(pairwise(nodes))

        for n1, n2 in pair_iter:
            edata = graph.get_edge_data(n1, n2)
            if edata is None:
                edata = self._missing_edata()
            else:
                assert &quot;internal_or_external&quot; in edata

            # TODO: fix query_region (overlaps are backwards)
            query_region = self.container.alignments[0].query_region.new(
                n1.index, n2.index
            )
            groups = self.container.find_groups_by_pos(
                query_region.a,
                query_region.b,
                group_type=edata[&quot;type&quot;],
                groups=self.groups,
            )
            if edata[&quot;internal_or_external&quot;] == &quot;internal&quot; and not groups:
                raise DasiDesignException(
                    &quot;Missing groups for edge between {} and {}&quot;.format(n1, n2)
                )

            edata[&quot;groups&quot;] = groups
            edata[&quot;query_region&quot;] = query_region
            subgraph.add_edge(
                _resolve(n1, query_region)[0], _resolve(n2, query_region)[0], **edata
            )
        return subgraph

    @property
    def cyclic(self):
        return is_circular(self.query)

    # TODO: consolidate this with shortest path utils in networkx
    def cost(self):
        material = 0
        efficiency = 1.0
        for _, _, edata in self.edges():
            material += edata[&quot;material&quot;]
            efficiency *= edata[&quot;efficiency&quot;]
        if efficiency == 0:
            return np.inf
        return material / efficiency

    def edges(self, data=True) -&gt; Iterable[Tuple[AssemblyNode, AssemblyNode, Dict]]:
        return self.graph.edges(data=data)

    def nodes(self, data=True) -&gt; Iterable[Tuple[AssemblyNode, Dict]]:
        return self.graph.nodes(data=data)

    def edit_distance(
        self, other: Assembly, explain=False
    ) -&gt; Union[int, Tuple[int, List[Tuple[int, str]]]]:
        differences = []
        for i, (n1, n2) in enumerate(
            zip_longest(self.nodes(data=False), other.nodes(data=False))
        ):
            if n1 is None or n2 is None:
                differences.append((i, &quot;{} != {}&quot;.format(n1, n2)))
                continue
            if n1.index != n2.index:
                differences.append((i, &quot;Index: {} != {}&quot;.format(n1.index, n2.index)))
            if n1.expandable != n2.expandable:
                differences.append(
                    (i, &quot;Expandable: {} != {}&quot;.format(n1.expandable, n2.expandable))
                )
            if n1.type != n2.type:
                differences.append((i, &quot;Type: {} != {}&quot;.format(n1.type, n2.type)))
            if n1.overhang != n2.overhang:
                differences.append(
                    (i, &quot;Overhang: {} != {}&quot;.format(n1.overhang, n2.overhang))
                )
        dist = len(differences)
        if explain:
            return dist, differences
        return dist

    def print(self):
        print(&quot;query_name: {}&quot;.format(self.query.name))
        print(&quot;query_key: {}&quot;.format(self.query_key))
        print(&quot;Cost: {}&quot;.format(self.cost()))
        df = self.to_df()
        print(df)

    def print_diff(self, other: Assembly):
        for i, (n1, n2) in enumerate(
            zip_longest(self.nodes(data=False), other.nodes(data=False))
        ):
            if n1 != n2:
                desc = False
            else:
                desc = True
            print(&quot;{} {} {}&quot;.format(desc, n1, n2))

    def to_df(self):
        rows = []
        for n1, n2, edata in self.edges():
            groups = edata[&quot;groups&quot;]

            if groups:
                group = groups[0]
                if isinstance(group, ComplexAlignmentGroup):
                    alignments = group.alignments
                else:
                    alignments = group.alignments[:1]
            else:
                alignments = []
            subject_keys = [a.subject_key for a in alignments]
            subject_names = [self.container.seqdb[key].name for key in subject_keys]
            subject_starts = [a.subject_region.a for a in alignments]
            subject_ends = [a.subject_region.b for a in alignments]

            rows.append(
                {
                    &quot;query_start&quot;: edata[&quot;query_region&quot;].a,
                    &quot;query_end&quot;: edata[&quot;query_region&quot;].b,
                    &quot;subject_names&quot;: subject_names,
                    &quot;subject_keys&quot;: subject_keys,
                    &quot;subject_start&quot;: subject_starts,
                    &quot;subject_ends&quot;: subject_ends,
                    &quot;cost&quot;: edata[&quot;cost&quot;],
                    &quot;material&quot;: edata[&quot;material&quot;],
                    &quot;span&quot;: edata[&quot;span&quot;],
                    &quot;type&quot;: edata[&quot;type&quot;],
                    &quot;name&quot;: edata[&quot;name&quot;],
                    &quot;internal_or_external&quot;: edata[&quot;internal_or_external&quot;],
                    &quot;efficiency&quot;: edata.get(&quot;efficiency&quot;, np.nan),
                }
            )

        df = pd.DataFrame(rows)
        return df

    def __eq__(self, other: Assembly) -&gt; bool:
        return self.edit_distance(other) == 0

    def __iter__(self) -&gt; Generator[AssemblyNode]:
        for n in self.nodes(data=False):
            yield n</div>


def run_blast(args):
    if args is None or args[0] is None:
        return []
    blast, func_str = args
    func = getattr(blast, func_str)
    func()
    return blast.get_perfect()


class FakePool:
    def __init__(self, *args, **kwargs):
        pass

    def __enter__(self):
        return FakePool()

    def __exit__(self, a, b, c):
        pass

    @staticmethod
    def map(func, args):
        return [func(arg) for arg in args]


<div class="viewcode-block" id="Design"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design">[docs]</a>class Design:
    &quot;&quot;&quot;Design class that returns optimal assemblies from a set of materials.&quot;&quot;&quot;

    PRIMERS = &quot;primers&quot;
    TEMPLATES = &quot;templates&quot;
    QUERIES = &quot;queries&quot;
    FRAGMENTS = &quot;fragments&quot;
    DEFAULT_N_JOBS = 1

    def __init__(self, span_cost=None, seqdb=None, n_jobs=None):
        &quot;&quot;&quot;

        :param span_cost:
        :type span_cost: SpanCost
        :param seqdb:
        :type seqdb: dict
        :param n_jobs:
        :type n_jobs: int
        &quot;&quot;&quot;
        self.blast_factory = BioBlastFactory()
        self.logger = logger(self)

        # graph by query_key
        if seqdb is None:
            seqdb = {}
        self._seqdb = seqdb
        self.span_cost = span_cost
        self.graphs = {}
        self.results = {}
        self.template_results = []
        self.fragment_results = []
        self.primer_results = []
        self.container_factory = AlignmentContainerFactory(self.seqdb)
        self.n_jobs = n_jobs or self.DEFAULT_N_JOBS

    @property
    def seqdb(self) -&gt; Dict[str, SeqRecord]:
        return self._seqdb

    def add_materials(
        self,
        primers: List[SeqRecord],
        templates: List[SeqRecord],
        queries: List[SeqRecord],
        fragments=None,
    ):
        if fragments is None:
            fragments = []
        self.add_primers(primers)
        fragments = self.filter_linear_records(fragments)
        self.add_templates(templates + fragments)
        self.add_queries(queries)
        self.add_fragments(fragments)

<div class="viewcode-block" id="Design.add_primers"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design.add_primers">[docs]</a>    def add_primers(self, primers: List[SeqRecord]):
        &quot;&quot;&quot;Add primer sequences to materials list.&quot;&quot;&quot;
        self.blast_factory.add_records(primers, self.PRIMERS)
        self.logger.info(&quot;Added {} primers&quot;.format(len(primers)))</div>

<div class="viewcode-block" id="Design.add_templates"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design.add_templates">[docs]</a>    def add_templates(self, templates: List[SeqRecord]):
        &quot;&quot;&quot;Add template sequences to materials list.&quot;&quot;&quot;
        self.blast_factory.add_records(templates, self.TEMPLATES)
        self.logger.info(&quot;Added {} templates&quot;.format(len(templates)))</div>

<div class="viewcode-block" id="Design.add_queries"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design.add_queries">[docs]</a>    def add_queries(self, queries: List[SeqRecord]):
        &quot;&quot;&quot;Add goal/query sequences to materials list.&quot;&quot;&quot;
        self.blast_factory.add_records(queries, self.QUERIES)
        self.logger.info(&quot;Added {} queries&quot;.format(len(queries)))</div>

<div class="viewcode-block" id="Design.add_fragments"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design.add_fragments">[docs]</a>    def add_fragments(self, fragments: List[SeqRecord]):
        &quot;&quot;&quot;Add fragment sequences to materials list.&quot;&quot;&quot;
        self.blast_factory.add_records(fragments, self.FRAGMENTS)
        self.logger.info(&quot;Added {} queries&quot;.format(len(fragments)))</div>
        # self.blast_factory.add_records(fragments, self.TEMPLATES)

<div class="viewcode-block" id="Design.filter_linear_records"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design.filter_linear_records">[docs]</a>    @classmethod
    def filter_linear_records(cls, records: List[SeqRecord]) -&gt; List[SeqRecord]:
        &quot;&quot;&quot;Return only linear records.&quot;&quot;&quot;
        return [r for r in records if not is_circular(r)]</div>

<div class="viewcode-block" id="Design.filter_perfect_subject"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design.filter_perfect_subject">[docs]</a>    @classmethod
    def filter_perfect_subject(cls, results: dict) -&gt; List[dict]:
        &quot;&quot;&quot;return only results whose subject is 100% aligned to query.&quot;&quot;&quot;
        return [r for r in results if perfect_subject(r[&quot;subject&quot;])]</div>

    # non-threaded blast
    def _blast(self):
        # align templates
        template_blast = self.blast_factory(self.TEMPLATES, self.QUERIES)
        template_blast.update_config(BLAST_PENALTY_CONFIG)
        template_blast.quick_blastn()
        template_results = template_blast.get_perfect()
        self.template_results = template_results
        self.logger.info(&quot;Number of template matches: {}&quot;.format(len(template_results)))
        self.container_factory.seqdb.update(template_blast.seq_db.records)

        # align fragments
        if self.blast_factory.record_groups[self.FRAGMENTS]:
            fragment_blast = self.blast_factory(self.FRAGMENTS, self.QUERIES)
            fragment_blast.update_config(BLAST_PENALTY_CONFIG)
            fragment_blast.quick_blastn()
            fragment_results = self.filter_perfect_subject(fragment_blast.get_perfect())
            self.container_factory.seqdb.update(fragment_blast.seq_db.records)
            self.logger.info(
                &quot;Number of perfect fragment matches: {}&quot;.format(len(fragment_results))
            )
        else:
            fragment_results = []
        self.fragment_results = fragment_results

        # align primers
        if self.blast_factory.record_groups[self.PRIMERS]:
            primer_blast = self.blast_factory(self.PRIMERS, self.QUERIES)
            primer_blast.update_config(BLAST_PENALTY_CONFIG)
            primer_blast.quick_blastn_short()
            primer_results = self.filter_perfect_subject(primer_blast.get_perfect())
            self.container_factory.seqdb.update(primer_blast.seq_db.records)
            self.logger.info(
                &quot;Number of perfect primers: {}&quot;.format(len(primer_results))
            )
        else:
            primer_results = []
        self.primer_results = primer_results

        self.container_factory.load_blast_json(fragment_results, Constants.FRAGMENT)
        self.container_factory.load_blast_json(template_results, Constants.PCR_PRODUCT)
        self.container_factory.load_blast_json(primer_results, Constants.PRIMER)

    @property
    def containers(self) -&gt; Dict[str, AlignmentContainer]:
        &quot;&quot;&quot;Iterable of alignment containers in this design.&quot;&quot;&quot;
        return self.container_factory.containers()

<div class="viewcode-block" id="Design.container_list"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design.container_list">[docs]</a>    def container_list(self) -&gt; List[AlignmentContainer]:
        &quot;&quot;&quot;List of alignment containers in this design.&quot;&quot;&quot;
        return list(self.container_factory.containers().values())</div>

<div class="viewcode-block" id="Design.query_keys"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design.query_keys">[docs]</a>    def query_keys(self) -&gt; List[str]:
        &quot;&quot;&quot;List of query keys in this design.&quot;&quot;&quot;
        return list(self.container_factory.containers())</div>

    def assemble_graphs(self, n_jobs=None):
        n_jobs = n_jobs or self.n_jobs
        if n_jobs &gt; 1:
            with self.logger.timeit(
                &quot;DEBUG&quot;,
                &quot;assembling graphs (n_graphs={}, threads={})&quot;.format(
                    len(self.container_list()), n_jobs
                ),
            ):
                self._assemble_graphs_with_threads(n_jobs)
        else:
            self._assemble_graphs_without_threads()

<div class="viewcode-block" id="Design._assemble_graphs_without_threads"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design._assemble_graphs_without_threads">[docs]</a>    def _assemble_graphs_without_threads(self):
        &quot;&quot;&quot;Assemble all assembly graphs for all queries in this design.&quot;&quot;&quot;
        for query_key, container in self.logger.tqdm(
            self.container_factory.containers().items(),
            &quot;INFO&quot;,
            desc=&quot;assembling graphs (threads=1)&quot;,
        ):
            self.graphs[query_key], _ = assemble_graph(container, self.span_cost)</div>

    def _assemble_graphs_with_threads(self, n_jobs=None):
        query_keys, containers = zip(*self.container_factory.containers().items())

        graphs = multiprocessing_assemble_graph(
            self.container_factory, self.span_cost, n_jobs=n_jobs
        )

        # update graphs dict
        for qk, g, c in zip(query_keys, graphs, containers):
            self.graphs[qk] = g

<div class="viewcode-block" id="Design.compile"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design.compile">[docs]</a>    def compile(self, n_jobs=None):
        &quot;&quot;&quot;Compile materials to assembly graph.&quot;&quot;&quot;
        self.results = {}
        with self.logger.timeit(&quot;DEBUG&quot;, &quot;running blast&quot;):
            self._blast()
        self.assemble_graphs(n_jobs=n_jobs)</div>

    # def plot_matrix(self, matrix):
    # plot matrix
    # import pylab as plt
    # import seaborn as sns
    # import numpy as np
    #
    # plot_matrix = matrix.copy()
    # plot_matrix[plot_matrix == np.inf] = 10000
    # plot_matrix = np.nan_to_num(plot_matrix)
    #
    # fig = plt.figure(figsize=(24, 20))
    # ax = fig.gca()
    # step = 1
    # sns.heatmap(plot_matrix[::step, ::step], ax=ax)

    @staticmethod
    def _find_iter_alignment(a: int, b: int, alignments: Iterable[Alignment]):
        for align in alignments:
            if a == align.query_region.a and b == align.query_region.b:
                yield align

    @staticmethod
    def path_to_edge_costs(
        path: List[AssemblyNode], graph: nx.DiGraph
    ) -&gt; List[Tuple[AssemblyNode, AssemblyNode, dict]]:
        arr = []
        for n1, n2 in pairwise(path):
            edata = graph[n1][n2]
            arr.append((n1, n2, edata))
        return arr

    def optimize(self, n_paths=3, n_jobs=None) -&gt; Dict[str, List[List[AssemblyNode]]]:
        n_jobs = n_jobs or self.n_jobs
        if n_jobs &gt; 1:
            with self.logger.timeit(
                &quot;DEBUG&quot;,
                &quot;optimizing graphs (n_graphs={}, threads={})&quot;.format(
                    len(self.graphs), n_jobs
                ),
            ):
                return self._optimize_with_threads(n_paths, n_jobs)
        else:
            return self._optimize_without_threads(n_paths)

    # TODO: n_paths to class attribute
<div class="viewcode-block" id="Design._optimize_without_threads"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.Design._optimize_without_threads">[docs]</a>    def _optimize_without_threads(self, n_paths) -&gt; Dict[str, List[List[AssemblyNode]]]:
        &quot;&quot;&quot;Finds the optimal paths for each query in the design.&quot;&quot;&quot;
        results_dict = {}
        for query_key, graph, query_length, cyclic, result in self.logger.tqdm(
            self._collect_optimize_args(self.graphs),
            &quot;INFO&quot;,
            desc=&quot;optimizing graphs (n_graphs={}, threads=1)&quot;.format(len(self.graphs)),
        ):

            container = self.containers[query_key]
            query = container.seqdb[query_key]
            cyclic = is_circular(query)
            results_dict[query_key] = result
            paths = optimize_graph(graph, len(query), cyclic, n_paths)
            if not paths:
                query_rec = self.blast_factory.db.records[query_key]
                self.logger.error(
                    &quot;\n\tThere were no solutions found for design &#39;{}&#39; ({}).\n\t&quot;
                    &quot;This sequence may be better synthesized. Use a tool such as JBEI&#39;s&quot;
                    &quot; BOOST.&quot;.format(query_rec.name, query_key)
                )
            result.add_assemblies(paths)
        return results_dict</div>

    def _optimize_with_threads(
        self, n_paths=5, n_jobs=10
    ) -&gt; Dict[str, List[List[AssemblyNode]]]:
        results_dict = {}
        query_keys, graphs, query_lengths, cyclics, results = zip(
            *list(self._collect_optimize_args(self.graphs))
        )

        list_of_paths = multiprocessing_optimize_graph(
            graphs=graphs,
            query_lengths=query_lengths,
            cyclics=cyclics,
            n_paths=n_paths,
            n_jobs=n_jobs,
        )
        for qk, paths, result in zip(query_keys, list_of_paths, results):
            result.add_assemblies(paths)
            results_dict[qk] = result
        return results_dict

    def _collect_optimize_args(
        self, graphs: Dict[str, nx.DiGraph]
    ) -&gt; Tuple[str, nx.DiGraph, bool, dict]:
        for query_key, graph in self.logger.tqdm(
            graphs.items(), &quot;INFO&quot;, desc=&quot;optimizing graphs&quot;
        ):
            container = self.containers[query_key]
            query = container.seqdb[query_key]
            cyclic = is_circular(query)
            result = DesignResult(container=container, query_key=query_key, graph=graph)
            yield query_key, graph, len(query), cyclic, result</div>


<div class="viewcode-block" id="LibraryDesign"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.LibraryDesign">[docs]</a>class LibraryDesign(Design):
    &quot;&quot;&quot;Design class for producing assemblies for libraries.&quot;&quot;&quot;

    DEFAULT_N_JOBS = 10

    def __init__(self, span_cost=None, n_jobs=None):
        super().__init__(span_cost=span_cost, n_jobs=n_jobs)
        self.shared_alignments = []
        self._edges = []

    # @staticmethod
    # def _get_repeats_from_results(results):
    #     repeats = []
    #     for r in results:
    #         qk = r[&#39;query&#39;][&#39;origin_key&#39;]
    #         sk = r[&#39;subject&#39;][&#39;origin_key&#39;]
    #         if qk == sk:
    #             repeats.append((qk, r[&#39;query&#39;][&#39;start&#39;], r[&#39;query&#39;][&#39;end&#39;]))
    #     return repeats

    # TODO: why?
<div class="viewcode-block" id="LibraryDesign._get_iter_non_repeats"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.LibraryDesign._get_iter_non_repeats">[docs]</a>    @staticmethod
    def _get_iter_non_repeats(alignments: List[Alignment]) -&gt; Tuple[str, int, int]:
        &quot;&quot;&quot;Return repeat regions of alignments. These are alignments that align
        to themselves.

        :param alignments:
        :return:
        &quot;&quot;&quot;
        for align in alignments:
            qk = align.query_key
            sk = align.subject_key
            if qk == sk:
                yield (qk, align.query_region.a, align.query_region.b)</div>

<div class="viewcode-block" id="LibraryDesign._share_query_blast"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.LibraryDesign._share_query_blast">[docs]</a>    def _share_query_blast(self):
        &quot;&quot;&quot;Find and use shared fragments across queries.

        :return:
        &quot;&quot;&quot;
        self.logger.info(&quot;=== Expanding shared library fragments ===&quot;)

        blast = self.blast_factory(self.QUERIES, self.QUERIES)
        blast.update_config(BLAST_PENALTY_CONFIG)
        blast.quick_blastn()

        results = blast.get_perfect()

        self.logger.info(
            &quot;Found {} shared alignments between the queries&quot;.format(len(results))
        )
        self.shared_alignments = results

        self.container_factory.seqdb.update(blast.seq_db.records)
        self.container_factory.load_blast_json(results, Constants.SHARED_FRAGMENT)

        # TODO: expand the normal fragments with the shared fragments
        for query_key, container in self.container_factory.containers().items():
            # expand the share fragments using their own endpoints
            original_shared_fragments = container.get_groups_by_types(
                Constants.SHARED_FRAGMENT
            )
            new_shared_fragments = container.expand_overlaps(
                original_shared_fragments, Constants.SHARED_FRAGMENT
            )

            self.logger.info(
                &quot;{}: Expanded {} shared from original {} shared fragments&quot;.format(
                    query_key, len(new_shared_fragments), len(original_shared_fragments)
                )
            )

            # expand the existing fragments with endpoints from the share alignments

            # TODO: what if there is no template for shared fragment?
            # TODO: shared fragment has to be contained wholly in another fragment
            new_alignments = container.expand_overlaps(
                container.get_groups_by_types(
                    [
                        Constants.FRAGMENT,
                        Constants.PCR_PRODUCT,
                        Constants.SHARED_FRAGMENT,
                    ]
                ),
                Constants.PCR_PRODUCT,
            )
            self.logger.info(
                &quot;{}: Expanded {} using {} and found {} new alignments.&quot;.format(
                    query_key,
                    Constants.PCR_PRODUCT,
                    Constants.SHARED_FRAGMENT,
                    len(new_alignments),
                )
            )
            # grab the pcr products and expand primer pairs (again)
            templates = container.get_groups_by_types(Constants.PCR_PRODUCT)
            new_primer_pairs = container.expand_primer_pairs(templates)
            self.logger.info(
                &quot;{}: Expanded {} {} using {}&quot;.format(
                    query_key,
                    len(new_primer_pairs),
                    &quot;PRODUCTS_WITH_PRIMERS&quot;,
                    Constants.SHARED_FRAGMENT,
                )
            )

        repeats = []
        for query_key, container in self.container_factory.containers().items():
            # get all shared fragments
            alignments = container.get_alignments_by_types(Constants.SHARED_FRAGMENT)
            self.logger.info(
                &quot;{} shared fragments for {}&quot;.format(len(alignments), query_key)
            )
            non_repeats = list(self._get_iter_non_repeats(alignments))
            self.logger.info(
                &quot;{} non repeats for {}&quot;.format(len(non_repeats), query_key)
            )
            # add to list of possible repeats
            # repeats += list(self._get_iter_non_repeats(alignments))
        self.repeats = repeats</div>

<div class="viewcode-block" id="LibraryDesign.compile_library"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.LibraryDesign.compile_library">[docs]</a>    def compile_library(self, n_jobs=None):
        &quot;&quot;&quot;Compile the materials list into assembly graphs.&quot;&quot;&quot;
        n_jobs = n_jobs or self.DEFAULT_N_JOBS
        self.graphs = {}
        self._blast()
        self._share_query_blast()
        self.assemble_graphs(n_jobs=n_jobs)</div>

<div class="viewcode-block" id="LibraryDesign.optimize_library"><a class="viewcode-back" href="../../developer/api_reference.html#dasi.design.LibraryDesign.optimize_library">[docs]</a>    def optimize_library(self):
        &quot;&quot;&quot;Optimize the assembly graph for library assembly.&quot;&quot;&quot;
        raise NotImplementedError</div></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>