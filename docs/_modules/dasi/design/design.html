<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.design.design &#8212; dasi 0.0.14 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/style.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>



  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.14</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../design.html">Design (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.design</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.Design.html">dasi.design.Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.LibraryDesign.html">dasi.design.LibraryDesign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.DesignResult.html">dasi.design.DesignResult</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Models (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.models</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Assembly.html">dasi.models.Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AssemblyNode.html">dasi.models.AssemblyNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Molecule.html">dasi.models.Molecule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.MoleculeType.html">dasi.models.MoleculeType</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Reaction.html">dasi.models.Reaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentGroup.html">dasi.models.AlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentGroupBase.html">dasi.models.AlignmentGroupBase</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.MultiPCRProductAlignmentGroup.html">dasi.models.MultiPCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.PCRProductAlignmentGroup.html">dasi.models.PCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentContainer.html">dasi.models.AlignmentContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentContainerFactory.html">dasi.models.AlignmentContainerFactory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../models.html#modules">modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.alignment.html">dasi.models.alignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.alignment_container.html">dasi.models.alignment_container</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cost.html">Cost Model (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.cost</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../cost.html#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.cost.utils.html">dasi.cost.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../command_line.html">Command Line (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.command_line</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">Utilities (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.utils</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../utils.html#utility-modules">Utility modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.npdf.html">dasi.utils.npdf</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.region.html">dasi.utils.region</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.sequence_design.html">dasi.utils.sequence_design</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../utils.html#networkx-utilities">Networkx utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.exceptions.html">dasi.utils.networkx.exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.shortest_path.html">dasi.utils.networkx.shortest_path</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.utils.html">dasi.utils.networkx.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../exceptions.html">Exceptions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.exceptions</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../constants.html">Constants (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.constants</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../usage.html#installation">Installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../schemas/schemas.html">JSON Schemas</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#default-cost-parameters">Default Cost Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#cost-parameter-schema">Cost Parameter Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../schemas/schemas.html#cost-parameters-schema">Cost Parameters Schema</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#design-output-schema">Design Output Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../schemas/schemas.html#dasi-design-output">DASi design output</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guidelines.html">Code Guidelines</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for dasi.design.design</h1><div class="highlight"><pre>
<span></span>r&quot;&quot;&quot;
Design (:mod:`dasi.design`)
=============================

.. currentmodule:: dasi.design

This module provide DNA assembly functionality for DASi.
&quot;&quot;&quot;
import bisect
import functools
import operator
from typing import Dict
from typing import Generator
from typing import Iterable
from typing import List
from typing import Tuple

import networkx as nx
import pandas as pd
from Bio.SeqRecord import SeqRecord
from more_itertools import pairwise
from pyblast import BioBlastFactory
from pyblast.utils import is_circular

from .design_algorithms import assemble_graph
from .design_algorithms import multiprocessing_assemble_graph
from .design_algorithms import multiprocessing_optimize_graph
from .graph_builder import AssemblyGraphPostProcessor
from .optimize import optimize_graph
from dasi.__version__ import __title__
from dasi.__version__ import __version__
from dasi.constants import Constants
from dasi.cost import cached_span_cost
from dasi.cost import SpanCost
from dasi.design.graph_builder import AssemblyNode
from dasi.design.output import dasi_design_to_output_json
from dasi.design.output import validate_output
from dasi.design.report import Report
from dasi.exceptions import DasiDesignException
from dasi.exceptions import DasiInvalidMolecularAssembly
from dasi.log import logger
from dasi.models import Alignment
from dasi.models import AlignmentContainer
from dasi.models import AlignmentContainerFactory
from dasi.models import Assembly
from dasi.utils import log_metadata
from dasi.utils import log_times
from dasi.utils import perfect_subject
from dasi.utils.sequence_generator import fake_designs

BLAST_PENALTY_CONFIG = {
    &quot;gapopen&quot;: 3,
    &quot;gapextend&quot;: 3,
    &quot;reward&quot;: 1,
    &quot;penalty&quot;: -5,
    &quot;ungapped&quot;: None,
}


<div class="viewcode-block" id="DesignResult"><a class="viewcode-back" href="../../../generated/dasi.design.DesignResult.html#dasi.design.DesignResult">[docs]</a>class DesignResult(Iterable):
    &quot;&quot;&quot;DesignResult container.

    Maintains a list of top assemblies.
    &quot;&quot;&quot;

<div class="viewcode-block" id="DesignResult.__init__"><a class="viewcode-back" href="../../../generated/dasi.design.DesignResult.html#dasi.design.DesignResult.__init__">[docs]</a>    def __init__(
        self, container: AlignmentContainer, graph: nx.DiGraph, query_key: str
    ):
        self.container = container
        self.graph = graph
        self.query_key = query_key
        self.query = self.container.seqdb[query_key]
        self._assemblies = []
        self._keys = []</div>

    @property
    def seqdb(self):
        return self.container.seqdb

    @property
    def assemblies(self) -&gt; Tuple[Assembly, ...]:
        &quot;&quot;&quot;Return a tuple of all assemblies.

        :return: tuple of all assemblies.
        &quot;&quot;&quot;
        return tuple(self._assemblies)

    def _add_assembly_from_path(self, path: List[AssemblyNode]):
        return Assembly(
            path,
            self.container,
            self.graph,
            self.query_key,
            self.query,
            seqdb=self.seqdb,
            do_raise=False,
        )

<div class="viewcode-block" id="DesignResult.add_assembly"><a class="viewcode-back" href="../../../generated/dasi.design.DesignResult.html#dasi.design.DesignResult.add_assembly">[docs]</a>    def add_assembly(
        self,
        path: List[AssemblyNode],
        ignore_invalid: bool = False,
        allow_invalid: bool = False,
    ):
        &quot;&quot;&quot;Add an assembly from a list of nodes.

        :param path: list of nodes
        :return: None
        &quot;&quot;&quot;

        assembly = self._add_assembly_from_path(path)

        # Validate the assembly
        try:
            assembly.post_validate()
        except DasiInvalidMolecularAssembly as e:
            if ignore_invalid:
                return
            elif not allow_invalid:
                raise e

        cost = assembly.cost()
        n_nodes = len(assembly._nodes)
        k = (cost, n_nodes)
        i = bisect.bisect_left(self._keys, k)
        self._assemblies.insert(i, assembly)
        self._keys.insert(i, k)
        return assembly</div>

<div class="viewcode-block" id="DesignResult.add_assemblies"><a class="viewcode-back" href="../../../generated/dasi.design.DesignResult.html#dasi.design.DesignResult.add_assemblies">[docs]</a>    def add_assemblies(
        self,
        paths: List[List[AssemblyNode]],
        ignore_invalid: bool = False,
        allow_invalid: bool = False,
    ):
        &quot;&quot;&quot;Adds a list of assemblies.

        :param paths: list of list of paths
        :return: None
        &quot;&quot;&quot;
        for path in paths:
            self.add_assembly(
                path, ignore_invalid=ignore_invalid, allow_invalid=allow_invalid
            )</div>

    #
    #
    #     for a in self.assemblies:
    #         for n1, n2, edata in a.edges():
    #             result = edata[&quot;sequence_result&quot;]
    #             mol_type = edata[&quot;type_def&quot;]
    #             if mol_type.int_or_ext == &quot;internal&quot;:
    #                 pass
    #                 # add a new reaction
    #                 # add template
    #                 # add primers
    #             elif mol_type.use_direct:
    #                 pass
    #                 # add fragment
    #             elif mol_type.synthesize:
    #                 pass
    #                 # add synthesize
    #             else:
    #                 pass
    #                 # raise Exception

    def __iter__(self) -&gt; Generator[Assembly, None, None]:
        &quot;&quot;&quot;Yield assemblies.

        :yield: assembly
        &quot;&quot;&quot;
        for assembly in self.assemblies:
            yield assembly

    def __getitem__(self, item: str) -&gt; Assembly:
        return list(self)[item]

    def __str__(self):
        return &quot;&lt;{cls} query={qname} {qk} nassemblies={n}&gt;&quot;.format(
            cls=self.__class__.__name__,
            qname=self.query.name,
            qk=self.query_key,
            n=len(self.assemblies),
        )</div>


class FakePool:
    def __init__(self, *args, **kwargs):
        pass

    def __enter__(self):
        return FakePool()

    def __exit__(self, a, b, c):
        pass

    @staticmethod
    def map(func, args):
        return [func(arg) for arg in args]


<div class="viewcode-block" id="Design"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design">[docs]</a>class Design:
    &quot;&quot;&quot;Design class that returns optimal assemblies from a set of materials.&quot;&quot;&quot;

    PRIMERS = &quot;primers&quot;
    TEMPLATES = &quot;templates&quot;
    QUERIES = &quot;queries&quot;
    FRAGMENTS = &quot;fragments&quot;
    DEFAULT_N_JOBS = 1
    DEFAULT_N_ASSEMBLIES = 3
    ALGORITHM = Constants.ALGORITHM_DEFAULT

<div class="viewcode-block" id="Design.__init__"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design.__init__">[docs]</a>    def __init__(self, span_cost=None, seqdb=None, n_jobs=None):
        &quot;&quot;&quot;

        :param span_cost:
        :type span_cost: SpanCost
        :param seqdb:
        :type seqdb: dict
        :param n_jobs:
        :type n_jobs: int
        &quot;&quot;&quot;
        self.blast_factory = BioBlastFactory(config=BLAST_PENALTY_CONFIG)
        self.logger = logger(self)

        # graph by query_key
        if seqdb is None:
            seqdb = {}
        self._seqdb = seqdb  #: Sequence dict registry
        if span_cost is None:
            span_cost = cached_span_cost()
        self.span_cost = span_cost  #: span cost df
        self.graphs = {}  #: Dict[str, nx.DiGraph]
        self._results = {}  #: Dict[str, DesignResult]
        self.template_results = []
        self.fragment_results = []
        self.primer_results = []
        self.container_factory = AlignmentContainerFactory(self.seqdb)
        self.n_jobs = n_jobs or self.DEFAULT_N_JOBS  #: number of multiprocessing jobs
        self._times = {}
        self._method_trace = {}</div>

    def _get_design_status(self, qk):
        status = {&quot;compiled&quot;: False, &quot;run&quot;: False, &quot;success&quot;: False, &quot;assemblies&quot;: []}

        record = self.seqdb[qk]
        status[&quot;record&quot;] = {
            &quot;name&quot;: record.name,
            &quot;length&quot;: len(record.seq),
            &quot;id&quot;: record.id,
            &quot;is_circular&quot;: is_circular(record),
        }

        if self.graphs.get(qk, None) is not None:
            status[&quot;compiled&quot;] = True

        if self.results.get(qk, None) is not None:
            status[&quot;run&quot;] = True
            for a in self.results[qk].assemblies:
                status[&quot;success&quot;] = True
                summ_df = a.to_df()
                material = sum(list(summ_df[&quot;material&quot;]))
                eff = functools.reduce(operator.mul, summ_df[&quot;efficiency&quot;])

                comp = 0
                for c in summ_df[&quot;complexity&quot;]:
                    if not c:
                        continue
                    elif c &gt; comp:
                        comp = c

                status[&quot;assemblies&quot;].append(
                    {
                        &quot;cost&quot;: {
                            &quot;material cost&quot;: round(material, 2),
                            &quot;assembly efficiency&quot;: round(eff, 2),
                            &quot;max synthesis complexity&quot;: round(comp, 2),
                        }
                    }
                )
        return status

    @property
    def metadata(self):
        return {
            &quot;program&quot;: __title__,
            &quot;version&quot;: __version__,
            &quot;execution_trace&quot;: self._method_trace,
        }

    @property
    def status(self):
        statuses = {}
        for qk in self.container_factory.containers():
            statuses[qk] = self._get_design_status(qk)
        return statuses

    @property
    def seqdb(self) -&gt; Dict[str, SeqRecord]:
        return self._seqdb

    @property
    def results(self):
        return dict(self._results)

    @classmethod
    @functools.wraps(fake_designs)
    def fake(
        cls,
        n_designs: int,
        span_cost: SpanCost = None,
        circular: bool = True,
        n_linear_seqs: int = 50,
        n_cyclic_seqs: int = 50,
        n_primers: int = 50,
        n_primers_from_templates: int = 50,
        shared_length: int = 0,
        cyclic_size_int: Tuple[int, int] = (3000, 10000),
        linear_size_int: Tuple[int, int] = (100, 4000),
        primer_size_int: Tuple[int, int] = (15, 60),
        plasmid_size_interval: Tuple[int, int] = (5000, 10000),
        chunk_size_interval: Tuple[int, int] = (100, 3000),
        random_chunk_prob_int: Tuple[float, float] = (0, 0.5),
        random_chunk_size_int: Tuple[int, int] = (100, 1000),
        return_with_library: bool = False,
        **kwargs,
    ):
        library = fake_designs(
            n_designs=n_designs,
            circular=circular,
            n_linear_seqs=n_linear_seqs,
            n_cyclic_seqs=n_cyclic_seqs,
            n_primers=n_primers,
            n_primers_from_templates=n_primers_from_templates,
            cyclic_size_int=cyclic_size_int,
            linear_size_int=linear_size_int,
            primer_size_int=primer_size_int,
            plasmid_size_interval=plasmid_size_interval,
            chunk_size_interval=chunk_size_interval,
            random_chunk_prob_int=random_chunk_prob_int,
            random_chunk_size_int=random_chunk_size_int,
            design_sequence_similarity_length=shared_length,
        )
        designs = library[&quot;design&quot;]
        plasmids = library[&quot;cyclic&quot;]
        fragments = library[&quot;linear&quot;]
        primers = library[&quot;short&quot;]

        design = cls(span_cost=span_cost)
        design.add_materials(
            primers=primers, fragments=fragments, templates=plasmids, queries=designs
        )
        if return_with_library:
            return design, library
        return design

    def add_materials(
        self,
        primers: List[SeqRecord],
        templates: List[SeqRecord],
        queries: List[SeqRecord],
        fragments: List[SeqRecord] = None,
    ):
        if fragments is None:
            fragments = []
        self.add_primers(primers)
        fragments = self.filter_linear_records(fragments)
        self.add_templates(templates + fragments)
        self.add_queries(queries)
        self.add_fragments(fragments)

<div class="viewcode-block" id="Design.add_primers"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design.add_primers">[docs]</a>    def add_primers(self, primers: List[SeqRecord]):
        &quot;&quot;&quot;Add primer sequences to materials list.&quot;&quot;&quot;
        self.blast_factory.add_records(primers, self.PRIMERS)
        self.logger.info(&quot;Added {} primers&quot;.format(len(primers)))</div>

<div class="viewcode-block" id="Design.add_templates"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design.add_templates">[docs]</a>    def add_templates(self, templates: List[SeqRecord]):
        &quot;&quot;&quot;Add template sequences to materials list.&quot;&quot;&quot;
        self.blast_factory.add_records(templates, self.TEMPLATES)
        self.logger.info(&quot;Added {} templates&quot;.format(len(templates)))</div>

<div class="viewcode-block" id="Design.add_queries"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design.add_queries">[docs]</a>    def add_queries(self, queries: List[SeqRecord]):
        &quot;&quot;&quot;Add goal/query sequences to materials list.&quot;&quot;&quot;
        self.blast_factory.add_records(queries, self.QUERIES)
        self.logger.info(&quot;Added {} queries&quot;.format(len(queries)))</div>

<div class="viewcode-block" id="Design.add_fragments"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design.add_fragments">[docs]</a>    def add_fragments(self, fragments: List[SeqRecord]):
        &quot;&quot;&quot;Add fragment sequences to materials list.&quot;&quot;&quot;
        self.blast_factory.add_records(fragments, self.FRAGMENTS)
        self.logger.info(&quot;Added {} queries&quot;.format(len(fragments)))</div>
        # self.blast_factory.add_records(fragments, self.TEMPLATES)

<div class="viewcode-block" id="Design.filter_linear_records"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design.filter_linear_records">[docs]</a>    @classmethod
    def filter_linear_records(cls, records: List[SeqRecord]) -&gt; List[SeqRecord]:
        &quot;&quot;&quot;Return only linear records.&quot;&quot;&quot;
        return [r for r in records if not is_circular(r)]</div>

<div class="viewcode-block" id="Design.filter_perfect_subject"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design.filter_perfect_subject">[docs]</a>    @classmethod
    def filter_perfect_subject(cls, results: dict) -&gt; List[dict]:
        &quot;&quot;&quot;return only results whose subject is 100% aligned to query.&quot;&quot;&quot;
        return [r for r in results if perfect_subject(r[&quot;subject&quot;])]</div>

    # non-threaded blast
    def _blast(self):
        # align templates
        template_blast = self.blast_factory(self.TEMPLATES, self.QUERIES)
        template_blast.blastn()
        template_results = template_blast.get_perfect()
        self.template_results = template_results
        self.logger.info(&quot;Number of template matches: {}&quot;.format(len(template_results)))
        self.container_factory.seqdb.update(template_blast.seq_db.records)

        # align fragments
        if self.blast_factory.record_groups[self.FRAGMENTS]:
            fragment_blast = self.blast_factory(self.FRAGMENTS, self.QUERIES)
            fragment_blast.blastn()
            fragment_results = self.filter_perfect_subject(fragment_blast.get_perfect())
            self.container_factory.seqdb.update(fragment_blast.seq_db.records)
            self.logger.info(
                &quot;Number of perfect fragment matches: {}&quot;.format(len(fragment_results))
            )
        else:
            fragment_results = []
        self.fragment_results = fragment_results

        # align primers
        if self.blast_factory.record_groups[self.PRIMERS]:
            primer_blast = self.blast_factory(self.PRIMERS, self.QUERIES)
            primer_blast.blastn_short()
            primer_results = self.filter_perfect_subject(primer_blast.get_perfect())
            self.container_factory.seqdb.update(primer_blast.seq_db.records)
            self.logger.info(
                &quot;Number of perfect primers: {}&quot;.format(len(primer_results))
            )
        else:
            primer_results = []
        self.primer_results = primer_results

        # initialize container factory
        query_keys = [rec.id for rec in self.blast_factory.record_groups[self.QUERIES]]
        query_keys = [self.blast_factory.db.get_origin_key(k) for k in query_keys]
        self.container_factory.initialize_empty(query_keys)

        # load results
        self.container_factory.load_blast_json(fragment_results, Constants.FRAGMENT)
        self.container_factory.load_blast_json(template_results, Constants.PCR_PRODUCT)
        self.container_factory.load_blast_json(primer_results, Constants.PRIMER)

    @property
    def containers(self) -&gt; Dict[str, AlignmentContainer]:
        &quot;&quot;&quot;Iterable of alignment containers in this design.&quot;&quot;&quot;
        return self.container_factory.containers()

    @property
    def container_list(self) -&gt; List[AlignmentContainer]:
        &quot;&quot;&quot;List of alignment containers in this design.&quot;&quot;&quot;
        return list(self.container_factory.containers().values())

    @property
    def query_keys(self) -&gt; List[str]:
        &quot;&quot;&quot;List of query keys in this design.&quot;&quot;&quot;
        return list(self.container_factory.containers())

    def assemble_graphs(self, n_jobs):
        if n_jobs &gt; 1:
            with self.logger.timeit(
                &quot;DEBUG&quot;,
                &quot;assembling graphs (n_graphs={}, threads={})&quot;.format(
                    len(self.container_list), n_jobs
                ),
            ):
                self._assemble_graphs_with_threads(n_jobs)
        else:
            self._assemble_graphs_without_threads()

    def post_process_graphs(self):
        for qk, graph in self.graphs.items():
            query = self.seqdb[qk]
            processor = AssemblyGraphPostProcessor(graph, query, self.span_cost)
            processor()

<div class="viewcode-block" id="Design._assemble_graphs_without_threads"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design._assemble_graphs_without_threads">[docs]</a>    def _assemble_graphs_without_threads(self):
        &quot;&quot;&quot;Assemble all assembly graphs for all queries in this design.&quot;&quot;&quot;
        for query_key, container in self.logger.tqdm(
            self.container_factory.containers().items(),
            &quot;INFO&quot;,
            desc=&quot;assembling graphs (threads=1)&quot;,
        ):
            self.graphs[query_key], _ = assemble_graph(container, self.span_cost)</div>

    def _assemble_graphs_with_threads(self, n_jobs=None):
        query_keys, containers = zip(*self.container_factory.containers().items())

        graphs = multiprocessing_assemble_graph(
            self.container_factory, self.span_cost, n_jobs=n_jobs
        )

        # update graphs dict
        for qk, g, c in zip(query_keys, graphs, containers):
            self.graphs[qk] = g

    def _uncompile(self):
        self.container_factory.reset()
        self._results = {}

<div class="viewcode-block" id="Design.compile"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design.compile">[docs]</a>    @log_metadata(&quot;compile&quot;, additional_metadata={&quot;algorithm&quot;: ALGORITHM})
    def compile(self, n_jobs: int = DEFAULT_N_JOBS):
        &quot;&quot;&quot;Compile materials to assembly graph.&quot;&quot;&quot;
        self._uncompile()
        with self.logger.timeit(&quot;DEBUG&quot;, &quot;running blast&quot;):
            self._blast()
        self.assemble_graphs(n_jobs=n_jobs)
        self.post_process_graphs()</div>

<div class="viewcode-block" id="Design.run"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design.run">[docs]</a>    def run(self, n_paths: int = DEFAULT_N_ASSEMBLIES, n_jobs: int = DEFAULT_N_JOBS):
        &quot;&quot;&quot;Run the design. Runs `compile` and `optimize`, returning results
        that can be accessed by `design.results` or by `design.out()`

        :param n_paths: max number of assemblies per design to design
        :param n_jobs: number of concurrent threads to run
        :return: results
        &quot;&quot;&quot;
        self.compile(n_jobs)
        return self.optimize(n_paths=n_paths, n_jobs=n_jobs)</div>

    @property
    def is_compiled(self):
        &quot;&quot;&quot;Return whether the design has been compiled.

        :return: True if compiled. False if otherwise.
        &quot;&quot;&quot;
        if self.container_list:
            return True
        return False

    # def plot_matrix(self, matrix):
    # plot matrix
    # import pylab as plt
    # import seaborn as sns
    # import numpy as np
    #
    # plot_matrix = matrix.copy()
    # plot_matrix[plot_matrix == np.inf] = 10000
    # plot_matrix = np.nan_to_num(plot_matrix)
    #
    # fig = plt.figure(figsize=(24, 20))
    # ax = fig.gca()
    # step = 1
    # sns.heatmap(plot_matrix[::step, ::step], ax=ax)

    @staticmethod
    def _find_iter_alignment(a: int, b: int, alignments: Iterable[Alignment]):
        for align in alignments:
            if a == align.query_region.a and b == align.query_region.b:
                yield align

    @staticmethod
    def path_to_edge_costs(
        path: List[AssemblyNode], graph: nx.DiGraph
    ) -&gt; List[Tuple[AssemblyNode, AssemblyNode, dict]]:
        arr = []
        for n1, n2 in pairwise(path):
            edata = graph[n1][n2]
            arr.append((n1, n2, edata))
        return arr

    @log_metadata(&quot;optimize&quot;, additional_metadata={&quot;algorithm&quot;: ALGORITHM})
    def optimize(
        self, n_paths=DEFAULT_N_ASSEMBLIES, n_jobs=DEFAULT_N_JOBS
    ) -&gt; Dict[str, DesignResult]:

        if not self.container_list:
            raise DasiDesignException(
                &quot;Design must be compiled before running optimization.&#39;&quot;
            )
        if n_jobs &gt; 1:
            with self.logger.timeit(
                &quot;DEBUG&quot;,
                &quot;optimizing graphs (n_graphs={}, threads={})&quot;.format(
                    len(self.graphs), n_jobs
                ),
            ):
                self._results = self._optimize_with_threads(n_paths, n_jobs)
        else:
            self._results = self._optimize_without_threads(n_paths)

        self._freeze_graphs()
        return self._results

    def _freeze_graphs(self):
        for graph in self.graphs.values():
            nx.freeze(graph)

<div class="viewcode-block" id="Design._optimize_without_threads"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design._optimize_without_threads">[docs]</a>    def _optimize_without_threads(self, n_paths) -&gt; Dict[str, DesignResult]:
        &quot;&quot;&quot;Finds the optimal paths for each query in the design.&quot;&quot;&quot;
        results_dict = {}
        for query_key, graph, query_length, cyclic, result in self.logger.tqdm(
            self._collect_optimize_args(self.graphs),
            &quot;INFO&quot;,
            desc=&quot;optimizing graphs (n_graphs={}, threads=1)&quot;.format(len(self.graphs)),
        ):

            container = self.containers[query_key]
            query = container.seqdb[query_key]
            cyclic = is_circular(query)
            results_dict[query_key] = result

            paths, costs = optimize_graph(graph, len(query), cyclic, n_paths)
            if not paths:
                query_rec = self.blast_factory.db.records[query_key]
                self.logger.error(
                    &quot;\n\tThere were no solutions found for design &#39;{}&#39; ({}).\n\t&quot;
                    &quot;This sequence may be better synthesized. Use a tool such as JBEI&#39;s&quot;
                    &quot; BOOST.&quot;.format(query_rec.name, query_key)
                )
            result.add_assemblies(paths, ignore_invalid=True)
        return results_dict</div>

    def _optimize_with_threads(self, n_paths=5, n_jobs=10) -&gt; Dict[str, DesignResult]:
        results_dict = {}
        query_keys, graphs, query_lengths, cyclics, results = zip(
            *list(self._collect_optimize_args(self.graphs))
        )

        list_of_paths = multiprocessing_optimize_graph(
            graphs=graphs,
            query_lengths=query_lengths,
            cyclics=cyclics,
            n_paths=n_paths,
            n_jobs=n_jobs,
        )
        for qk, paths, result in zip(query_keys, list_of_paths, results):
            result.add_assemblies(paths, ignore_invalid=True)
            results_dict[qk] = result
        return results_dict

    def _collect_optimize_args(
        self, graphs: Dict[str, nx.DiGraph]
    ) -&gt; Tuple[str, nx.DiGraph, bool, dict]:
        for query_key, graph in self.logger.tqdm(
            graphs.items(), &quot;INFO&quot;, desc=&quot;optimizing graphs&quot;
        ):
            container = self.containers[query_key]
            query = container.seqdb[query_key]
            cyclic = is_circular(query)
            result = DesignResult(container=container, query_key=query_key, graph=graph)
            yield query_key, graph, len(query), cyclic, result

    # TODO: order keys
    # TODO: group identical reactions (identical output sequence)
    def to_df(self, assembly_index: int = 0) -&gt; Tuple[pd.DataFrame, pd.DataFrame]:
        reaction_dfs = []
        summary_dfs = []
        design_json = {}
        for i, (qk, result) in enumerate(self.results.items()):
            if result.assemblies and result.assemblies[0]:
                assembly = result.assemblies[assembly_index]
                react_df = assembly.to_reaction_df()
                react_df[&quot;DESIGN_ID&quot;] = i
                react_df[&quot;DESIGN_KEY&quot;] = qk
                react_df[&quot;ASSEMBLY_ID&quot;] = assembly_index
                reaction_dfs.append(react_df)

                summ_df = assembly.to_df()
                summ_df[&quot;DESIGN_ID&quot;] = i
                summ_df[&quot;DESIGN_KEY&quot;] = qk
                summ_df[&quot;ASSEMBLY_ID&quot;] = assembly_index
                summary_dfs.append(summ_df)

                rec = self.seqdb[qk]
                design_json[qk] = {&quot;NAME&quot;: rec.name, &quot;FILE&quot;: None}
                if hasattr(rec, &quot;from_file&quot;):
                    design_json[qk][&quot;FILE&quot;] = rec.from_file
            else:
                msg = &quot;Query {} {} yielded no assembly&quot;.format(self.seqdb[qk].name, i)
                self.logger.error(msg)

        colnames = [
            &quot;DESIGN_ID&quot;,
            &quot;DESIGN_KEY&quot;,
            &quot;ASSEMBLY_ID&quot;,
            &quot;REACTION_ID&quot;,
            &quot;REACTION_NAME&quot;,
            &quot;NAME&quot;,
            &quot;TYPE&quot;,
            &quot;KEY&quot;,
            &quot;ROLE&quot;,
            &quot;REGION&quot;,
            &quot;SEQUENCE&quot;,
            &quot;LENGTH&quot;,
            &quot;META&quot;,
        ]
        if reaction_dfs:
            react_df = pd.concat(reaction_dfs)
        else:
            react_df = pd.DataFrame(columns=colnames)
        react_df.columns = colnames
        react_df.sort_values(
            by=[&quot;TYPE&quot;, &quot;DESIGN_ID&quot;, &quot;ASSEMBLY_ID&quot;, &quot;REACTION_ID&quot;, &quot;NAME&quot;, &quot;ROLE&quot;],
            inplace=True,
        )

        if summary_dfs:
            summ_df = pd.concat(summary_dfs)
        else:
            summ_df = pd.DataFrame()

        return react_df, summ_df, design_json

    def report(self):
        return Report(self)

    @property
    def last_run_start(self):
        x = self._method_run_times.get(&quot;optimize&quot;, None)
        if not x:
            return None
        else:
            return x[0]

    @property
    def last_run_end(self):
        x = self._method_run_times.get(&quot;optimize&quot;, None)
        if not x:
            return None
        else:
            return x[1]

    @property
    def last_compile_start(self):
        x = self._method_run_times.get(&quot;compile&quot;, None)
        if not x:
            return None
        else:
            return x[0]

    @property
    def last_compile_end(self):
        x = self._method_run_times.get(&quot;compile&quot;, None)
        if not x:
            return None
        else:
            return x[1]

<div class="viewcode-block" id="Design.out"><a class="viewcode-back" href="../../../generated/dasi.design.Design.html#dasi.design.Design.out">[docs]</a>    def out(self, fmt: str = &quot;json&quot;):
        &quot;&quot;&quot;Return the results of the design as a validates output JSON.

        The output JSON is follows the following schema, see
        :param fmt:
        :return:
        &quot;&quot;&quot;
        if fmt.lower() == &quot;json&quot;:
            output = dasi_design_to_output_json(self)
            validate_output(output)
            return output
        else:
            raise ValueError(&quot;Format &#39;{}&#39; not recognized&quot;.format(fmt))</div></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>