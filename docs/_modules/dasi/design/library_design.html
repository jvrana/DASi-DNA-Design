<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.design.library_design &#8212; dasi 0.0.19a documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/style.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>



  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.19a</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../usage.html#getting-started">Getting started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#installation">Installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#running-examples">Running examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage.html#advanced">Advanced</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#using-inventory-information-with-dasi">Using inventory information with DASi</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#adjusting-design-parameters">Adjusting design parameters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../schemas/schemas.html">JSON Schemas</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#default-cost-parameters">Default Cost Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#cost-parameter-schema">Cost Parameter Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../schemas/schemas.html#cost-parameters-schema">Cost Parameters Schema</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#design-output-schema">Design Output Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../schemas/schemas.html#dasi-design-output">DASi design output</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../design.html">Design (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.design</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.Design.html">dasi.design.Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.LibraryDesign.html">dasi.design.LibraryDesign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.DesignResult.html">dasi.design.DesignResult</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Models (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.models</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Assembly.html">dasi.models.Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AssemblyNode.html">dasi.models.AssemblyNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Molecule.html">dasi.models.Molecule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.MoleculeType.html">dasi.models.MoleculeType</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Reaction.html">dasi.models.Reaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentGroup.html">dasi.models.AlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentGroupBase.html">dasi.models.AlignmentGroupBase</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.MultiPCRProductAlignmentGroup.html">dasi.models.MultiPCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.PCRProductAlignmentGroup.html">dasi.models.PCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentContainer.html">dasi.models.AlignmentContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentContainerFactory.html">dasi.models.AlignmentContainerFactory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../models.html#modules">modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.alignment.html">dasi.models.alignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.alignment_container.html">dasi.models.alignment_container</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cost.html">Cost Model (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.cost</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../cost.html#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.cost.utils.html">dasi.cost.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../command_line.html">Command Line (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.command_line</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">Utilities (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.utils</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../utils.html#utility-modules">Utility modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.npdf.html">dasi.utils.npdf</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.region.html">dasi.utils.region</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../utils.html#networkx-utilities">Networkx utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.exceptions.html">dasi.utils.networkx.exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.shortest_path.html">dasi.utils.networkx.shortest_path</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.utils.html">dasi.utils.networkx.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../exceptions.html">Exceptions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.exceptions</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../constants.html">Constants (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.constants</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guidelines.html">Code Guidelines</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for dasi.design.library_design</h1><div class="highlight"><pre>
<span></span>from copy import deepcopy
from typing import Dict
from typing import List
from typing import Tuple

import networkx as nx

from dasi.constants import Constants
from dasi.design import Design
from dasi.design import DesignResult
from dasi.design.graph_builder import AssemblyGraphPostProcessor
from dasi.models import Alignment
from dasi.models import AlignmentContainer
from dasi.models import AlignmentGroup
from dasi.utils import group_by
from dasi.utils import log_metadata
from dasi.utils import sort_with_keys


def overlapping_groups(group_list_a, group_list_b):
    &quot;&quot;&quot;Get all groups in group_list_b that right-hand overlap with
    group_list_a.&quot;&quot;&quot;
    group_sort, group_keys = sort_with_keys(
        group_list_b, key=lambda x: x.query_region.a
    )
    tuples = []
    for group_a in group_list_a:
        overlapping = AlignmentContainer.filter_alignments_by_span(
            group_sort,
            group_a.query_region,
            key=lambda p: p.query_region.a,
            end_inclusive=False,
        )

        if group_a in overlapping:
            overlapping.remove(group_a)
        tuples.append((group_a, overlapping))
    return tuples


def add_clusters(design):
    # list of all alignment groups
    all_groups = []
    for container in design.container_factory.containers().values():
        all_groups += container.get_groups_by_types(Constants.SHARED_FRAGMENT)

    # alignment_groups grouped by query_key
    grouped_by_qk = {}
    for g in all_groups:
        grouped_by_qk.setdefault(g.query_key, list())
        grouped_by_qk[g.query_key].append(g)

    # overlapping_by_qk
    overlapping = []
    for qk, groups in list(grouped_by_qk.items())[:]:
        overlapping += overlapping_groups(groups, groups)

    new_alignments = []
    for group_a, group_list in overlapping:
        new = container.expand_overlaps(
            group_list + [group_a], include_left=False, atype=Constants.SHARED_FRAGMENT
        )
        new_alignments += new
    new_alignments = list({a.eq_hash(): a for a in new_alignments}.values())
    design.container_factory.add_alignments(new_alignments)


def to_undirected(graph):
    &quot;&quot;&quot;.to_undirected is implemented in networkx out of the box, however, it
    suffers from occational infinite recursion errors during the deepcopy phase
    of the method (unknown as to why).&quot;&quot;&quot;
    undirected = nx.Graph()
    copied = deepcopy(graph)
    for n in copied.nodes:
        ndata = copied.nodes[n]
        undirected.add_node(n, **ndata)
    for n1, n2 in copied.edges:
        edata = copied.edges[n1, n2]
        undirected.add_edge(n1, n2, **edata)
    return undirected


def get_subgraphs(graph):
    &quot;&quot;&quot;Get independent subgraphs.&quot;&quot;&quot;
    node_list = list(graph.nodes)
    subgraphs = []
    while len(node_list) &gt; 0:
        node = node_list[-1]
        subgraph = nx.bfs_tree(to_undirected(graph), node)
        for n in subgraph.nodes:
            node_list.remove(n)
        subgraphs.append(graph.subgraph(subgraph.nodes))
    return subgraphs


def has_repeats(g):
    &quot;&quot;&quot;Check if the interaction graph has a repeated DNA sequence.&quot;&quot;&quot;
    grouped_by_key = {}
    for n in g.nodes:
        grouped_by_key.setdefault(n[0], list())
        grouped_by_key[n[0]].append((n[1], n[2]))
    for k, v in grouped_by_key.items():
        if len(v) &gt; 1:
            print(grouped_by_key)
            return True
    return False


def cluster_graph(design):
    interaction_graph = nx.Graph()
    all_groups = []
    for container in design.container_factory.containers().values():
        all_groups += container.get_groups_by_types(Constants.SHARED_FRAGMENT)
    for g in all_groups:
        for a in g.alignments:
            n1 = (a.query_key, a.query_region.a, a.query_region.b, a.query_region.c)
            n2 = (
                a.subject_key,
                a.subject_region.a,
                a.subject_region.b,
                a.subject_region.c,
            )
            edata = interaction_graph.get_edge_data(n1, n2)
            if edata:
                edata.setdefault(&quot;alignments&quot;, list())
                edata[&quot;alignments&quot;].append(a)
            else:
                interaction_graph.add_edge(n1, n2, alignments=[a])
    graphs = get_subgraphs(interaction_graph)
    graphs = [g for g in graphs if not has_repeats(g)]
    graphs.sort(reverse=True, key=lambda x: x.number_of_nodes())
    return graphs


<div class="viewcode-block" id="LibraryDesign"><a class="viewcode-back" href="../../../generated/dasi.design.LibraryDesign.html#dasi.design.LibraryDesign">[docs]</a>class LibraryDesign(Design):
    &quot;&quot;&quot;Design class for producing assemblies for libraries.&quot;&quot;&quot;

    DEFAULT_N_JOBS = 10
    FAVOR_SHARED_SEQUENCES = 2
    DEFAULT_N_ASSEMBLIES = Design.DEFAULT_N_ASSEMBLIES
    ALGORITHM = Constants.ALGORITHM_LIBRARY

<div class="viewcode-block" id="LibraryDesign.__init__"><a class="viewcode-back" href="../../../generated/dasi.design.LibraryDesign.html#dasi.design.LibraryDesign.__init__">[docs]</a>    def __init__(self, span_cost=None, seqdb=None, n_jobs=None):
        &quot;&quot;&quot;Something.&quot;&quot;&quot;
        super().__init__(span_cost=span_cost, seqdb=seqdb, n_jobs=n_jobs)
        self.shared_alignments = []
        self._edges = []</div>

    # @staticmethod
    # def _get_repeats_from_results(results):
    #     repeats = []
    #     for r in results:
    #         qk = r[&#39;query&#39;][&#39;origin_key&#39;]
    #         sk = r[&#39;subject&#39;][&#39;origin_key&#39;]
    #         if qk == sk:
    #             repeats.append((qk, r[&#39;query&#39;][&#39;start&#39;], r[&#39;query&#39;][&#39;end&#39;]))
    #     return repeats

    # TODO: why?
<div class="viewcode-block" id="LibraryDesign._get_iter_non_repeats"><a class="viewcode-back" href="../../../generated/dasi.design.LibraryDesign.html#dasi.design.LibraryDesign._get_iter_non_repeats">[docs]</a>    @staticmethod
    def _get_iter_non_repeats(alignments: List[Alignment]) -&gt; Tuple[str, int, int]:
        &quot;&quot;&quot;Return repeat regions of alignments. These are alignments that align
        to themselves.

        :param alignments:
        :return:
        &quot;&quot;&quot;
        for align in alignments:
            qk = align.query_key
            sk = align.subject_key
            if qk == sk:
                yield (qk, align.query_region.a, align.query_region.b)</div>

<div class="viewcode-block" id="LibraryDesign._expand_from_synthesized"><a class="viewcode-back" href="../../../generated/dasi.design.LibraryDesign.html#dasi.design.LibraryDesign._expand_from_synthesized">[docs]</a>    def _expand_from_synthesized(self):
        &quot;&quot;&quot;Expand PCR products that are next to SYNTHESIZED_FRAGMENTS.

        :return:
        &quot;&quot;&quot;
        for query_key, container in self.container_factory.containers().items():

            def is_not_shared(group_a: AlignmentGroup, group_b: AlignmentGroup):
                if group_a.type == Constants.SHARED_SYNTHESIZED_FRAGMENT:
                    return False
                if group_b.type == Constants.SHARED_SYNTHESIZED_FRAGMENT:
                    return True
                return False

            new_alignments = container.expand_overlaps(
                container.get_groups_by_types(
                    [
                        Constants.FRAGMENT,
                        Constants.PCR_PRODUCT,
                        Constants.SHARED_SYNTHESIZED_FRAGMENT,
                    ]
                ),
                Constants.PCR_PRODUCT,
                pass_condition=is_not_shared,
            )
            container.add_alignments(new_alignments, lim_size=True)

            self.logger.info(
                &quot;{}: Expanded {} using {} and found {} new alignments.&quot;.format(
                    query_key,
                    Constants.PCR_PRODUCT,
                    Constants.SHARED_SYNTHESIZED_FRAGMENT,
                    len(new_alignments),
                )
            )</div>

            # # grab the pcr products and expand primer pairs (again)
            # templates = container.get_groups_by_types(Constants.PCR_PRODUCT)
            # new_primer_pairs = container.expand_primer_pairs(templates)
            # self.logger.info(
            #     &quot;{}: Expanded {} {} using {}&quot;.format(
            #         query_key,
            #         len(new_primer_pairs),
            #         Constants.PCR_PRODUCT,
            #         Constants.SYNTHESIZED_FRAGMENT,
            #     )
            # )

<div class="viewcode-block" id="LibraryDesign._expand_synthesized_fragments"><a class="viewcode-back" href="../../../generated/dasi.design.LibraryDesign.html#dasi.design.LibraryDesign._expand_synthesized_fragments">[docs]</a>    def _expand_synthesized_fragments(self):
        &quot;&quot;&quot;
            1. copy groups from SHARED_FRAGMENTS to SYNTHESIZED_FRAGMENT
            2. expand overlaps for SYNTHESIZED_FRAGMENTS
        &quot;&quot;&quot;
        for query_key, container in self.container_factory.containers().items():
            # expand the share fragments using their own endpoints
            original_shared_fragments = container.get_groups_by_types(
                Constants.SHARED_FRAGMENT
            )
            copied_alignments = container.copy_groups(
                original_shared_fragments, Constants.SHARED_SYNTHESIZED_FRAGMENT
            )
            container.add_alignments(copied_alignments, lim_size=True)

            new_alignments = container.expand_overlaps(
                container.get_groups_by_types(Constants.SHARED_SYNTHESIZED_FRAGMENT),
                atype=Constants.SHARED_SYNTHESIZED_FRAGMENT,
            )

            self.logger.info(
                &quot;{}: Expanded {} new {} alignments.&quot;.format(
                    query_key,
                    len(new_alignments),
                    Constants.SHARED_SYNTHESIZED_FRAGMENT,
                )
            )
            container.add_alignments(new_alignments, lim_size=True)</div>

    def _check_shared_repeats(self):
        repeats = []
        for query_key, container in self.container_factory.containers().items():
            for align in container.get_alignments_by_types(Constants.SHARED_FRAGMENT):
                qk = align.query_key
                sk = align.subject_key
                if qk == sk:
                    repeats.append(align)
        assert not repeats

<div class="viewcode-block" id="LibraryDesign._share_query_blast"><a class="viewcode-back" href="../../../generated/dasi.design.LibraryDesign.html#dasi.design.LibraryDesign._share_query_blast">[docs]</a>    def _share_query_blast(self):
        &quot;&quot;&quot;Find and use shared fragments across queries.

        :return:
        &quot;&quot;&quot;

        # step 1: get query-on-query alignments
        self.logger.info(&quot;=== Expanding shared library fragments ===&quot;)
        blast = self.blast_factory(self.QUERIES, self.QUERIES)
        blast.blastn()

        results = blast.get_perfect()

        # step 2: eliminate self binding results
        results = [
            entry
            for entry in results
            if entry[&quot;query&quot;][&quot;origin_key&quot;] != entry[&quot;subject&quot;][&quot;origin_key&quot;]
        ]

        self.logger.info(
            &quot;Found {} shared alignments between the queries&quot;.format(len(results))
        )

        # step 3: load results to the container
        self.shared_alignments = results
        self.container_factory.seqdb.update(blast.seq_db.records)
        self.container_factory.load_blast_json(results, Constants.SHARED_FRAGMENT)</div>

    def _precompile_library_expansion(self):
        self._share_query_blast()
        self._expand_synthesized_fragments()
        self._expand_from_synthesized()
        self._check_shared_repeats()

<div class="viewcode-block" id="LibraryDesign.compile"><a class="viewcode-back" href="../../../generated/dasi.design.LibraryDesign.html#dasi.design.LibraryDesign.compile">[docs]</a>    @log_metadata(&quot;compile&quot;, additional_metadata={&quot;algorithm&quot;: ALGORITHM})
    def compile(
        self, n_jobs: int = DEFAULT_N_JOBS, post_processing_kwargs: Dict = None
    ):
        &quot;&quot;&quot;Compile the materials list into assembly graphs.&quot;&quot;&quot;
        if post_processing_kwargs is None:
            post_processing_kwargs = {}
        self._uncompile()
        tracker = self.logger.track(&quot;INFO&quot;, desc=&quot;Compiling library&quot;, total=5).enter()

        self.graphs = {}

        tracker.update(0, &quot;Running blast&quot;)
        self._blast()

        tracker.update(1, &quot;Running shared fragment blast&quot;)
        self._share_query_blast()

        # tracker.update(2, &quot;Expanding shared fragments&quot;)
        # self._expand_synthesized_fragments()
        # self._expand_from_synthesized()

        tracker.update(3, &quot;Finding shared clusters&quot;)
        self.update_library_metadata()

        tracker.update(4, &quot;Assembling graphs&quot;)
        self.assemble_graphs(n_jobs=n_jobs)

        # TODO: adjust n_clusters in the graph instead

        tracker.update(4, &quot;Post processing&quot;)
        adjusted = 0
        for qk, graph in self.graphs.items():
            query = self.seqdb[qk]
            processor = AssemblyGraphPostProcessor(
                graph, query, self.span_cost, self.seqdb, **post_processing_kwargs
            )
            processor()
            for n1, n2, edata in graph.edges(data=True):
                if edata[&quot;type_def&quot;].name == Constants.SHARED_SYNTHESIZED_FRAGMENT:
                    group = edata[&quot;group&quot;]

                    # TODO: better way to make notes on graph edge
                    if &quot;notes&quot; not in edata or edata[&quot;notes&quot;] is None:
                        edata[&quot;notes&quot;] = {}

                    # if &quot;n_clusters&quot; not in group.meta:
                    #     pass
                    edata[&quot;notes&quot;][&quot;n_clusters&quot;] = group.meta[&quot;n_clusters&quot;]
                    # TODO: adjust n_clusters
                    edata[&quot;material&quot;] = (
                        edata[&quot;material&quot;]
                        / (group.meta[&quot;n_clusters&quot;])
                        / self.FAVOR_SHARED_SEQUENCES
                    )
                    edata[&quot;cost&quot;] = edata[&quot;material&quot;] / edata[&quot;efficiency&quot;]
                    adjusted += 1
        tracker.update(4, &quot;Post processing complete&quot;)
        tracker.update(4, &quot;Compilation complete&quot;)</div>

    def update_library_metadata(self):
        add_clusters(self)
        graphs = cluster_graph(self)

        for c in self.container_list:
            c.share_group_tag = {}

        # update the meta data
        for g in graphs:
            n_clusters = g.number_of_nodes()
            for n1, n2, edata in g.edges(data=True):
                alignments = edata[&quot;alignments&quot;]
                for qk, container_alignments in group_by(
                    alignments, key=lambda x: x.query_key
                ).items():
                    container = self.containers[qk]
                    for a in container_alignments:
                        group_key = (
                            a.query_region.a,
                            a.query_region.b,
                            Constants.SHARED_SYNTHESIZED_FRAGMENT,
                        )
                        container.group_tags.add(
                            Constants.SHARE_GROUP_TAG,
                            group_key,
                            {
                                &quot;alignments&quot;: container_alignments,
                                &quot;cross_container_alignments&quot;: alignments,
                                &quot;n_clusters&quot;: n_clusters,
                            },
                        )

        # for container in design.container_list():
        #     groups = container.get_groups_by_types(Constants.SHARED_FRAGMENT)
        #     copied = container.copy_groups(groups, atype=Constants.SYNTHESIZED_FRAGMENT)
        #     container.add_alignments(copied)

        # def is_not_shared(group_a: AlignmentGroup, group_b: AlignmentGroup):
        #     if group_a.type == Constants.SHARED_FRAGMENT:
        #         return False
        #     if group_b.type == Constants.SYNTHESIZED_FRAGMENT:
        #         return True
        #     return False

        # new_alignments = container.expand_overlaps(
        #     container.get_groups_by_types(
        #         [
        #             Constants.FRAGMENT,
        #             Constants.PCR_PRODUCT,
        #             Constants.SYNTHESIZED_FRAGMENT,
        #         ]
        #     ),
        #     Constants.PCR_PRODUCT,
        #     pass_condition=is_not_shared,
        # )
        # container.add_alignments(new_alignments, lim_size=True)

    # def post_process_library_graphs(self):
    #     for qk, graph in self.graphs.items():
    #         query = self.seqdb[qk]
    #         processor = AssemblyGraphPostProcessor(graph, query)
    #         processor()

<div class="viewcode-block" id="LibraryDesign.optimize"><a class="viewcode-back" href="../../../generated/dasi.design.LibraryDesign.html#dasi.design.LibraryDesign.optimize">[docs]</a>    @log_metadata(
        &quot;optimize&quot;, additional_metadata={&quot;algorithm&quot;: Constants.ALGORITHM_LIBRARY}
    )
    def optimize(
        self, n_paths: int = DEFAULT_N_ASSEMBLIES, n_jobs: int = DEFAULT_N_JOBS
    ) -&gt; Dict[str, DesignResult]:
        &quot;&quot;&quot;Optimize the assembly graph for library assembly.&quot;&quot;&quot;
        return super().optimize(n_paths=n_paths, n_jobs=n_jobs)</div></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>