<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.models.alignment &#8212; dasi 0.1.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/style.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>



  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.1.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../usage.html#getting-started">Getting started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#installation">Installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#running-examples">Running examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage.html#advanced">Advanced</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#using-inventory-information-with-dasi">Using inventory information with DASi</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#adjusting-design-parameters">Adjusting design parameters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../schemas/schemas.html">JSON Schemas</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#default-cost-parameters">Default Cost Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#cost-parameter-schema">Cost Parameter Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../schemas/schemas.html#cost-parameters-schema">Cost Parameters Schema</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#design-output-schema">Design Output Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../schemas/schemas.html#dasi-design-output">DASi design output</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../design.html">Design (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.design</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.Design.html">dasi.design.Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.LibraryDesign.html">dasi.design.LibraryDesign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.DesignResult.html">dasi.design.DesignResult</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Models (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.models</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Assembly.html">dasi.models.Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AssemblyNode.html">dasi.models.AssemblyNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Molecule.html">dasi.models.Molecule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.MoleculeType.html">dasi.models.MoleculeType</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Reaction.html">dasi.models.Reaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Alignment.html">dasi.models.Alignment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentGroup.html">dasi.models.AlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentGroupBase.html">dasi.models.AlignmentGroupBase</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.MultiPCRProductAlignmentGroup.html">dasi.models.MultiPCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.PCRProductAlignmentGroup.html">dasi.models.PCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentContainer.html">dasi.models.AlignmentContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentContainerFactory.html">dasi.models.AlignmentContainerFactory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../models.html#modules">modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.assembly.html">dasi.models.assembly</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.molecule.html">dasi.models.molecule</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.alignment.html">dasi.models.alignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.alignment_container.html">dasi.models.alignment_container</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cost.html">Cost Model (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.cost</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../cost.html#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.cost.utils.html">dasi.cost.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../command_line.html">Command Line (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.command_line</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">Utilities (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.utils</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../utils.html#utility-modules">Utility modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.npdf.html">dasi.utils.npdf</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.region.html">dasi.utils.region</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../utils.html#networkx-utilities">Networkx utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.exceptions.html">dasi.utils.networkx.exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.shortest_path.html">dasi.utils.networkx.shortest_path</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.utils.html">dasi.utils.networkx.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../exceptions.html">Exceptions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.exceptions</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../constants.html">Constants (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.constants</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guidelines.html">Code Guidelines</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for dasi.models.alignment</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;Alignments.

These classes represent abstract alignments between existing and
potential molecules that could be produced.
&quot;&quot;&quot;
import functools
import operator
from collections.abc import Sized
from typing import Dict
from typing import Generator
from typing import List
from typing import Union

from .molecule import MoleculeType
from dasi.exceptions import AlignmentException
from dasi.utils import argsorted
from dasi.utils import Region


<div class="viewcode-block" id="RepresentsMolecule"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.RepresentsMolecule">[docs]</a>class RepresentsMolecule:
    &quot;&quot;&quot;Mixin for molecular sized alignments or alignment groups.&quot;&quot;&quot;

    def __init__(self, query_region: Region, atype: str):
        self.query_region = query_region
        self.type = atype
        if atype not in MoleculeType.types:
            raise ValueError(&quot;atype &#39;{}&#39; not in MoleculeTypes&quot;.format(atype))

<div class="viewcode-block" id="RepresentsMolecule.size_ok"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.RepresentsMolecule.size_ok">[docs]</a>    def size_ok(self):
        &quot;&quot;&quot;Determine if the size of this molecule is &#39;acceptable&#39; from the
        bounded molecule type.

        :return: whether this passes the size requirement of the molecule type.
        &quot;&quot;&quot;
        size = len(self.query_region)
        mol_type = MoleculeType.types[self.type]
        if mol_type.min_size is not None and size &lt; mol_type.min_size:
            return False
        if mol_type.max_size is not None and size &gt; mol_type.max_size:
            return False
        return True</div></div>


<div class="viewcode-block" id="Alignment"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.Alignment">[docs]</a>class Alignment(RepresentsMolecule, Sized):
    &quot;&quot;&quot;A pair of Regions that &#39;aligns&#39; two regions of DNA sequences. All
    regions must always be the same length.

    A subregion of both regions may be taken.
    &quot;&quot;&quot;

    __slots__ = [
        &quot;query_region&quot;,
        &quot;subject_region&quot;,
        &quot;type&quot;,
        &quot;query_key&quot;,
        &quot;subject_key&quot;,
        &quot;uid&quot;,
    ]

<div class="viewcode-block" id="Alignment.__init__"><a class="viewcode-back" href="../../../generated/dasi.models.Alignment.html#dasi.models.Alignment.__init__">[docs]</a>    def __init__(
        self,
        query_region: Region,
        subject_region: Region,
        atype: str,
        query_key: str,
        subject_key: str,
        meta: dict = None,
    ):
        &quot;&quot;&quot;Makes an alignment between two regions of sequences. Validates the
        regions are the same length.

        :param query_region: Query region this alignment aligns to
        :param subject_region: Subject region this alignment aligns to.
        :param atype: Type of alignment
        :param query_key: The record identifier for the query
        :param subject_key: The record identifier for the subject
        &quot;&quot;&quot;
        super().__init__(query_region, atype)
        assert query_region.direction == 1
        self.subject_region = subject_region
        self.validate()
        self.query_key = query_key
        self.subject_key = subject_key
        if meta is None:
            meta = {}
        self.meta = meta</div>

    def validate(self):
        if not len(self.query_region) == len(self.subject_region):
            raise AlignmentException(
                &quot;Regions must have the same size: {} vs {}. {} vs {}&quot;.format(
                    len(self.query_region),
                    len(self.subject_region),
                    self.query_region,
                    self.subject_region,
                )
            )

    def is_perfect_subject(self):
        return len(self.subject_region) == self.subject_region.context_length

<div class="viewcode-block" id="Alignment.sub_region"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.Alignment.sub_region">[docs]</a>    def sub_region(self, qstart: int, qend: int, atype=None) -&gt; &quot;Alignment&quot;:
        &quot;&quot;&quot;Returns a copy of the alignment between the inclusive start and end
        relative to the query region.

        :param qstart: start of the query sub region
        :param qend: end of the query sub region
        :param atype: optional type of alignment to return
        :return:
        &quot;&quot;&quot;
        query_copy = self.query_region.sub(qstart, qend)

        i = self.query_region.i(qstart)
        if i &lt; 0:
            i = self.query_region.i(qstart + self.query_region.context_length)
        if i == len(self.subject_region):
            i = 0

        if self.subject_region.direction == -1:
            b = len(self.subject_region) - i
            a = b - len(query_copy)
            if a == b == len(self.subject_region):
                a = b = 0
            subject_copy = self.subject_region[a:b]
        else:
            subject_copy = self.subject_region[i : i + len(query_copy)]

        if atype is None:
            atype = self.type
        self.validate()
        return self.__class__(
            query_region=query_copy,
            subject_region=subject_copy,
            atype=atype,
            query_key=self.query_key,
            subject_key=self.subject_key,
        )</div>

<div class="viewcode-block" id="Alignment.copy"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.Alignment.copy">[docs]</a>    def copy(self, atype=None) -&gt; &quot;Alignment&quot;:
        &quot;&quot;&quot;Do shallow copy of this alignment. Query and subject regions between
        this and the copied alignment will be identical.

        :param atype: new alignment type
        :return:
        &quot;&quot;&quot;
        if atype is None:
            atype = self.type
        return self.__class__(
            self.query_region,
            self.subject_region,
            atype,
            self.query_key,
            self.subject_key,
        )</div>

    def __len__(self) -&gt; int:
        return len(self.query_region)

    def __str__(self) -&gt; str:
        return &quot;&lt;{} {} {} {}&gt;&quot;.format(
            self.__class__.__name__, self.type, self.query_region, self.subject_region
        )

    @staticmethod
    def _rhash(region: Region):
        return (region.a, region.b, region.c, region.context_length, region.cyclic)

    def eq_hash(self):
        return (
            (self.query_key, self.subject_key, self.type)
            + self._rhash(self.query_region)
            + self._rhash(self.subject_region)
        )

    def __eq__(self, other: &quot;Alignment&quot;):
        return self.eq_hash() == other.eq_hash()

    def __repr__(self) -&gt; str:
        return str(self)</div>


<div class="viewcode-block" id="AlignmentGroupBase"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.AlignmentGroupBase">[docs]</a>class AlignmentGroupBase(RepresentsMolecule):
    &quot;&quot;&quot;A representative Alignment representing a group of alignments.&quot;&quot;&quot;

    __slots__ = [&quot;query_region&quot;, &quot;_alignments&quot;, &quot;name&quot;, &quot;type&quot;, &quot;meta&quot;]

<div class="viewcode-block" id="AlignmentGroupBase.__init__"><a class="viewcode-back" href="../../../generated/dasi.models.AlignmentGroupBase.html#dasi.models.AlignmentGroupBase.__init__">[docs]</a>    def __init__(
        self,
        alignments: List[Alignment],
        group_type: str,
        name: str = None,
        query_region: Region = None,
        meta: dict = None,
    ):
        &quot;&quot;&quot;

        :param alignments:
        :param group_type:
        :param name:
        :param query_region:
        :param meta:
        &quot;&quot;&quot;
        super().__init__(query_region, group_type)
        self._alignments = tuple(alignments)
        self.name = name
        if meta is None:
            meta = {}
        self.meta = meta</div>

    @property
    def query_key(self) -&gt; str:
        &quot;&quot;&quot;Return the query key associated with the query region.&quot;&quot;&quot;
        return self.alignments[0].query_key

    @property
    def subject_regions(self) -&gt; List[Region]:
        &quot;&quot;&quot;Return the list of subject regions in this alignment group.&quot;&quot;&quot;
        return [a.subject_region for a in self.alignments]

    @property
    def subject_keys(self) -&gt; List[str]:
        &quot;&quot;&quot;Return the list of subject keys in this alignment group.&quot;&quot;&quot;
        return [a.subject_key for a in self.alignments]

    @property
    def alignments(self):
        return self._alignments

<div class="viewcode-block" id="AlignmentGroupBase.sub_region"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.AlignmentGroupBase.sub_region">[docs]</a>    def sub_region(self, qstart: int, qend: int, atype: str) -&gt; &quot;AlignmentGroupBase&quot;:
        &quot;&quot;&quot;Produce a new alignment group with sub-regions of the query region
        and subject regions at the specified new indicies.&quot;&quot;&quot;
        alignments_copy = []
        for a in self.alignments:
            alignments_copy.append(a.sub_region(qstart, qend))
        for a in alignments_copy:
            a.type = atype
        return self.__class__(
            alignments=alignments_copy, group_type=atype, name=&quot;subregion&quot;
        )</div>

    def __repr__(self) -&gt; str:
        return &quot;&lt;{} {}&gt;&quot;.format(self.__class__.__name__, self.query_region)</div>


<div class="viewcode-block" id="AlignmentGroup"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.AlignmentGroup">[docs]</a>class AlignmentGroup(AlignmentGroupBase):
    &quot;&quot;&quot;A representative Alignment representing a group of alignments sharing
    the same starting and ending position for a query sequence.&quot;&quot;&quot;

    __slots__ = list(AlignmentGroupBase.__slots__)

<div class="viewcode-block" id="AlignmentGroup.__init__"><a class="viewcode-back" href="../../../generated/dasi.models.AlignmentGroup.html#dasi.models.AlignmentGroup.__init__">[docs]</a>    def __init__(
        self,
        alignments: List[Alignment],
        group_type: str,
        name: str = None,
        meta: dict = None,
    ):
        super().__init__(
            alignments=alignments,
            group_type=group_type,
            name=name,
            query_region=alignments[0].query_region,
            meta=meta,
        )</div>

<div class="viewcode-block" id="AlignmentGroup.reindex_alignments"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.AlignmentGroup.reindex_alignments">[docs]</a>    def reindex_alignments(self, indices: List[int]):
        &quot;&quot;&quot;Reindex the alignments list by index.

        :param indices: list of indices
        :return: None
        &quot;&quot;&quot;
        if len(indices) != len(self.alignments):
            raise ValueError(
                &quot;Cannot reindex. Length of indices ({}) does not match length of&quot;
                &quot; alignments ({})&quot;.format(len(indices), len(self._groupings))
            )
        self._alignments = tuple(self._alignments[i] for i in indices)</div>

<div class="viewcode-block" id="AlignmentGroup.prioritize_alignments"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.AlignmentGroup.prioritize_alignments">[docs]</a>    def prioritize_alignments(self, indices: List[int]):
        &quot;&quot;&quot;Prioritize alignments by pushing groupings at the given indices into
        the front of the alignments list.

        :param indices: list of indices to prioritize
        :return: None
        &quot;&quot;&quot;
        other_indices = []
        for i in range(len(self.alignments)):
            if i not in indices:
                other_indices.append(i)
        new_indices = indices + other_indices
        self.reindex_alignments(new_indices)</div></div>


# class RepresentsPCR(AlignmentGroupBase):
#
#     @abstractmethod
#     def get_templates(self):
#         pass


<div class="viewcode-block" id="PCRProductAlignmentGroup"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.PCRProductAlignmentGroup">[docs]</a>class PCRProductAlignmentGroup(AlignmentGroupBase):
    &quot;&quot;&quot;Represents a PCR product alignment from a template alignment and
    forward and reverse alignments. Represents several situations:

    ::

            Situations the PCRProductAlignmentGroup represents:

            Rev primer with overhang
                        &lt;--------
            ------------------
            ----&gt;

            Primers with overhangs
                           &lt;--------
               ------------------
            --------&gt;

            Primers &#39;within&#39; the template
                    &lt;-----
               ------------------
            --------&gt;

            And so on...

    &quot;&quot;&quot;

    __slots__ = list(set(AlignmentGroupBase.__slots__ + [&quot;template&quot;, &quot;fwd&quot;, &quot;rev&quot;]))

<div class="viewcode-block" id="PCRProductAlignmentGroup.__init__"><a class="viewcode-back" href="../../../generated/dasi.models.PCRProductAlignmentGroup.html#dasi.models.PCRProductAlignmentGroup.__init__">[docs]</a>    def __init__(
        self,
        fwd: Union[None, Alignment],
        template: Alignment,
        rev: Union[None, Alignment],
        query_region: Region,
        group_type: str,
        meta: dict = None,
    ):
        &quot;&quot;&quot;Initialize a new PCRProductAlignmentGroup. Represents a PCR product.
        Query region end points are determined from the first non-None
        alignment and the last non-None alignment. Produces *one new
        alignment*, the template alignment, which is the intersection of the
        provided template alignment and the query_region, which represents the
        exact region for which PCR primers ought to align in a PCR reaction.

        :param fwd: the forward primer alignment. Can be &#39;inside&#39; the template or have
            an overhang.
        :param template: template alignment
        :param rev: the reverse primer alignment. Can be &#39;within&#39; the template or have
            an overhang.
        :param group_type: group type name
        :param meta: extra meta data
        &quot;&quot;&quot;
        if fwd is None and rev is None:
            raise AlignmentException(&quot;Must provide either a fwd and/or rev alignments&quot;)
        alignments = [x for x in [fwd, template, rev] if x is not None]

        a = alignments[0].query_region.a
        b = alignments[-1].query_region.b

        query_region = query_region.new(a, b)

        self.template = template
        self.fwd = fwd
        self.rev = rev

        super().__init__(
            alignments=alignments,
            group_type=group_type,
            query_region=query_region,
            meta=meta,
        )</div>

    @property
    def subject_keys(self):
        raise AlignmentException(
            &quot;Use subject keys directly, as in `self.fwd.subject_key`&quot;
        )</div>


# TODO: MultiPCRProductAlignmentGroup is a seriously convoluted class
#       Being such an important class, this should be very easy to understand.
#       `alignments` property should never be accessed directly, as
#          the concept of &#39;template&#39; is different here (see `get_template`)
#
<div class="viewcode-block" id="MultiPCRProductAlignmentGroup"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.MultiPCRProductAlignmentGroup">[docs]</a>class MultiPCRProductAlignmentGroup(AlignmentGroupBase):
    &quot;&quot;&quot;A PCR Product Alignment with redundant forward primer, reverse primer,
    and template alignments.

    Essentially, this represents region of a designed sequence *that could*
    be generated from a number of PCR reactions. Each PCR reaction is
    tracked in the `groupings`, which is a list of dictionaries with
    keys &#39;fwd&#39;, &#39;rev&#39;, &#39;template&#39; and valued by Alignments.

    Now, there are alot of ways to produce PCR products.
    &quot;&quot;&quot;

    __slots__ = list(set(AlignmentGroupBase.__slots__ + [&quot;_groupings&quot;]))

    EXPECTED_KEYS = &quot;fwd&quot;, &quot;rev&quot;, &quot;template&quot;
    TEMPLATE_ACCESSOR = &quot;adjusted_template&quot;

<div class="viewcode-block" id="MultiPCRProductAlignmentGroup.__init__"><a class="viewcode-back" href="../../../generated/dasi.models.MultiPCRProductAlignmentGroup.html#dasi.models.MultiPCRProductAlignmentGroup.__init__">[docs]</a>    def __init__(
        self,
        groupings: List[Dict[str, Alignment]],
        query_region: Region,
        group_type: str,
    ):
        &quot;&quot;&quot;Initializes a new MultiPCRProductAlignmentGroup. This object
        represents a region of DNA that can be produced from a number of
        different forward, reverse, and template DNAs, all producing the same
        sequence.

        :param groupings: dictionary of groupings with the &quot;fwd&quot;, &quot;rev&quot; and &quot;template&quot;
            keys.
        :param query_region: query region
        :param group_type: group type
        &quot;&quot;&quot;

        for g in groupings:
            for key in self.EXPECTED_KEYS:
                if key not in g:
                    raise ValueError(&quot;Grouping is missing key &#39;{}&#39;&quot;.format(key))
        self._groupings = groupings
        self._templates = [None] * len(self._groupings)
        alignments = self._get_alignments()
        super().__init__(
            alignments=alignments, query_region=query_region, group_type=group_type
        )</div>

    # @property
    # def groupings(self):
    #     return self._groupings

    def _get_alignments(self):
        accumulated = {}
        for key in self.EXPECTED_KEYS:
            accumulated.setdefault(key, list())
            for g in self._groupings:
                if g[key]:
                    accumulated[key].append(g[key])

        alignments = []
        for key in self.EXPECTED_KEYS:
            alignments += accumulated[key]

        return alignments

<div class="viewcode-block" id="MultiPCRProductAlignmentGroup.reindex_groupings"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.MultiPCRProductAlignmentGroup.reindex_groupings">[docs]</a>    def reindex_groupings(self, indices: List[int]):
        &quot;&quot;&quot;Reindex the groupings list by index.

        :param indices: list of indices
        :return: None
        &quot;&quot;&quot;
        if len(indices) != len(self._groupings):
            raise ValueError(
                &quot;Cannot reindex. Length of indices ({}) does not match length of &quot;
                &quot;groups ({})&quot;.format(len(indices), len(self._groupings))
            )
        self._groupings = tuple(self._groupings[i] for i in indices)
        self._alignments = tuple(self._get_alignments())</div>

<div class="viewcode-block" id="MultiPCRProductAlignmentGroup.prioritize_groupings"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.MultiPCRProductAlignmentGroup.prioritize_groupings">[docs]</a>    def prioritize_groupings(self, indices: List[int]):
        &quot;&quot;&quot;Prioritize groupings by pushing groupings at the given indices into
        the front of the grouping list.

        :param indices: list of indices to prioritize
        :return: None
        &quot;&quot;&quot;
        other_indices = []
        for i in range(len(self._groupings)):
            if i not in indices:
                other_indices.append(i)
        new_indices = indices + other_indices
        self.reindex_groupings(new_indices)</div>

    # TODO: WHAT IS THIS METHOD???
<div class="viewcode-block" id="MultiPCRProductAlignmentGroup.get_template"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.MultiPCRProductAlignmentGroup.get_template">[docs]</a>    def get_template(self, index: int = 0):
        &quot;&quot;&quot;Here we take the intersection of the template.query_region and query
        region. WHY???

        Notes this is **not** the &#39;template&#39; key of the groupings.

        .. note::
            The result of this alignment is used in the primer design.

        :param index:
        :return:
        &quot;&quot;&quot;
        group = self._groupings[index]

        if self.TEMPLATE_ACCESSOR not in group:
            template = self._groupings[index][&quot;template&quot;]
            intersection = template.query_region.intersection(self.query_region)
            group[self.TEMPLATE_ACCESSOR] = template.sub_region(
                intersection.a, intersection.b
            )
        return group[self.TEMPLATE_ACCESSOR]</div>

<div class="viewcode-block" id="MultiPCRProductAlignmentGroup.iter_templates"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.MultiPCRProductAlignmentGroup.iter_templates">[docs]</a>    def iter_templates(self) -&gt; Generator[Alignment, None, None]:
        &quot;&quot;&quot;Generator of templates from `get_template`&quot;&quot;&quot;
        for i in range(len(self._groupings)):
            yield self.get_template(i)</div>

<div class="viewcode-block" id="MultiPCRProductAlignmentGroup.get_fwd"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.MultiPCRProductAlignmentGroup.get_fwd">[docs]</a>    def get_fwd(self, index: int = 0) -&gt; Alignment:
        &quot;&quot;&quot;Get the forward alignment at the specified index.

        :param index: index of the grouping to access
        :return: alignment
        &quot;&quot;&quot;
        group = self._groupings[index]
        return group[&quot;fwd&quot;]</div>

<div class="viewcode-block" id="MultiPCRProductAlignmentGroup.get_rev"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.MultiPCRProductAlignmentGroup.get_rev">[docs]</a>    def get_rev(self, index: int = 0):
        &quot;&quot;&quot;Get the reverse alignment at the specified index.

        :param index: index of the grouping to access
        :return: alignment
        &quot;&quot;&quot;
        group = self._groupings[index]
        return group[&quot;rev&quot;]</div></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>