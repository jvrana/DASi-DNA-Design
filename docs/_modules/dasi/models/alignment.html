<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.models.alignment &#8212; dasi 0.0.14 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/style.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>



  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.14</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../design.html">Design (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.design</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.Design.html">dasi.design.Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.LibraryDesign.html">dasi.design.LibraryDesign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.DesignResult.html">dasi.design.DesignResult</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Models (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.models</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Assembly.html">dasi.models.Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AssemblyNode.html">dasi.models.AssemblyNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Molecule.html">dasi.models.Molecule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.MoleculeType.html">dasi.models.MoleculeType</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Reaction.html">dasi.models.Reaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentGroup.html">dasi.models.AlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentGroupBase.html">dasi.models.AlignmentGroupBase</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.MultiPCRProductAlignmentGroup.html">dasi.models.MultiPCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.PCRProductAlignmentGroup.html">dasi.models.PCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentContainer.html">dasi.models.AlignmentContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentContainerFactory.html">dasi.models.AlignmentContainerFactory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../models.html#modules">modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.alignment.html">dasi.models.alignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.alignment_container.html">dasi.models.alignment_container</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cost.html">Cost Model (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.cost</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../cost.html#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.cost.utils.html">dasi.cost.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../command_line.html">Command Line (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.command_line</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">Utilities (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.utils</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../utils.html#utility-modules">Utility modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.npdf.html">dasi.utils.npdf</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.region.html">dasi.utils.region</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.sequence_design.html">dasi.utils.sequence_design</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../utils.html#networkx-utilities">Networkx utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.exceptions.html">dasi.utils.networkx.exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.shortest_path.html">dasi.utils.networkx.shortest_path</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.utils.html">dasi.utils.networkx.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../exceptions.html">Exceptions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.exceptions</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../constants.html">Constants (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.constants</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../usage.html#installation">Installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../schemas/schemas.html">JSON Schemas</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#default-cost-parameters">Default Cost Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#cost-parameter-schema">Cost Parameter Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../schemas/schemas.html#cost-parameters-schema">Cost Parameters Schema</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#design-output-schema">Design Output Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../schemas/schemas.html#dasi-design-output">DASi design output</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guidelines.html">Code Guidelines</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for dasi.models.alignment</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;Alignments.&quot;&quot;&quot;
from collections.abc import Sized
from typing import Dict
from typing import List
from typing import Union

from .molecule import MoleculeType
from dasi.exceptions import AlignmentException
from dasi.utils import Region


<div class="viewcode-block" id="RepresentsMolecule"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.RepresentsMolecule">[docs]</a>class RepresentsMolecule:
    &quot;&quot;&quot;Mixin for molecular sized alignments or alignment groups.&quot;&quot;&quot;

    def __init__(self, query_region: Region, atype: str):
        self.query_region = query_region
        self.type = atype
        if atype not in MoleculeType.types:
            raise ValueError(&quot;atype &#39;{}&#39; not in MoleculeTypes&quot;.format(atype))

    def size_ok(self):
        size = len(self.query_region)
        mol_type = MoleculeType.types[self.type]
        if mol_type.min_size is not None and size &lt; mol_type.min_size:
            return False
        if mol_type.max_size is not None and size &gt; mol_type.max_size:
            return False
        return True</div>


<div class="viewcode-block" id="Alignment"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.Alignment">[docs]</a>class Alignment(RepresentsMolecule, Sized):
    &quot;&quot;&quot;A pair of Regions that &#39;aligns&#39; two regions of DNA sequences. All
    regions must always be the same length.

    A subregion of both regions may be taken.
    &quot;&quot;&quot;

    __slots__ = [
        &quot;query_region&quot;,
        &quot;subject_region&quot;,
        &quot;type&quot;,
        &quot;query_key&quot;,
        &quot;subject_key&quot;,
        &quot;uid&quot;,
    ]

    def __init__(
        self,
        query_region: Region,
        subject_region: Region,
        atype: str,
        query_key: str,
        subject_key: str,
        meta: dict = None,
    ):
        &quot;&quot;&quot;Makes an alignment between two regions of sequences. Validates the
        regions are the same length.

        :param query_region: Query region this alignment aligns to
        :param subject_region: Subject region this alignment aligns to.
        :param atype: Type of alignment
        :param query_key: The record identifier for the query
        :param subject_key: The record identifier for the subject
        &quot;&quot;&quot;
        super().__init__(query_region, atype)
        assert query_region.direction == 1
        self.subject_region = subject_region
        self.validate()
        self.query_key = query_key
        self.subject_key = subject_key
        if meta is None:
            meta = {}
        self.meta = meta

    def validate(self):
        if not len(self.query_region) == len(self.subject_region):
            raise AlignmentException(
                &quot;Regions must have the same size: {} vs {}. {} vs {}&quot;.format(
                    len(self.query_region),
                    len(self.subject_region),
                    self.query_region,
                    self.subject_region,
                )
            )

    def is_perfect_subject(self):
        return len(self.subject_region) == self.subject_region.context_length

<div class="viewcode-block" id="Alignment.sub_region"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.Alignment.sub_region">[docs]</a>    def sub_region(self, qstart: int, qend: int, atype=None) -&gt; &quot;Alignment&quot;:
        &quot;&quot;&quot;Returns a copy of the alignment between the inclusive start and end
        relative to the query region.

        :param qstart: start of the query sub region
        :param qend: end of the query sub region
        :param atype: optional type of alignment to return
        :return:
        &quot;&quot;&quot;
        query_copy = self.query_region.sub(qstart, qend)

        i = self.query_region.i(qstart)
        if i &lt; 0:
            i = self.query_region.i(qstart + self.query_region.context_length)
        if i == len(self.subject_region):
            i = 0

        if self.subject_region.direction == -1:
            b = len(self.subject_region) - i
            a = b - len(query_copy)
            if a == b == len(self.subject_region):
                a = b = 0
            subject_copy = self.subject_region[a:b]
        else:
            subject_copy = self.subject_region[i : i + len(query_copy)]

        if atype is None:
            atype = self.type
        self.validate()
        return self.__class__(
            query_region=query_copy,
            subject_region=subject_copy,
            atype=atype,
            query_key=self.query_key,
            subject_key=self.subject_key,
        )</div>

<div class="viewcode-block" id="Alignment.copy"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.Alignment.copy">[docs]</a>    def copy(self, atype=None) -&gt; &quot;Alignment&quot;:
        &quot;&quot;&quot;Do shallow copy of this alignment. Query and subject regions between
        this and the copied alignment will be identical.

        :param atype: new alignment type
        :return:
        &quot;&quot;&quot;
        if atype is None:
            atype = self.type
        return self.__class__(
            self.query_region,
            self.subject_region,
            atype,
            self.query_key,
            self.subject_key,
        )</div>

    def __len__(self) -&gt; int:
        return len(self.query_region)

    def __str__(self) -&gt; str:
        return &quot;&lt;{} {} {} {}&gt;&quot;.format(
            self.__class__.__name__, self.type, self.query_region, self.subject_region
        )

    @staticmethod
    def _rhash(region: Region):
        return (region.a, region.b, region.c, region.context_length, region.cyclic)

    def eq_hash(self):
        return (
            (self.query_key, self.subject_key, self.type)
            + self._rhash(self.query_region)
            + self._rhash(self.subject_region)
        )

    def __eq__(self, other: &quot;Alignment&quot;):
        return self.eq_hash() == other.eq_hash()

    def __repr__(self) -&gt; str:
        return str(self)</div>


<div class="viewcode-block" id="AlignmentGroupBase"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.AlignmentGroupBase">[docs]</a>class AlignmentGroupBase(RepresentsMolecule):
    &quot;&quot;&quot;A representative Alignment representing a group of alignments.&quot;&quot;&quot;

    __slots__ = [&quot;query_region&quot;, &quot;alignments&quot;, &quot;name&quot;, &quot;type&quot;, &quot;meta&quot;]

<div class="viewcode-block" id="AlignmentGroupBase.__init__"><a class="viewcode-back" href="../../../generated/dasi.models.AlignmentGroupBase.html#dasi.models.AlignmentGroupBase.__init__">[docs]</a>    def __init__(
        self,
        alignments: List[Alignment],
        group_type: str,
        name: str = None,
        query_region: Region = None,
        meta: dict = None,
    ):
        &quot;&quot;&quot;

        :param alignments:
        :param group_type:
        :param name:
        :param query_region:
        :param meta:
        &quot;&quot;&quot;
        super().__init__(query_region, group_type)
        self.alignments = alignments
        self.name = name
        if meta is None:
            meta = {}
        self.meta = meta</div>

    @property
    def query_key(self) -&gt; str:
        &quot;&quot;&quot;Return the query key associated with the query region.&quot;&quot;&quot;
        return self.alignments[0].query_key

    @property
    def subject_regions(self) -&gt; List[Region]:
        &quot;&quot;&quot;Return the list of subject regions in this alignment group.&quot;&quot;&quot;
        return [a.subject_region for a in self.alignments]

    @property
    def subject_keys(self) -&gt; List[str]:
        &quot;&quot;&quot;Return the list of subject keys in this alignment group.&quot;&quot;&quot;
        return [a.subject_key for a in self.alignments]

<div class="viewcode-block" id="AlignmentGroupBase.sub_region"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.AlignmentGroupBase.sub_region">[docs]</a>    def sub_region(self, qstart: int, qend: int, atype: str) -&gt; &quot;AlignmentGroupBase&quot;:
        &quot;&quot;&quot;Produce a new alignment group with sub-regions of the query region
        and subject regions at the specified new indicies.&quot;&quot;&quot;
        alignments_copy = []
        for a in self.alignments:
            alignments_copy.append(a.sub_region(qstart, qend))
        for a in alignments_copy:
            a.type = atype
        return self.__class__(
            alignments=alignments_copy, group_type=atype, name=&quot;subregion&quot;
        )</div>

    def __repr__(self) -&gt; str:
        return &quot;&lt;AlignmentGroup {}&gt;&quot;.format(self.query_region)</div>


<div class="viewcode-block" id="AlignmentGroup"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.AlignmentGroup">[docs]</a>class AlignmentGroup(AlignmentGroupBase):
    &quot;&quot;&quot;A representative Alignment representing a group of alignments sharing
    the same starting and ending position for a query sequence.&quot;&quot;&quot;

    __slots__ = [&quot;query_region&quot;, &quot;alignments&quot;, &quot;name&quot;, &quot;type&quot;]

<div class="viewcode-block" id="AlignmentGroup.__init__"><a class="viewcode-back" href="../../../generated/dasi.models.AlignmentGroup.html#dasi.models.AlignmentGroup.__init__">[docs]</a>    def __init__(
        self,
        alignments: List[Alignment],
        group_type: str,
        name: str = None,
        meta: dict = None,
    ):
        super().__init__(
            alignments=alignments,
            group_type=group_type,
            name=name,
            query_region=alignments[0].query_region,
            meta=meta,
        )</div></div>


<div class="viewcode-block" id="PCRProductAlignmentGroup"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.PCRProductAlignmentGroup">[docs]</a>class PCRProductAlignmentGroup(AlignmentGroupBase):
    &quot;&quot;&quot;Represents a PCR product alignment from a template alignment and
    forward and reverse alignments. Represents several situations:

    ::

            Situations the PCRProductAlignmentGroup represents:

            Rev primer with overhang
                        &lt;--------
            ------------------
            ----&gt;

            Primers with overhangs
                           &lt;--------
               ------------------
            --------&gt;

            Primers &#39;within&#39; the template
                    &lt;-----
               ------------------
            --------&gt;

            And so on...

    &quot;&quot;&quot;

<div class="viewcode-block" id="PCRProductAlignmentGroup.__init__"><a class="viewcode-back" href="../../../generated/dasi.models.PCRProductAlignmentGroup.html#dasi.models.PCRProductAlignmentGroup.__init__">[docs]</a>    def __init__(
        self,
        fwd: Union[None, Alignment],
        template: Alignment,
        rev: Union[None, Alignment],
        query_region: Region,
        group_type: str,
        meta: dict = None,
    ):
        &quot;&quot;&quot;Initialize a new PCRProductAlignmentGroup. Represents a PCR product.
        Query region end points are determined from the first non-None
        alignment and the last non-None alignment. Produces *one new
        alignment*, the template alignment, which is the intersection of the
        provided template alignment and the query_region, which represents the
        exact region for which PCR primers ought to align in a PCR reaction.

        :param fwd: the forward primer alignment. Can be &#39;inside&#39; the template or have an overhang.
        :param template: template alignment
        :param rev: the reverse primer alignment. Can be &#39;within&#39; the template or have an overhang.
        :param group_type: group type name
        :param meta: extra meta data
        &quot;&quot;&quot;
        if fwd is None and rev is None:
            raise AlignmentException(&quot;Must provide either a fwd and/or rev alignments&quot;)
        alignments = [x for x in [fwd, template, rev] if x is not None]

        a = alignments[0].query_region.a
        b = alignments[-1].query_region.b

        query_region = query_region.new(a, b)

        self.raw_template = template
        self._template = None
        self.fwd = fwd
        self.rev = rev

        super().__init__(
            alignments=alignments,
            group_type=group_type,
            query_region=query_region,
            meta=meta,
        )</div>

    @property
    def subject_keys(self):
        raise AlignmentException(
            &quot;Use subject keys directly, as in `self.fwd.subject_key`&quot;
        )</div>


# TODO: rename this class
<div class="viewcode-block" id="MultiPCRProductAlignmentGroup"><a class="viewcode-back" href="../../../generated/dasi.models.alignment.html#dasi.models.MultiPCRProductAlignmentGroup">[docs]</a>class MultiPCRProductAlignmentGroup(AlignmentGroupBase):
    &quot;&quot;&quot;A PCR Product Alignment with redundant forward primer, reverse primer,
    and template alignments.&quot;&quot;&quot;

<div class="viewcode-block" id="MultiPCRProductAlignmentGroup.__init__"><a class="viewcode-back" href="../../../generated/dasi.models.MultiPCRProductAlignmentGroup.html#dasi.models.MultiPCRProductAlignmentGroup.__init__">[docs]</a>    def __init__(
        self,
        groupings: List[Dict[str, Alignment]],
        query_region: Region,
        group_type: str,
    ):
        &quot;&quot;&quot;Initializes a new MultiPCRProductAlignmentGroup.

        :param fwds:
        :param templates:
        :param revs:
        :param query_region:
        :param group_type:
        &quot;&quot;&quot;
        self.groupings = groupings
        self._templates = [None] * len(self.groupings)
        fwds = [d[&quot;fwd&quot;] for d in self.groupings]
        revs = [d[&quot;rev&quot;] for d in self.groupings]
        templates = [d[&quot;template&quot;] for d in self.groupings]
        alignments = [a for a in fwds + revs + templates if a is not None]
        super().__init__(
            alignments=alignments, query_region=query_region, group_type=group_type
        )</div>

    def get_template(self, index):
        if self._templates[index] is None:
            template = self.groupings[index][&quot;template&quot;]
            intersection = template.query_region.intersection(self.query_region)
            self._templates[index] = template.sub_region(intersection.a, intersection.b)
        return self._templates[index]</div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>