<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.models.alignment_container &#8212; dasi 0.0.21 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/style.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>



  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.21</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../usage.html#getting-started">Getting started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#installation">Installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#running-examples">Running examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage.html#advanced">Advanced</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#using-inventory-information-with-dasi">Using inventory information with DASi</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../usage.html#adjusting-design-parameters">Adjusting design parameters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../schemas/schemas.html">JSON Schemas</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#default-cost-parameters">Default Cost Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#cost-parameter-schema">Cost Parameter Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../schemas/schemas.html#cost-parameters-schema">Cost Parameters Schema</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../schemas/schemas.html#design-output-schema">Design Output Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../schemas/schemas.html#dasi-design-output">DASi design output</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../design.html">Design (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.design</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.Design.html">dasi.design.Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.LibraryDesign.html">dasi.design.LibraryDesign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.design.DesignResult.html">dasi.design.DesignResult</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Models (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.models</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Assembly.html">dasi.models.Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AssemblyNode.html">dasi.models.AssemblyNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Molecule.html">dasi.models.Molecule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.MoleculeType.html">dasi.models.MoleculeType</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.Reaction.html">dasi.models.Reaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentGroup.html">dasi.models.AlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentGroupBase.html">dasi.models.AlignmentGroupBase</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.MultiPCRProductAlignmentGroup.html">dasi.models.MultiPCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.PCRProductAlignmentGroup.html">dasi.models.PCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentContainer.html">dasi.models.AlignmentContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/dasi.models.AlignmentContainerFactory.html">dasi.models.AlignmentContainerFactory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../models.html#modules">modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.alignment.html">dasi.models.alignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.models.alignment_container.html">dasi.models.alignment_container</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cost.html">Cost Model (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.cost</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../cost.html#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.cost.utils.html">dasi.cost.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../command_line.html">Command Line (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.command_line</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">Utilities (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.utils</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../utils.html#utility-modules">Utility modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.npdf.html">dasi.utils.npdf</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.region.html">dasi.utils.region</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../utils.html#networkx-utilities">Networkx utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.exceptions.html">dasi.utils.networkx.exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.shortest_path.html">dasi.utils.networkx.shortest_path</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../generated/dasi.utils.networkx.utils.html">dasi.utils.networkx.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../exceptions.html">Exceptions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.exceptions</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../constants.html">Constants (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.constants</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guidelines.html">Code Guidelines</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for dasi.models.alignment_container</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;Alignment container.&quot;&quot;&quot;
from bisect import bisect_left
from collections.abc import Mapping
from collections.abc import Sized
from typing import Any
from typing import Callable
from typing import Dict
from typing import List
from typing import Tuple
from typing import Union

from Bio.SeqRecord import SeqRecord
from frozendict import frozendict
from more_itertools import flatten
from more_itertools import partition
from more_itertools import unique_everseen

from .alignment import Alignment
from .alignment import AlignmentGroup
from .alignment import MultiPCRProductAlignmentGroup
from .alignment import PCRProductAlignmentGroup
from dasi.config import Config
from dasi.constants import Constants
from dasi.exceptions import AlignmentContainerException
from dasi.log import logger
from dasi.utils import bisect_slice_between
from dasi.utils import Region
from dasi.utils import sort_with_keys


<div class="viewcode-block" id="blast_to_region"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.blast_to_region">[docs]</a>def blast_to_region(query_or_subject: dict, seqdb: Dict[str, SeqRecord]) -&gt; Region:
    &quot;&quot;&quot;Converts a blast data result to a Region. Blast results are indicated by
    two positions with index starting at 1 and positions being inclusive. This
    returns a Region with index starting at 0 and the end point position being
    exclusive.

    :param query_or_subject:
    :type query_or_subject:
    :param seqdb:
    :type seqdb:
    :return:
    :rtype:
    &quot;&quot;&quot;
    data = query_or_subject
    record = seqdb[data[&quot;origin_key&quot;]]

    s, e = data[&quot;start&quot;], data[&quot;raw_end&quot;]
    length = len(record)

    if data[&quot;strand&quot;] == -1:
        s, e = e, s

    region = Region(
        s - 1,
        e,
        length=length,
        cyclic=data[&quot;circular&quot;],
        direction=data[&quot;strand&quot;],
        index=0,
        name=&quot;{}: {}&quot;.format(record.id, record.name),
        ignore_wrap=False,
    )
    return region</div>


class GroupTags(Mapping):
    def __init__(self):
        self.tags = {}
        self.constructors = {}
        self.cached = {}

    def new_tag(self, name: str, constructor: Callable):
        self.tags[name] = {}
        self.cached[name] = {}
        self.constructors[name] = constructor

    def add(self, name, key, data):
        self.tags[name].setdefault(key, list())
        self.tags[name][key].append(data)
        self.cached[name] = None

    def all(self):
        groups = []
        for tag in self.tags:
            groups += self[tag]
        return groups

    def __getitem__(self, name):
        if self.cached[name]:
            return self.cached[name]
        else:
            results = self.constructors[name](self.tags[name])
            self.cached[name] = results
            return results

    def __contains__(self, name):
        return name in self.tags

    def __iter__(self):
        return self.tags.__iter__()

    def __len__(self):
        return len(self.tags)


<div class="viewcode-block" id="AlignmentContainer"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer">[docs]</a>class AlignmentContainer(Sized):
    &quot;&quot;&quot;Container for a set of query-to-subject alignments for a single query.

    Instance Attributes/Properties:
        alignments  list of alignments for the container
                    List[Alignment]
        seqdb       key to SeqRecord dictionary
                    Dict[str, SeqRecord]
        logger      the instance&#39;s logger
                    Loggable

    This class contains:
        1. Methods grouping alignments together according to those
    alignments that share the same starting and ending points.
        2. Methods for &#39;expanding&#39; alignments
    &quot;&quot;&quot;

    valid_types = (
        Constants.PCR_PRODUCT,
        Constants.PRIMER,
        Constants.FRAGMENT,
        Constants.PCR_PRODUCT_WITH_PRIMERS,
        Constants.PCR_PRODUCT_WITH_LEFT_PRIMER,
        Constants.PCR_PRODUCT_WITH_RIGHT_PRIMER,
        Constants.PRIMER_EXTENSION_PRODUCT_WITH_PRIMERS,
        Constants.PRIMER_EXTENSION_PRODUCT_WITH_LEFT_PRIMER,
        Constants.PRIMER_EXTENSION_PRODUCT_WITH_RIGHT_PRIMER,
        Constants.SHARED_FRAGMENT,
        Constants.GAP,
        Constants.OVERLAP,
        Constants.MISSING,
        Constants.SHARED_SYNTHESIZED_FRAGMENT,
    )  # valid fragment types

<div class="viewcode-block" id="AlignmentContainer.__init__"><a class="viewcode-back" href="../../../generated/dasi.models.AlignmentContainer.html#dasi.models.AlignmentContainer.__init__">[docs]</a>    def __init__(self, seqdb: Dict[str, SeqRecord], alignments=None):
        self._alignments = []
        self._frozen = False
        self._frozen_groups = None
        if alignments is not None:
            self.set_alignments(alignments)
        self.seqdb = seqdb
        self.logger = logger(self)

        self.group_tags = GroupTags()
        self.group_tags.new_tag(Constants.PCR_GROUP_TAG, self.pcr_constructor)
        self.group_tags.new_tag(Constants.SHARE_GROUP_TAG, self.share_constructor)</div>

    @staticmethod
    def pcr_constructor(data):
        groups = []
        for (a, b, group_type), adict_list in data.items():
            groupings = [
                {&quot;fwd&quot;: d[&quot;fwd&quot;], &quot;rev&quot;: d[&quot;rev&quot;], &quot;template&quot;: d[&quot;template&quot;]}
                for d in adict_list
            ]

            regions = [d[&quot;query_region&quot;] for d in adict_list]
            assert len({(q.a, q.b) for q in regions}) == 1

            groups.append(
                MultiPCRProductAlignmentGroup(
                    groupings,
                    query_region=adict_list[0][&quot;query_region&quot;],
                    group_type=group_type,
                )
            )
        return groups

    @staticmethod
    def share_constructor(data):
        groups = []
        for (a, b, group_type), entry in data.items():
            if entry:
                groups.append(
                    AlignmentGroup(
                        entry[0][&quot;alignments&quot;],
                        group_type=group_type,
                        meta={
                            &quot;n_clusters&quot;: entry[0][&quot;n_clusters&quot;],
                            &quot;cross_container_alignments&quot;: entry[0][
                                &quot;cross_container_alignments&quot;
                            ],
                        },
                    )
                )
        return groups

    @property
    def alignments(self):
        return self._alignments

    # @alignments.setter
    # def alignments(self, v):
    #     if self._frozen:
    #         raise AlignmentContainerException(
    #             &quot;Cannot set alignments. Container is frozen.&quot;
    #         )
    #     self._alignments = v
    #     self._check_single_query_key(self._alignments)

    def set_alignments(self, alignments: List[Alignment], lim_size: bool = False):
        if self._frozen:
            raise AlignmentContainerException(
                &quot;Cannot set alignments. Container is frozen.&quot;
            )
        if lim_size:
            alignments = [a for a in alignments if a.size_ok()]
        self._alignments = alignments
        self._check_single_query_key(self._alignments)

    def add_alignments(self, alignments: List[Alignment], lim_size: bool = False):
        hashes = [align.eq_hash() for align in self.alignments]
        new_alignments = []
        for align in alignments:
            if not lim_size or align.size_ok():
                if align.eq_hash() not in hashes:
                    new_alignments.append(align)
        self.set_alignments(self.alignments + new_alignments)
        return new_alignments

    @staticmethod
    def _check_single_query_key(alignments):
        keys = {a.query_key for a in alignments}
        if len(keys) &gt; 1:
            raise AlignmentContainerException(
                &quot;AlignmentContainer cannot contain more than one query. Contains the &quot;
                &quot;following query keys: {}&quot;.format(keys)
            )

    @staticmethod
    def filter_alignments_by_span(alignments, region, key=None, end_inclusive=True):
        fwd, fwd_keys = sort_with_keys(alignments, key=key)
        found = []
        for a, b in region.ranges(ignore_wraps=True):
            if not end_inclusive:
                b = b - 1
            found += bisect_slice_between(fwd, fwd_keys, a, b)
        return found

<div class="viewcode-block" id="AlignmentContainer.find_groups_by_pos"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer.find_groups_by_pos">[docs]</a>    def find_groups_by_pos(
        self, a: int, b: int, group_type: str, groups=None
    ) -&gt; List[Union[AlignmentGroup, PCRProductAlignmentGroup]]:
        &quot;&quot;&quot;Return a list of groups that have the same positions (a, b) and same
        group_type.

        :param a: starting position
        :param b: ending position
        :param group_type: group_type
        :param groups: optional list of groups to search
        :return: list of groups
        &quot;&quot;&quot;

        if group_type not in list(self.valid_types) + [&quot;ANY&quot;]:
            raise AlignmentContainerException(
                &quot;Type &#39;{}&#39; not found in valid types: {}&quot;.format(
                    group_type, self.valid_types
                )
            )
        if groups is None:
            groups = self.groups()
        found = []
        for g in groups:
            if (
                g.query_region.a == a
                and g.query_region.b == b
                and (group_type == &quot;ANY&quot; or g.type == group_type)
            ):
                found.append(g)
        return found</div>

<div class="viewcode-block" id="AlignmentContainer._create_pcr_product_alignment"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer._create_pcr_product_alignment">[docs]</a>    def _create_pcr_product_alignment(
        self,
        template_group: AlignmentGroup,
        fwd: Union[Alignment, None],
        rev: Union[Alignment, None],
        alignment_type: str,
        lim_size: bool,
    ):
        &quot;&quot;&quot;
        Create a new alignment group for a PCR product.

        ::

            Situations the PCRProductAlignmentGroup represents:

                        &lt;--------
            ------------------
            ----&gt;

                           &lt;--------
               ------------------
            --------&gt;


                    &lt;-----
               ------------------
            --------&gt;


                          &lt;------
               ------------------
            --------&gt;

        :param template_group:
        :param fwd:
        :param rev:
        :param alignment_type:
        :return:
        &quot;&quot;&quot;
        groups = []
        for a in template_group.alignments:
            product_group = PCRProductAlignmentGroup(
                fwd=fwd,
                template=a,
                rev=rev,
                query_region=a.query_region,
                group_type=alignment_type,
            )

            if lim_size and not product_group.size_ok():
                continue
            self._new_pcr_grouping_tag(product_group)
            groups.append(product_group)
        return groups</div>

    def _create_primer_extension_alignment(
        self, fwd: Alignment, rev: Alignment, alignment_type: str, lim_size: bool
    ):
        if fwd is None:
            query_region = rev.query_region
        else:
            query_region = fwd.query_region
        product_group = PCRProductAlignmentGroup(
            fwd=fwd,
            template=None,
            rev=rev,
            query_region=query_region,
            group_type=alignment_type,
        )
        if lim_size and not product_group.size_ok():
            return []
        self._new_pcr_grouping_tag(product_group)
        return [product_group]

<div class="viewcode-block" id="AlignmentContainer._make_subgroup"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer._make_subgroup">[docs]</a>    def _make_subgroup(
        self, group: AlignmentGroup, a: int, b: int, atype: str
    ) -&gt; Union[AlignmentGroup, None]:
        &quot;&quot;&quot;Make a subgroup at the specified indices.

        Returns None if a, b and the indices of the group.query_region
        or if a == b
        &quot;&quot;&quot;
        region = group.query_region
        if region.a == a and region.b == b:
            return None
        elif a == b:
            return None
        subgroup = group.sub_region(a, b, atype)
        return subgroup</div>

    def expand_primer_extension_products(self, only_one_required=False, lim_size=True):
        primers = self.get_alignments_by_types(Constants.PRIMER)

        rev, fwd = partition(lambda p: p.subject_region.direction == 1, primers)
        fwd, fwd_keys = sort_with_keys(fwd, key=lambda p: p.query_region.b)
        rev, rev_keys = sort_with_keys(rev, key=lambda p: p.query_region.a)
        pairs = []
        for f in fwd:
            rev_bind_region = f.query_region[: -Config.PRIMER_MIN_BIND]
            rev_bind = self.filter_alignments_by_span(
                rev, rev_bind_region, key=lambda p: p.query_region.a
            )
            rev_bind, rkeys = sort_with_keys(rev_bind, key=lambda p: p.query_region.a)

            for r in rev_bind:
                if r.query_region.b in f.query_region:
                    if r.query_region.b == f.query_region.b:
                        pass
                    else:
                        continue
                pairs += self._create_primer_extension_alignment(
                    f,
                    r,
                    Constants.PRIMER_EXTENSION_PRODUCT_WITH_PRIMERS,
                    lim_size=lim_size,
                )

        if only_one_required:
            for f in fwd:
                # existing fwd primer
                pairs += self._create_primer_extension_alignment(
                    f,
                    None,
                    Constants.PRIMER_EXTENSION_PRODUCT_WITH_LEFT_PRIMER,
                    lim_size=lim_size,
                )

            for r in rev:
                # existing fwd primer
                pairs += self._create_primer_extension_alignment(
                    None,
                    r,
                    Constants.PRIMER_EXTENSION_PRODUCT_WITH_RIGHT_PRIMER,
                    lim_size=lim_size,
                )
        return pairs

<div class="viewcode-block" id="AlignmentContainer.expand_primer_pairs"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer.expand_primer_pairs">[docs]</a>    def expand_primer_pairs(
        self, alignment_groups: List[AlignmentGroup], lim_size: bool = True
    ) -&gt; List[Alignment]:
        &quot;&quot;&quot;Creates new alignments for all possible primer pairs. Searches for
        fwd and rev primer pairs that exist within other alignments and
        produces all combinations of alignments that can form from these primer
        pairs.

        :return: list
        &quot;&quot;&quot;
        primers = self.get_alignments_by_types(Constants.PRIMER)

        rev, fwd = partition(lambda p: p.subject_region.direction == 1, primers)
        fwd, fwd_keys = sort_with_keys(fwd, key=lambda p: p.query_region.b)
        rev, rev_keys = sort_with_keys(rev, key=lambda p: p.query_region.a)
        pairs = []

        for g in self.logger.tqdm(
            alignment_groups, &quot;INFO&quot;, desc=&quot;Expanding primer pair&quot;
        ):
            query_ranges = g.query_region.ranges()
            fwd_bind_region = g.query_region[Config.PRIMER_MIN_BIND :]
            rev_bind_region = g.query_region[: -Config.PRIMER_MIN_BIND]
            fwd_bind = self.filter_alignments_by_span(
                fwd, fwd_bind_region, key=lambda p: p.query_region.b
            )
            rev_bind = self.filter_alignments_by_span(
                rev, rev_bind_region, key=lambda p: p.query_region.a
            )
            rev_bind, rkeys = sort_with_keys(rev_bind, key=lambda p: p.query_region.a)

            # both primers
            for f in fwd_bind:
                _rev_bind = []
                if len(query_ranges) == 1:
                    i = bisect_left(rkeys, f.query_region.a)
                    _rev_bind = rev_bind[i:]
                else:
                    try:
                        _rev_span = g.query_region.sub(
                            f.query_region.a, g.query_region.b
                        )
                    except IndexError:
                        _rev_span = g.query_region

                    for a, b in _rev_span.ranges():
                        _rev_bind += bisect_slice_between(rev_bind, rkeys, a, b)
                for r in _rev_bind:
                    if f.query_region.a in r.query_region:
                        if f.query_region.a == r.query_region.a:
                            pass
                        else:
                            continue
                    if r.query_region.b in f.query_region:
                        if r.query_region.b == f.query_region.b:
                            pass
                        else:
                            continue
                    pairs += self._create_pcr_product_alignment(
                        g, f, r, Constants.PCR_PRODUCT_WITH_PRIMERS, lim_size=lim_size
                    )
            # left primer
            for f in fwd_bind:
                pairs += self._create_pcr_product_alignment(
                    g,
                    f,
                    None,
                    Constants.PCR_PRODUCT_WITH_LEFT_PRIMER,
                    lim_size=lim_size,
                )

            # right primer
            for r in rev_bind:
                pairs += self._create_pcr_product_alignment(
                    g,
                    None,
                    r,
                    Constants.PCR_PRODUCT_WITH_RIGHT_PRIMER,
                    lim_size=lim_size,
                )
        return pairs</div>

<div class="viewcode-block" id="AlignmentContainer.expand_overlaps"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer.expand_overlaps">[docs]</a>    def expand_overlaps(
        self,
        alignment_groups: List[AlignmentGroup],
        atype=Constants.PCR_PRODUCT,
        lim_size: bool = True,
        pass_condition: Callable = None,
        include_left: bool = True,
    ) -&gt; List[Alignment]:
        &quot;&quot;&quot;
        Expand the list of alignments from existing regions. Produces new fragments in
        the following two situations:

        ::

            if `include_left`
            |--------|          alignment 1
                |--------|      alignment 2
            |---|               new alignment


            |--------|          alignment 1
                 |--------|     alignment 2
                 |---|          new alignment

        :param alignment_groups: list of alignment groups to expand
        :param atype: the alignment type label for expanded alignments
        :param lim_size: if True, only add alignments that pass the size limitations
        :param pass_condition: an optional callable that takes group_a (AlignmentGroup)
            and group_b (AlignmentGroup). If the returned value is False, alignments
            are skipped.
        :param include_left: if True, will add overlapping region and the left
            region up to the overlap.
        :return: list of new alignments
        &quot;&quot;&quot;

        min_overlap = Config.MIN_OVERLAP
        group_sort, group_keys = sort_with_keys(
            alignment_groups, key=lambda x: x.query_region.a
        )
        alignments = []
        for group_a in logger.tqdm(group_sort, &quot;INFO&quot;, desc=&quot;expanding pcr products&quot;):
            overlapping = self.filter_alignments_by_span(
                group_sort,
                group_a.query_region,
                key=lambda p: p.query_region.a,
                end_inclusive=False,
            )

            for group_b in overlapping:
                if group_b is not group_a:
                    # ignore groups that are completely contained in region
                    if group_b.query_region.b in group_a.query_region:
                        continue
                    if pass_condition:
                        if not pass_condition(group_a, group_b):
                            continue

                    if include_left:
                        left = self._make_subgroup(
                            group_a,
                            group_a.query_region.a,
                            group_b.query_region.a,
                            atype,
                        )
                        if left and len(left.query_region) &gt; min_overlap:
                            alignments += left.alignments

                    overlap = self._make_subgroup(
                        group_a, group_b.query_region.a, group_a.query_region.b, atype
                    )
                    if overlap and len(overlap.query_region) &gt; min_overlap:
                        alignments += overlap.alignments
        if lim_size:
            alignments = [a for a in alignments if a.size_ok()]
        return alignments</div>

<div class="viewcode-block" id="AlignmentContainer.copy_groups"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer.copy_groups">[docs]</a>    def copy_groups(self, alignment_groups: List[AlignmentGroup], atype: str):
        &quot;&quot;&quot;Copy alignments from the list of groups to a new alignment type.&quot;&quot;&quot;
        alignments = []
        for g in alignment_groups:
            for align in g.alignments:
                alignments.append(align.copy(atype))
        return alignments</div>

    # TODO: break apart long alignments
<div class="viewcode-block" id="AlignmentContainer.expand"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer.expand">[docs]</a>    def expand(
        self,
        expand_overlaps=True,
        expand_primers=True,
        expand_primer_dimers=False,
        lim_size: bool = True,
    ):
        &quot;&quot;&quot;Alignment expansion algorithm.

        :param expand_overlaps: if True, expand overlaps
        :param expand_primers: if True, expand primer pairs
        :param expand_primer_dimers: if True, expand primer dimer pairs
        :param lim_size: if True, limit the size of the alignment according to theri
            Molecule definitions
        :return: None
        &quot;&quot;&quot;

        templates = self.get_groups_by_types(
            [Constants.PCR_PRODUCT, Constants.FRAGMENT]
        )
        if lim_size:
            templates = [t for t in templates if t.size_ok()]

        if expand_primers:
            # NOTE: does not need to append alignments
            self.expand_primer_pairs(templates, lim_size=lim_size)

        if expand_primer_dimers:
            # NOTE: this does not need to append alignments
            self.expand_primer_extension_products(lim_size=lim_size)

        # TODO: why not expand overlaps using the primer pairs???
        if expand_overlaps:
            expanded = self.expand_overlaps(
                templates, atype=Constants.PCR_PRODUCT, lim_size=lim_size
            )
            self.add_alignments(expanded, lim_size=lim_size)</div>

    def _new_pcr_grouping_tag(self, group: PCRProductAlignmentGroup):
        group_key = (group.query_region.a, group.query_region.b, group.type)
        data = {
            &quot;fwd&quot;: group.fwd,
            &quot;template&quot;: group.template,
            &quot;rev&quot;: group.rev,
            &quot;query_region&quot;: group.query_region,
        }
        self.group_tags.add(Constants.PCR_GROUP_TAG, group_key, data)

<div class="viewcode-block" id="AlignmentContainer._alignment_hash"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer._alignment_hash">[docs]</a>    @staticmethod
    def _alignment_hash(a):
        &quot;&quot;&quot;A hashable representation of an alignment for grouping.&quot;&quot;&quot;
        return a.query_region.a, a.query_region.b, a.query_region.direction, a.type</div>

    def pcr_alignment_groups(self):
        return self.group_tags[Constants.PCR_GROUP_TAG]

<div class="viewcode-block" id="AlignmentContainer.clean_alignments"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer.clean_alignments">[docs]</a>    def clean_alignments(self):
        &quot;&quot;&quot;Remove redundant alignments.&quot;&quot;&quot;
        grouped = {}
        for a in self.alignments:
            key = a.eq_hash()

            assert isinstance(key, tuple)
            try:
                grouped.setdefault(key, list())
            except Exception as e:
                raise e
            grouped[key].append(a)

        self.set_alignments([v[0] for v in grouped.values()])</div>

<div class="viewcode-block" id="AlignmentContainer.redundent_alignment_groups"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer.redundent_alignment_groups">[docs]</a>    @classmethod
    def redundent_alignment_groups(
        cls, alignments: List[Alignment]
    ) -&gt; List[AlignmentGroup]:
        &quot;&quot;&quot;Return AlignmentGroups that have been grouped by alignment_hash.

        :param alignments:
        :return:
        &quot;&quot;&quot;
        grouped = {}
        for a in alignments:
            grouped.setdefault(cls._alignment_hash(a), list()).append(a)
        alignment_groups = []
        for group in grouped.values():
            alignment_groups.append(AlignmentGroup(group, group[0].type))
        return alignment_groups</div>

    def groups(self) -&gt; List[Union[AlignmentGroup, MultiPCRProductAlignmentGroup]]:
        if self._frozen:
            return self._frozen_groups
        else:
            allgroups = []
            allgroups += self.redundent_alignment_groups(self.alignments)
            allgroups += self.group_tags.all()
            self._frozen_groups = allgroups
            return allgroups

    @property
    def types(self) -&gt; Tuple[Any, ...]:
        &quot;&quot;&quot;Return all valid types.

        :return:
        &quot;&quot;&quot;
        return tuple(self.valid_types)

<div class="viewcode-block" id="AlignmentContainer.get_groups_by_types"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer.get_groups_by_types">[docs]</a>    def get_groups_by_types(
        self, types: List[str]
    ) -&gt; Union[AlignmentGroup, List[AlignmentGroup]]:
        &quot;&quot;&quot;Return AlignmentGroups by fragment type.

        :param types: list of types
        :return:
        &quot;&quot;&quot;
        groups = self.groups_by_type()
        if isinstance(types, str):
            return groups[types]
        else:
            return list(unique_everseen(flatten([groups[t] for t in types])))</div>

    def get_alignments_by_types(self, types: List[str]) -&gt; List[Alignment]:
        groups = self.get_groups_by_types(types)
        return list(flatten([g.alignments for g in groups]))

<div class="viewcode-block" id="AlignmentContainer.groups_by_type"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer.groups_by_type">[docs]</a>    def groups_by_type(
        self
    ) -&gt; Dict[str, List[Union[AlignmentGroup, PCRProductAlignmentGroup]]]:
        &quot;&quot;&quot;Return alignment groups according to their alignment &#39;type&#39;.

        :return: dict
        &quot;&quot;&quot;
        d = {}
        for t in self.valid_types:
            d[t] = []
        for g in self.groups():
            d[g.type].append(g)
        return d</div>

<div class="viewcode-block" id="AlignmentContainer.freeze"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer.freeze">[docs]</a>    def freeze(self):
        &quot;&quot;&quot;Freeze the container, disallowing further modifications to
        alignments.&quot;&quot;&quot;
        self._alignments = tuple(self._alignments)
        self._frozen = True</div>

<div class="viewcode-block" id="AlignmentContainer.unfreeze"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainer.unfreeze">[docs]</a>    def unfreeze(self):
        &quot;&quot;&quot;Unfreeze the container, allowing modifications to alignments.&quot;&quot;&quot;
        self._alignments = list(self._alignments)
        self._frozen = False</div>

    def __len__(self):
        return len(self.alignments)</div>


<div class="viewcode-block" id="AlignmentContainerFactory"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainerFactory">[docs]</a>class AlignmentContainerFactory:
    &quot;&quot;&quot;Class that maintains a shared list of alignments and shared sequence
    database.

    AlignmentContainers can be retrieved in a dict grouped by their
    query via `.containers()`
    &quot;&quot;&quot;

    valid_types = (
        Constants.PCR_PRODUCT,
        Constants.PRIMER,
        Constants.FRAGMENT,
        Constants.PCR_PRODUCT_WITH_PRIMERS,
        Constants.PCR_PRODUCT_WITH_LEFT_PRIMER,
        Constants.PCR_PRODUCT_WITH_RIGHT_PRIMER,
        Constants.SHARED_FRAGMENT,
        Constants.PRIMER_EXTENSION_PRODUCT_WITH_PRIMERS,
        Constants.PRIMER_EXTENSION_PRODUCT_WITH_LEFT_PRIMER,
        Constants.PRIMER_EXTENSION_PRODUCT_WITH_RIGHT_PRIMER,
        Constants.SHARED_SYNTHESIZED_FRAGMENT,
    )  # valid fragment types

<div class="viewcode-block" id="AlignmentContainerFactory.__init__"><a class="viewcode-back" href="../../../generated/dasi.models.AlignmentContainerFactory.html#dasi.models.AlignmentContainerFactory.__init__">[docs]</a>    def __init__(self, seqdb: Dict[str, SeqRecord]):
        &quot;&quot;&quot;Construct a new AlignmentContainer.

        :param seqdb: a sequence record database
        &quot;&quot;&quot;
        self._alignments = (
            {}
        )  # dictionary of query_key to alignment; Dict[str, List[Alignment]]
        self._containers = None
        self.logger = logger(self)
        self.seqdb = seqdb</div>

    @property
    def alignments(self) -&gt; frozendict:
        &quot;&quot;&quot;Return dict of alignments keyed by query_key.

        :return:
        &quot;&quot;&quot;
        return frozendict(self._alignments)

    def add_alignments(self, alignments: List[Alignment]):
        grouped = {}
        for align in alignments:
            grouped.setdefault(align.query_key, list())
            grouped[align.query_key].append(align)

        for k, v in grouped.items():
            for a in v:
                if a not in self._alignments[k]:
                    self._alignments[k].append(a)

    def initialize_empty(self, query_keys: List[str]):
        for query_key in query_keys:
            self._alignments[query_key] = []

<div class="viewcode-block" id="AlignmentContainerFactory.load_blast_json"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainerFactory.load_blast_json">[docs]</a>    def load_blast_json(self, data: List[Dict], atype: str):
        &quot;&quot;&quot;Create alignments from a formatted BLAST JSON result.

        :param data: formatted BLAST JSON result
        :param atype: the type of alignment to initialize
        :return: None
        &quot;&quot;&quot;
        self.logger.info(
            &#39;Loading blast json ({} entries) to fragment type &quot;{}&quot;&#39;.format(
                len(data), atype
            )
        )
        assert atype in self.valid_types
        for d in data:
            query_region = blast_to_region(d[&quot;query&quot;], self.seqdb)
            subject_region = blast_to_region(d[&quot;subject&quot;], self.seqdb)
            query_key = d[&quot;query&quot;][&quot;origin_key&quot;]
            subject_key = d[&quot;subject&quot;][&quot;origin_key&quot;]

            alignment = Alignment(
                query_region=query_region,
                subject_region=subject_region,
                atype=atype,
                query_key=query_key,
                subject_key=subject_key,
            )
            self._alignments.setdefault(query_key, list()).append(alignment)</div>

<div class="viewcode-block" id="AlignmentContainerFactory.containers"><a class="viewcode-back" href="../../../generated/dasi.models.alignment_container.html#dasi.models.AlignmentContainerFactory.containers">[docs]</a>    def containers(self) -&gt; Dict[str, AlignmentContainer]:
        &quot;&quot;&quot;Return dictionary of AlignmentContainers keyed by query_keys.

        :return:
        &quot;&quot;&quot;
        if self._containers is None:
            container_dict = {}
            for key, alignments in self.alignments.items():
                container_dict[key] = AlignmentContainer(
                    self.seqdb, alignments=alignments
                )
            self._containers = container_dict
        return frozendict(self._containers)</div>

    def reset(self):
        self._containers = None</div>

    # def set_alignments(self, alignments):
    #     self._alignments = alignments
    #     self._containers = None
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>