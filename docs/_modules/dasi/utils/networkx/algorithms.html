<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.utils.networkx.algorithms &#8212; dasi 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../../_static/bootstrap-sphinx.js "></script>

  </head><body>
    


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer/api_reference.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../developer/api_reference.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for dasi.utils.networkx.algorithms</h1><div class="highlight"><pre>
<span></span>import networkx as nx
import numpy as np
from .utils import divide, select_from_arrs, replace_nan_with_inf
from sympy import sympify, lambdify
from collections import OrderedDict
from .exceptions import TerrariumNetworkxError

# TODO: cycle finder using *almost cycles*
# TODO: test directed vs undirected
# TODO: test multigraph


# def _archived_floyd_warhsall_with_efficiency(
#     G, weight=&quot;weight&quot;, efficiency=&quot;eff&quot;, nodelist=None, return_all=False, dtype=None
# ):
#     &quot;&quot;&quot;
#     Computes the shortest path between all pairs using the cost function: SUM(w) / PROD(e)
#
#     Warning: This is guaranteed to return precise values due to floating point rounding errors.
#
#     :param G:
#     :param weight:
#     :param efficiency:
#     :param nodelist:
#     :return:
#     &quot;&quot;&quot;
#     if dtype is None:
#         dtype = np.float64
#     A = nx.to_numpy_matrix(
#         G,
#         nodelist=nodelist,
#         multigraph_weight=min,
#         weight=weight,
#         nonedge=np.inf,
#         dtype=dtype,
#     )
#     B = nx.to_numpy_matrix(
#         G,
#         nodelist=nodelist,
#         multigraph_weight=min,
#         weight=efficiency,
#         nonedge=0.0,
#         dtype=dtype,
#     )
#
#     n, m = A.shape
#     I = np.identity(n)
#     A[I == 1] = 0  # diagonal elements should be zero
#     B[I == 1] = 1
#
#     for i in np.arange(n):
#         # get weight and efficiency of path using node &#39;i&#39;
#         A_part = A[i, :] + A[:, i]
#         B_part = np.multiply(B[i, :], B[:, i])
#
#         # get total cost
#         C = divide(A, B)
#         C_part = divide(A_part, B_part)
#
#         # update
#         A = np.asmatrix(select_from_arrs(A, A_part, C &lt; C_part))
#         B = np.asmatrix(select_from_arrs(B, B_part, C &lt; C_part))
#
#     C = divide(A, B)
#     if return_all:
#         return C, A, B
#     else:
#         return C


PRODUCT = &quot;product&quot;
SUM = &quot;sum&quot;


<div class="viewcode-block" id="sympy_floyd_warshall"><a class="viewcode-back" href="../../../../developer/_autosummary/_autosummary/_autosummary/dasi.utils.networkx.algorithms.html#dasi.utils.networkx.algorithms.sympy_floyd_warshall">[docs]</a>def sympy_floyd_warshall(
    G,
    f,
    accumulators: dict,
    nonedge=None,
    nodelist=None,
    multigraph_weight=None,
    identity_subs=None,
    return_all=False,
    dtype=None,
):
    &quot;&quot;&quot;
    Implementation of all pairs shortest path length using a modified floyd-warshall algorithm with arbitrary path
    length functions. The following path length function is valid:

    $$
    C = \frac{\sum_{i}^{n}{a_i}}{\prod_{i}^{n}{b_i}}
    $$

    Where $a_i$ and $b_i$ is the weight &#39;a&#39; and &#39;b&#39; of the *ith* edge in the path respectively.
    $\sum_{i}^{n}{a_i}$ is the accumulated sum of weights &#39;a&#39; and $\prod_{i}^{n}{b_i}$
     is the accumulated product of weights &#39;b&#39;. Arbitrarily complex path functions with arbitrary numbers of weights
     ($a, b, c,...$) can be used in the algorithm.

    Because arbitrary functions are used, the shortest path between ij and jk does not necessarily mean the shortest
    path nodes ijk is the concatenation of these two paths. In other words, for the shortest path $p_{ik}$ between
    nodes $i$ $j$ and $k$:

    $$
    p_{ij} + p_{jk} \neq p_{ijk}
    $$

    This means a predecessor dictionary cannot be used to reconstruct the paths easily. To do so, use the modified
    Dijkstra&#39;s algorithm below which handles arbitrary path functions.

    :param accumulators: if &#39;sum&#39; or missing, apply $\sum$, if &#39;product&#39; apply $\prod$ to edge weights
    :param nonedge:
    :param nodelist:
    :param multigraph_weight:
    :param identity_subs:
    :param return_all:
    :param dtype:
    :return:
    &quot;&quot;&quot;
    if dtype is None:
        dtype = np.float64

    if identity_subs is None:
        identity_subs = {}

    if multigraph_weight is None:
        multigraph_weight = {}

    if nonedge is None:
        nonedge = {}

    expr = sympify(f)
    symbols = tuple(expr.free_symbols)
    func = lambdify(symbols, expr)

    matrix_dict = OrderedDict()

    for sym in symbols:
        matrix_dict[sym.name] = nx.to_numpy_matrix(
            G,
            nodelist=nodelist,
            multigraph_weight=multigraph_weight.get(sym.name, min),
            weight=sym.name,
            nonedge=nonedge.get(sym.name, np.inf),
            dtype=dtype,
        )

    n, m = list(matrix_dict.values())[0].shape

    # replace diagonals
    I = np.identity(n)
    for key, matrix in matrix_dict.items():
        # set accumulators
        if accumulators.get(key, SUM) == SUM:
            d = 0.0
        elif accumulators[key] == PRODUCT:
            d = 1.0
        else:
            raise TerrariumNetworkxError(
                &quot;Accumulator key {} must either by &#39;{}&#39; or &#39;{}&#39; or a callable with two &quot;
                &quot;arguments (&#39;M&#39; a numpy matrix and &#39;i&#39; a node index as an int)&quot;.format(
                    key
                )
            )

        # set diagonal
        matrix[I == 1] = identity_subs.get(key, d)

    for i in np.arange(n):
        # get costs if using node &#39;i&#39;
        parts_dict = OrderedDict()
        for key, M in matrix_dict.items():
            M = matrix_dict[key]
            if accumulators.get(key, SUM) == SUM:
                parts_dict[key] = M[i, :] + M[:, i]
            elif accumulators[key] == PRODUCT:
                parts_dict[key] = np.multiply(M[i, :], M[:, i])
            else:
                raise TerrariumNetworkxError(
                    &quot;Key &#39;{}&#39; not in accumulator dictionary. Options are &#39;{}&#39; or &#39;{}&#39;&quot;.format(
                        PRODUCT, SUM
                    )
                )

        # get total cost
        m_arr = [np.asarray(m) for m in matrix_dict.values()]
        p_arr = [np.asarray(m) for m in parts_dict.values()]
        C = replace_nan_with_inf(func(*m_arr))
        C_part = replace_nan_with_inf(func(*p_arr))

        # update
        for key, M in matrix_dict.items():
            part = parts_dict[key]
            c = C &gt; C_part

            # TODO: is this if np.any(c) correct?
            if np.any(c):
                assert M.shape == part.shape
                # matrix_dict[key] = np.asmatrix(np.choose(c, (M, part)))
                matrix_dict[key] = np.asmatrix(select_from_arrs(part, M, C &lt; C_part))

    m_arr = [np.asarray(m) for m in matrix_dict.values()]
    C = replace_nan_with_inf(func(*m_arr))
    if return_all:
        return C, matrix_dict
    return C</div>


<div class="viewcode-block" id="floyd_warshall_with_efficiency"><a class="viewcode-back" href="../../../../developer/_autosummary/_autosummary/_autosummary/dasi.utils.networkx.algorithms.html#dasi.utils.networkx.algorithms.floyd_warshall_with_efficiency">[docs]</a>def floyd_warshall_with_efficiency(
    G, weight, efficiency, nodelist=None, return_all=False, dtype=None
):
    &quot;&quot;&quot;
    Computes the shortest path between all pairs using the cost function: SUM(w) / PROD(e)

    Warning: This is guaranteed to return precise values due to floating point rounding errors.

    :param G:
    :param weight:
    :param efficiency:
    :param nodelist:
    :return:
    &quot;&quot;&quot;
    f = &quot;{} / {}&quot;.format(weight, efficiency)
    return sympy_floyd_warshall(
        G,
        f,
        accumulators={weight: SUM, efficiency: PRODUCT},
        nonedge={weight: np.inf, efficiency: 0.0},
        nodelist=nodelist,
        return_all=return_all,
        dtype=dtype,
    )</div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>