<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.utils.region &#8212; dasi 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="dasi.constants" href="../dasi.constants.html" />
    <link rel="prev" title="dasi.utils.npdf" href="dasi.utils.npdf.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>
    


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../api_reference.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../api_reference.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="dasi.utils.npdf.html" title="Previous Chapter: dasi.utils.npdf"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; dasi.utils.npdf</span>
    </a>
  </li>
  <li>
    <a href="../dasi.constants.html" title="Next Chapter: dasi.constants"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">dasi.constants &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../../../_sources/developer/_autosummary/_autosummary/dasi.utils.region.rst"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="module-dasi.utils.region">
<span id="dasi-utils-region"></span><h1>dasi.utils.region<a class="headerlink" href="#module-dasi.utils.region" title="Permalink to this headline">¶</a></h1>
<p class="rubric">Classes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Direction</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan" title="dasi.utils.region.EmptySpan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EmptySpan</span></code></a>(a, b, l[, cyclic, index, …])</p></td>
<td><p>Constructs a new Span.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region" title="dasi.utils.region.Region"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Region</span></code></a>(start, end, length[, cyclic, index, …])</p></td>
<td><p>Constructs a new Span.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Span</span></code></a>(a, b, l[, cyclic, index, ignore_wrap, …])</p></td>
<td><p><cite>Span</cite> maps the provided positions onto a context</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Exceptions</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.SpanError" title="dasi.utils.region.SpanError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpanError</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="dasi.utils.region.EmptySpan">
<em class="property">class </em><code class="sig-prename descclassname">dasi.utils.region.</code><code class="sig-name descname">EmptySpan</code><span class="sig-paren">(</span><em class="sig-param">a: int</em>, <em class="sig-param">b: int</em>, <em class="sig-param">l: int</em>, <em class="sig-param">cyclic=False</em>, <em class="sig-param">index=0</em>, <em class="sig-param">ignore_wrap=False</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">abs_wrap=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dasi/utils/region.html#EmptySpan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.EmptySpan" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">dasi.utils.region.Span</span></code></a></p>
<p>Constructs a new Span. There are several options to customize the initialization procedure.</p>
<p><strong>strict=True</strong></p>
<p>When strict, any index outside the valid bounds of the context raises an IndexError.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Span(1, 10, 10, cyclic=True, strict=True) # no raise
Span(1, 11, 10, cyclic=True, strict=True) # raises IndexError
Span(0, 11, 10, index=1, cyclic=True, strict=True) # raises IndexError
</pre></div>
</div>
<p><strong>ignore_wrap=True</strong></p>
<p>When wrapping is ignored, indices are simply mapped to the context with no consideration
of the number of times the absolute position would wrap around the context.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># all of the following are equivalent with ignore_wrap == True
Span(1, 10, 10, cyclic=True, ignore_wrap=True)
Span(1+10, 10, 10, cyclic=True, ignore_wrap=True)
Span(1, 10-100, 10, cyclic=True, ignore_wrap=True)
Span(1+20, 10-100, 10, cyclic=True, ignore_wrap=True)
</pre></div>
</div>
<p><strong>abs_wrap=True</strong></p>
<p>When absolute wrapping is used, the absolute difference between starting and ending index wrappings
is calculated, the starting index is to the context while the ending index is adjusted such
that the length will reflect the abs difference between starting and ending index wrappings.
This can be unintuitive
is best shown with the following example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># all of the following initializations result in equivalent spans

# starts at 1, wraps around one full time, ends at 5.
# Length is 15 - 1
s1 = Span(1, 15, 10, cyclic=True, abs_wrap=True)
assert len(s1) == 14

# starts at 11, wraps around one full time, ends at 15.
# Then positions are mapped back to context at 1 and 5.
# Length is still 25 - 11 == 14
s2 = Span(11, 25, 10, cyclic=True, abs_wrap=True)
assert len(s2) == 14

# starts at 11, wraps around one full time, ends at 15.
# Then positions are mapped back to context at 1 and 5.
# Length is now 11 + 5 = 14
s3 = Span(11, 5, 10, cyclic=True, abs_wrap=True)
assert len(s3) == 14

# the lengths change with the abs diff in number of times wrapped
_s = Span(21, 5, 10, cyclic=True, abs_wrap=True)
assert len(_s) == 24

_s = Span(21, 15, 10, cyclic=True, abs_wrap=True)
assert len(_s) == 14

# all
assert s1 == s2
assert s2 == s3
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>int</em>) – start of the span (inclusive)</p></li>
<li><p><strong>b</strong> (<em>int</em>) – end of the span (exclusive)</p></li>
<li><p><strong>l</strong> (<em>int</em>) – context length of the region</p></li>
<li><p><strong>cyclic</strong> (<em>bool</em>) – whether the underlying context is cyclic</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the starting index of the region</p></li>
<li><p><strong>strict</strong> (<em>bool</em>) – if True, positions outside of context bounds are disallowed.</p></li>
<li><p><strong>ignore_wrap</strong> (<em>bool</em>) – if True (default False), initialization indicies that wrap around multiple times will
simply be mapped directly to the context (no wrapping used).</p></li>
<li><p><strong>abs_wrap</strong> – if True, the abs difference between start and end wrappings are used. Starting wraps that
are greater than ending wraps are valid. If False and the starting wrap is greater than
the ending wrap, an IndexError is thrown.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="dasi.utils.region.EmptySpan.a">
<em class="property">property </em><code class="sig-name descname">a</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.a" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inclusive mapped startpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.b">
<em class="property">property </em><code class="sig-name descname">b</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.bounds">
<code class="sig-name descname">bounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; tuple<a class="headerlink" href="#dasi.utils.region.EmptySpan.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the context bounds (end exclusive)</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.c">
<em class="property">property </em><code class="sig-name descname">c</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.c" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive un-mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.connecting_span">
<code class="sig-name descname">connecting_span</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; Optional[dasi.utils.region.Span]<a class="headerlink" href="#dasi.utils.region.EmptySpan.connecting_span" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span that connects the two spans. Returns None</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.consecutive">
<code class="sig-name descname">consecutive</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#dasi.utils.region.EmptySpan.consecutive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span is immediately consecutive with this span.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.context_length">
<em class="property">property </em><code class="sig-name descname">context_length</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.context_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.cyclic">
<em class="property">property </em><code class="sig-name descname">cyclic</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the context is cyclic/circular.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.differences">
<code class="sig-name descname">differences</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; Union[Tuple[dasi.utils.region.Span], Tuple[dasi.utils.region.Span, dasi.utils.region.Span]]<a class="headerlink" href="#dasi.utils.region.EmptySpan.differences" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of differences between this span and the other span.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.force_context">
<code class="sig-name descname">force_context</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#dasi.utils.region.EmptySpan.force_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise error if another Span has different context.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – The other span</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p>SpanError</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.i">
<code class="sig-name descname">i</code><span class="sig-paren">(</span><em class="sig-param">p: int</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#dasi.utils.region.EmptySpan.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Find index of position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the starting index of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.intersection">
<code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; dasi.utils.region.Span<a class="headerlink" href="#dasi.utils.region.EmptySpan.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span inersection between this span and the other span.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.invert">
<code class="sig-name descname">invert</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Union[Tuple[dasi.utils.region.Span, dasi.utils.region.Span], Tuple[dasi.utils.region.Span, None]]<a class="headerlink" href="#dasi.utils.region.EmptySpan.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the region, returning a tuple of the remaining spans from the context.
If cyclic, a tuple (span, None) tuple is returned. If linear, a (span, span) is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>inverted regions</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.new">
<code class="sig-name descname">new</code><span class="sig-paren">(</span><em class="sig-param">a: Optional[int], b: Optional[int], ignore_wrap=None, index=None, strict=None, abs_wrap=None</em><span class="sig-paren">)</span> &#x2192; dasi.utils.region.Span<a class="headerlink" href="#dasi.utils.region.EmptySpan.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new span using the same context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.overlaps_with">
<code class="sig-name descname">overlaps_with</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#dasi.utils.region.EmptySpan.overlaps_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span has an overlap with this span.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – The other span</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the two spans overlap.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.ranges">
<code class="sig-name descname">ranges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dasi/utils/region.html#EmptySpan.ranges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.EmptySpan.ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return ranges of valid positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.reindex">
<code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param">i</em>, <em class="sig-param">strict=None</em>, <em class="sig-param">ignore_wrap=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new span with positions reindexed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – new index</p></li>
<li><p><strong>strict</strong> – initialize with ‘strict’</p></li>
<li><p><strong>ignore_wrap</strong> – whether to ignore wrapping indices</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.same_context">
<code class="sig-name descname">same_context</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#dasi.utils.region.EmptySpan.same_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if another Span as an equivalent context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.slices">
<code class="sig-name descname">slices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of slices</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param">a: int</em>, <em class="sig-param">b: int</em><span class="sig-paren">)</span> &#x2192; dasi.utils.region.Span<a class="headerlink" href="#dasi.utils.region.EmptySpan.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sub region starting from a to b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – starting pos</p></li>
<li><p><strong>b</strong> – ending pos</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new Span.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.t">
<code class="sig-name descname">t</code><span class="sig-paren">(</span><em class="sig-param">p: int</em>, <em class="sig-param">throw_error=True</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#dasi.utils.region.EmptySpan.t" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates a position ‘p’ to an index within the context bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – </p></li>
<li><p><strong>throw_error</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dasi.utils.region.Region">
<em class="property">class </em><code class="sig-prename descclassname">dasi.utils.region.</code><code class="sig-name descname">Region</code><span class="sig-paren">(</span><em class="sig-param">start</em>, <em class="sig-param">end</em>, <em class="sig-param">length</em>, <em class="sig-param">cyclic=False</em>, <em class="sig-param">index=0</em>, <em class="sig-param">direction=1</em>, <em class="sig-param">name=None</em>, <em class="sig-param">region_id=None</em>, <em class="sig-param">ignore_wrap=False</em>, <em class="sig-param">abs_wrap=True</em>, <em class="sig-param">strict=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dasi/utils/region.html#Region"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Region" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">dasi.utils.region.Span</span></code></a></p>
<p>Constructs a new Span. There are several options to customize the initialization procedure.</p>
<p><strong>strict=True</strong></p>
<p>When strict, any index outside the valid bounds of the context raises an IndexError.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Span(1, 10, 10, cyclic=True, strict=True) # no raise
Span(1, 11, 10, cyclic=True, strict=True) # raises IndexError
Span(0, 11, 10, index=1, cyclic=True, strict=True) # raises IndexError
</pre></div>
</div>
<p><strong>ignore_wrap=True</strong></p>
<p>When wrapping is ignored, indices are simply mapped to the context with no consideration
of the number of times the absolute position would wrap around the context.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># all of the following are equivalent with ignore_wrap == True
Span(1, 10, 10, cyclic=True, ignore_wrap=True)
Span(1+10, 10, 10, cyclic=True, ignore_wrap=True)
Span(1, 10-100, 10, cyclic=True, ignore_wrap=True)
Span(1+20, 10-100, 10, cyclic=True, ignore_wrap=True)
</pre></div>
</div>
<p><strong>abs_wrap=True</strong></p>
<p>When absolute wrapping is used, the absolute difference between starting and ending index wrappings
is calculated, the starting index is to the context while the ending index is adjusted such
that the length will reflect the abs difference between starting and ending index wrappings.
This can be unintuitive
is best shown with the following example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># all of the following initializations result in equivalent spans

# starts at 1, wraps around one full time, ends at 5.
# Length is 15 - 1
s1 = Span(1, 15, 10, cyclic=True, abs_wrap=True)
assert len(s1) == 14

# starts at 11, wraps around one full time, ends at 15.
# Then positions are mapped back to context at 1 and 5.
# Length is still 25 - 11 == 14
s2 = Span(11, 25, 10, cyclic=True, abs_wrap=True)
assert len(s2) == 14

# starts at 11, wraps around one full time, ends at 15.
# Then positions are mapped back to context at 1 and 5.
# Length is now 11 + 5 = 14
s3 = Span(11, 5, 10, cyclic=True, abs_wrap=True)
assert len(s3) == 14

# the lengths change with the abs diff in number of times wrapped
_s = Span(21, 5, 10, cyclic=True, abs_wrap=True)
assert len(_s) == 24

_s = Span(21, 15, 10, cyclic=True, abs_wrap=True)
assert len(_s) == 14

# all
assert s1 == s2
assert s2 == s3
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>int</em>) – start of the span (inclusive)</p></li>
<li><p><strong>b</strong> (<em>int</em>) – end of the span (exclusive)</p></li>
<li><p><strong>l</strong> (<em>int</em>) – context length of the region</p></li>
<li><p><strong>cyclic</strong> (<em>bool</em>) – whether the underlying context is cyclic</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the starting index of the region</p></li>
<li><p><strong>strict</strong> (<em>bool</em>) – if True, positions outside of context bounds are disallowed.</p></li>
<li><p><strong>ignore_wrap</strong> (<em>bool</em>) – if True (default False), initialization indicies that wrap around multiple times will
simply be mapped directly to the context (no wrapping used).</p></li>
<li><p><strong>abs_wrap</strong> – if True, the abs difference between start and end wrappings are used. Starting wraps that
are greater than ending wraps are valid. If False and the starting wrap is greater than
the ending wrap, an IndexError is thrown.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="dasi.utils.region.Region.a">
<em class="property">property </em><code class="sig-name descname">a</code><a class="headerlink" href="#dasi.utils.region.Region.a" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inclusive mapped startpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.b">
<em class="property">property </em><code class="sig-name descname">b</code><a class="headerlink" href="#dasi.utils.region.Region.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.bounds">
<code class="sig-name descname">bounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; tuple<a class="headerlink" href="#dasi.utils.region.Region.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the context bounds (end exclusive)</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.c">
<em class="property">property </em><code class="sig-name descname">c</code><a class="headerlink" href="#dasi.utils.region.Region.c" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive un-mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.connecting_span">
<code class="sig-name descname">connecting_span</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; Optional[dasi.utils.region.Span]<a class="headerlink" href="#dasi.utils.region.Region.connecting_span" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span that connects the two spans. Returns None</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.consecutive">
<code class="sig-name descname">consecutive</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#dasi.utils.region.Region.consecutive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span is immediately consecutive with this span.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.context_length">
<em class="property">property </em><code class="sig-name descname">context_length</code><a class="headerlink" href="#dasi.utils.region.Region.context_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.cyclic">
<em class="property">property </em><code class="sig-name descname">cyclic</code><a class="headerlink" href="#dasi.utils.region.Region.cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the context is cyclic/circular.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.differences">
<code class="sig-name descname">differences</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; Union[Tuple[dasi.utils.region.Span], Tuple[dasi.utils.region.Span, dasi.utils.region.Span]]<a class="headerlink" href="#dasi.utils.region.Region.differences" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of differences between this span and the other span.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.force_context">
<code class="sig-name descname">force_context</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#dasi.utils.region.Region.force_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise error if another Span has different context.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – The other span</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p>SpanError</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.i">
<code class="sig-name descname">i</code><span class="sig-paren">(</span><em class="sig-param">p: int</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#dasi.utils.region.Region.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Find index of position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#dasi.utils.region.Region.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the starting index of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.intersection">
<code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; dasi.utils.region.Span<a class="headerlink" href="#dasi.utils.region.Region.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span inersection between this span and the other span.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.invert">
<code class="sig-name descname">invert</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Union[Tuple[dasi.utils.region.Span, dasi.utils.region.Span], Tuple[dasi.utils.region.Span, None]]<a class="headerlink" href="#dasi.utils.region.Region.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the region, returning a tuple of the remaining spans from the context.
If cyclic, a tuple (span, None) tuple is returned. If linear, a (span, span) is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>inverted regions</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.new">
<code class="sig-name descname">new</code><span class="sig-paren">(</span><em class="sig-param">a: Optional[int], b: Optional[int], ignore_wrap=None, index=None, strict=None, abs_wrap=None</em><span class="sig-paren">)</span> &#x2192; dasi.utils.region.Span<a class="headerlink" href="#dasi.utils.region.Region.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new span using the same context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.overlaps_with">
<code class="sig-name descname">overlaps_with</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#dasi.utils.region.Region.overlaps_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span has an overlap with this span.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – The other span</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the two spans overlap.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.ranges">
<code class="sig-name descname">ranges</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[Tuple[int, int]]<a class="headerlink" href="#dasi.utils.region.Region.ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return ranges of valid positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.reindex">
<code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param">i</em>, <em class="sig-param">strict=None</em>, <em class="sig-param">ignore_wrap=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new span with positions reindexed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – new index</p></li>
<li><p><strong>strict</strong> – initialize with ‘strict’</p></li>
<li><p><strong>ignore_wrap</strong> – whether to ignore wrapping indices</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.same_context">
<code class="sig-name descname">same_context</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#dasi.utils.region.Region.same_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if another Span as an equivalent context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.slices">
<code class="sig-name descname">slices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of slices</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param">a: int</em>, <em class="sig-param">b: int</em><span class="sig-paren">)</span> &#x2192; dasi.utils.region.Span<a class="headerlink" href="#dasi.utils.region.Region.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sub region starting from a to b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – starting pos</p></li>
<li><p><strong>b</strong> – ending pos</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new Span.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.t">
<code class="sig-name descname">t</code><span class="sig-paren">(</span><em class="sig-param">p: int</em>, <em class="sig-param">throw_error=True</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#dasi.utils.region.Region.t" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates a position ‘p’ to an index within the context bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – </p></li>
<li><p><strong>throw_error</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dasi.utils.region.Span">
<em class="property">class </em><code class="sig-prename descclassname">dasi.utils.region.</code><code class="sig-name descname">Span</code><span class="sig-paren">(</span><em class="sig-param">a: int</em>, <em class="sig-param">b: int</em>, <em class="sig-param">l: int</em>, <em class="sig-param">cyclic=False</em>, <em class="sig-param">index=0</em>, <em class="sig-param">ignore_wrap=False</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">abs_wrap=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></p>
<p><cite>Span</cite> maps the provided positions onto a context</p>
<p>Spans have no direction and have an underlying context
that has a certain length, can be linear or cyclic, and has a starting index.</p>
<p>The following attributes are accessible:</p>
<ul class="simple">
<li><p><cite>a</cite> - the starting (inclusive) position of the span</p></li>
<li><p><cite>b</cite> - the mapped exclusive position of the span</p></li>
<li><p><cite>c</cite> - the unmapped exclusive position of the span (used for cyclic spans that wrap context multiple times)</p></li>
<li><p><cite>cyclic</cite> - whether the underlying context is circular or linear</p></li>
<li><p><cite>index</cite> - the first index of the context</p></li>
<li><p><cite>context_length</cite> - the length of the underlying context.</p></li>
</ul>
<p><strong>Linear spans</strong>
For example, a basic linear span can be represented using the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(0, 10, 20)
assert s.a == 0
assert s.b == 10
assert list(s) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  # spans are always exclusive at endpoint.
</pre></div>
</div>
<p><strong>Indexing and Slicing</strong></p>
<p>New indexes can be provided to spans.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(1, 10, 10, index=1)
assert s.a == 1
assert s.b == 10
</pre></div>
</div>
<p>Positions can be mapped to the span:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(5, 8, 10, index=5)
assert s.a == 5
assert s.b == 8
assert s[0] == 5  # the &#39;first&#39; position in the span equivalent to the starting index
assert s[-1] == 7  # the &#39;last&#39; position in the span is the last inclusive index
</pre></div>
</div>
<p>Positions can be mapped automatically during initialization:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(-1, 5, 10, cyclic=True, index=0)  # index &#39;-1&#39; is mapped onto last available index on the context,
&#39;9&#39;
assert s.a == 9
assert s.b == 5

s = Span(6, -1, 10, cyclic=True, index=0)  # index &#39;-1&#39; is mapped onto last available exclusive index on the
 context, &#39;10&#39;
assert s.a == 6
assert s.b == 10
</pre></div>
</div>
<p>Inclusive positions can be mapped onto the context using <cite>t</cite>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(-1, 5, 10, cyclic=True)
assert s.t(11) == 1
assert s.t(10) == 0
</pre></div>
</div>
<p><strong>Reindexing</strong></p>
<p>Context starting index can be remapped:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(0, 5, 10)
s1 = s.reindex(1)
asset s1.a == 1
assert s2.b == 6
</pre></div>
</div>
<p><strong>Slicing</strong></p>
<p>Spans can be sliced similarly to lists:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(4, 8, 10)
s1 = s[1:]
assert s1.a == 5
assert s2.b == 8

s2 = s[:-1]
assert s2.a == 4
assert s2.b == 7

s3 = s[2:-1]
assert s3.a == 5
assert s3.b == 7
</pre></div>
</div>
<p><strong>Cyclic spans</strong>
A cyclic span can be represented in the following way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(18, 2, 20, cyclic=True)
assert s.a == 18
assert s.b == 2
assert list(s) == [18, 19, 0, 1]
assert len(s) == 4
</pre></div>
</div>
<p><strong>Wrapping cyclic spans</strong>
Spans the wrap around the context multiple times can be represented as well. The mapped endpoint
is found with <cite>span.b</cite> and the non-mapped endpoint is found using <cite>span.c</cite>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(9, 21, 10, cyclic=True)
assert list(s) == [9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
assert len(s) == 12
assert s.a == 9  # start point
assert s.b == 1  # mapped endpoint
assert s.c == 21 # the unmapped endpoint
</pre></div>
</div>
<p>The indices are reduced to their lowest ‘wrapping’ whenever possible. For example, the following
initializations are equivalent:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s1 = Span(1, 5, 10, cyclic=True)
s2 = Span(11, 15, 10, cyclic=True)
s3 = Span(21, 25, 10, cyclic=True)
assert s1 == s2
assert s2 == s3
</pre></div>
</div>
<p><strong>Iterating through spans</strong></p>
<p>Spans can be treated like iterators:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for i in Span(5, 3, 10, cyclic=True):
    print(i)
</pre></div>
</div>
<p><strong>Span inversion</strong></p>
<p>Inversion returns two spans that represent everything <em>except</em> the span:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(4, 8, 10)
s1, s2 = s.invert()  # also s[::-1]
assert s1.a == 0
assert s1.b == 4
assert s2.a == 8
assert s2.b == 10

# inverted cyclic span returns one valid span and None
s = Span(4, 8, 10, cyclic=True)
s1, s2 = s.invert()
assert s1.a == 8
assert s1.b == 4
assert s2 is None
</pre></div>
</div>
<p><strong>Intersections, differences</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s1 = Span(4, 10, 20)
s2 = Span(8, 12, 20)
s3 = s1.intersection(s2)
assert s3.a == 8
assert s3.b == 10
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s1 = Span(4, 10, 20)
s2 = Span(8, 12, 20)
s3, s4 = s1.differences(s2)

assert s3.a, s3.b == 4, 8
assert s4,a, s4.b == 10, 12
</pre></div>
</div>
<p>Constructs a new Span. There are several options to customize the initialization procedure.</p>
<p><strong>strict=True</strong></p>
<p>When strict, any index outside the valid bounds of the context raises an IndexError.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Span(1, 10, 10, cyclic=True, strict=True) # no raise
Span(1, 11, 10, cyclic=True, strict=True) # raises IndexError
Span(0, 11, 10, index=1, cyclic=True, strict=True) # raises IndexError
</pre></div>
</div>
<p><strong>ignore_wrap=True</strong></p>
<p>When wrapping is ignored, indices are simply mapped to the context with no consideration
of the number of times the absolute position would wrap around the context.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># all of the following are equivalent with ignore_wrap == True
Span(1, 10, 10, cyclic=True, ignore_wrap=True)
Span(1+10, 10, 10, cyclic=True, ignore_wrap=True)
Span(1, 10-100, 10, cyclic=True, ignore_wrap=True)
Span(1+20, 10-100, 10, cyclic=True, ignore_wrap=True)
</pre></div>
</div>
<p><strong>abs_wrap=True</strong></p>
<p>When absolute wrapping is used, the absolute difference between starting and ending index wrappings
is calculated, the starting index is to the context while the ending index is adjusted such
that the length will reflect the abs difference between starting and ending index wrappings.
This can be unintuitive
is best shown with the following example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># all of the following initializations result in equivalent spans

# starts at 1, wraps around one full time, ends at 5.
# Length is 15 - 1
s1 = Span(1, 15, 10, cyclic=True, abs_wrap=True)
assert len(s1) == 14

# starts at 11, wraps around one full time, ends at 15.
# Then positions are mapped back to context at 1 and 5.
# Length is still 25 - 11 == 14
s2 = Span(11, 25, 10, cyclic=True, abs_wrap=True)
assert len(s2) == 14

# starts at 11, wraps around one full time, ends at 15.
# Then positions are mapped back to context at 1 and 5.
# Length is now 11 + 5 = 14
s3 = Span(11, 5, 10, cyclic=True, abs_wrap=True)
assert len(s3) == 14

# the lengths change with the abs diff in number of times wrapped
_s = Span(21, 5, 10, cyclic=True, abs_wrap=True)
assert len(_s) == 24

_s = Span(21, 15, 10, cyclic=True, abs_wrap=True)
assert len(_s) == 14

# all
assert s1 == s2
assert s2 == s3
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>int</em>) – start of the span (inclusive)</p></li>
<li><p><strong>b</strong> (<em>int</em>) – end of the span (exclusive)</p></li>
<li><p><strong>l</strong> (<em>int</em>) – context length of the region</p></li>
<li><p><strong>cyclic</strong> (<em>bool</em>) – whether the underlying context is cyclic</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the starting index of the region</p></li>
<li><p><strong>strict</strong> (<em>bool</em>) – if True, positions outside of context bounds are disallowed.</p></li>
<li><p><strong>ignore_wrap</strong> (<em>bool</em>) – if True (default False), initialization indicies that wrap around multiple times will
simply be mapped directly to the context (no wrapping used).</p></li>
<li><p><strong>abs_wrap</strong> – if True, the abs difference between start and end wrappings are used. Starting wraps that
are greater than ending wraps are valid. If False and the starting wrap is greater than
the ending wrap, an IndexError is thrown.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="dasi.utils.region.Span.a">
<em class="property">property </em><code class="sig-name descname">a</code><a class="headerlink" href="#dasi.utils.region.Span.a" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inclusive mapped startpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.b">
<em class="property">property </em><code class="sig-name descname">b</code><a class="headerlink" href="#dasi.utils.region.Span.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.bounds">
<code class="sig-name descname">bounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; tuple<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the context bounds (end exclusive)</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.c">
<em class="property">property </em><code class="sig-name descname">c</code><a class="headerlink" href="#dasi.utils.region.Span.c" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive un-mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.connecting_span">
<code class="sig-name descname">connecting_span</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; Optional[dasi.utils.region.Span]<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.connecting_span"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.connecting_span" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span that connects the two spans. Returns None</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.consecutive">
<code class="sig-name descname">consecutive</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.consecutive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.consecutive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span is immediately consecutive with this span.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.context_length">
<em class="property">property </em><code class="sig-name descname">context_length</code><a class="headerlink" href="#dasi.utils.region.Span.context_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.cyclic">
<em class="property">property </em><code class="sig-name descname">cyclic</code><a class="headerlink" href="#dasi.utils.region.Span.cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the context is cyclic/circular.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.differences">
<code class="sig-name descname">differences</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; Union[Tuple[dasi.utils.region.Span], Tuple[dasi.utils.region.Span, dasi.utils.region.Span]]<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.differences"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.differences" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of differences between this span and the other span.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.force_context">
<code class="sig-name descname">force_context</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.force_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.force_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise error if another Span has different context.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – The other span</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p>SpanError</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.i">
<code class="sig-name descname">i</code><span class="sig-paren">(</span><em class="sig-param">p: int</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.i"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Find index of position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#dasi.utils.region.Span.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the starting index of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.intersection">
<code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; dasi.utils.region.Span<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.intersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span inersection between this span and the other span.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.invert">
<code class="sig-name descname">invert</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Union[Tuple[dasi.utils.region.Span, dasi.utils.region.Span], Tuple[dasi.utils.region.Span, None]]<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.invert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the region, returning a tuple of the remaining spans from the context.
If cyclic, a tuple (span, None) tuple is returned. If linear, a (span, span) is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>inverted regions</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.new">
<code class="sig-name descname">new</code><span class="sig-paren">(</span><em class="sig-param">a: Optional[int], b: Optional[int], ignore_wrap=None, index=None, strict=None, abs_wrap=None</em><span class="sig-paren">)</span> &#x2192; dasi.utils.region.Span<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.new"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new span using the same context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.overlaps_with">
<code class="sig-name descname">overlaps_with</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.overlaps_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.overlaps_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span has an overlap with this span.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – The other span</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the two spans overlap.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.ranges">
<code class="sig-name descname">ranges</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[Tuple[int, int]]<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.ranges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return ranges of valid positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.reindex">
<code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param">i</em>, <em class="sig-param">strict=None</em>, <em class="sig-param">ignore_wrap=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.reindex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new span with positions reindexed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – new index</p></li>
<li><p><strong>strict</strong> – initialize with ‘strict’</p></li>
<li><p><strong>ignore_wrap</strong> – whether to ignore wrapping indices</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.same_context">
<code class="sig-name descname">same_context</code><span class="sig-paren">(</span><em class="sig-param">other: dasi.utils.region.Span</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.same_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.same_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if another Span as an equivalent context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.slices">
<code class="sig-name descname">slices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.slices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of slices</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param">a: int</em>, <em class="sig-param">b: int</em><span class="sig-paren">)</span> &#x2192; dasi.utils.region.Span<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.sub"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sub region starting from a to b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – starting pos</p></li>
<li><p><strong>b</strong> – ending pos</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new Span.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.t">
<code class="sig-name descname">t</code><span class="sig-paren">(</span><em class="sig-param">p: int</em>, <em class="sig-param">throw_error=True</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="../../../_modules/dasi/utils/region.html#Span.t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.t" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates a position ‘p’ to an index within the context bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – </p></li>
<li><p><strong>throw_error</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="dasi.utils.region.SpanError">
<em class="property">exception </em><code class="sig-prename descclassname">dasi.utils.region.</code><code class="sig-name descname">SpanError</code><a class="reference internal" href="../../../_modules/dasi/utils/region.html#SpanError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.SpanError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<dl class="method">
<dt id="dasi.utils.region.SpanError.with_traceback">
<code class="sig-name descname">with_traceback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.SpanError.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>