<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dasi.utils.region &#8212; dasi 0.0.4 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/style.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="dasi.utils.sequence_design" href="dasi.utils.sequence_design.html" />
    <link rel="prev" title="dasi.utils.npdf" href="dasi.utils.npdf.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>



  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          DASi</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.4</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">DASi <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../design.html">Design (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.design</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../models.html">Models (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.models</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="dasi.models.Assembly.html">dasi.models.Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="dasi.models.AssemblyNode.html">dasi.models.AssemblyNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="dasi.models.Molecule.html">dasi.models.Molecule</a></li>
<li class="toctree-l2"><a class="reference internal" href="dasi.models.MoleculeType.html">dasi.models.MoleculeType</a></li>
<li class="toctree-l2"><a class="reference internal" href="dasi.models.Reaction.html">dasi.models.Reaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="dasi.models.AlignmentGroup.html">dasi.models.AlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="dasi.models.AlignmentGroupBase.html">dasi.models.AlignmentGroupBase</a></li>
<li class="toctree-l2"><a class="reference internal" href="dasi.models.MultiPCRProductAlignmentGroup.html">dasi.models.MultiPCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="dasi.models.PCRProductAlignmentGroup.html">dasi.models.PCRProductAlignmentGroup</a></li>
<li class="toctree-l2"><a class="reference internal" href="dasi.models.AlignmentContainer.html">dasi.models.AlignmentContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="dasi.models.AlignmentContainerFactory.html">dasi.models.AlignmentContainerFactory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../models.html#modules">modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="dasi.models.alignment.html">dasi.models.alignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="dasi.models.alignment_container.html">dasi.models.alignment_container</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cost.html">Cost Model (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.cost</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../cost.html#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="dasi.cost.utils.html">dasi.cost.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../command_line.html">Command Line (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.command_line</span></code>)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../utils.html">Utilities (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.utils</span></code>)</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../utils.html#utility-modules">Utility modules</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="dasi.utils.npdf.html">dasi.utils.npdf</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">dasi.utils.region</a></li>
<li class="toctree-l3"><a class="reference internal" href="dasi.utils.sequence_design.html">dasi.utils.sequence_design</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../utils.html#networkx-utilities">Networkx utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="dasi.utils.networkx.exceptions.html">dasi.utils.networkx.exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="dasi.utils.networkx.shortest_path.html">dasi.utils.networkx.shortest_path</a></li>
<li class="toctree-l3"><a class="reference internal" href="dasi.utils.networkx.utils.html">dasi.utils.networkx.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../exceptions.html">Exceptions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.exceptions</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../constants.html">Constants (<code class="xref py py-mod docutils literal notranslate"><span class="pre">dasi.constants</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../schemas/schemas.html">User Parameter Inputs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../schemas/schemas.html#default-cost-parameters">Default Cost Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../schemas/schemas.html#cost-parameter-schema">Cost Parameter Schema</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../schemas/schemas.html#cost-parameters-schema">Cost Parameters Schema</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guidelines.html">Code Guidelines</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="dasi.utils.npdf.html" title="Previous Chapter: dasi.utils.npdf"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; dasi.utils.npdf</span>
    </a>
  </li>
  <li>
    <a href="dasi.utils.sequence_design.html" title="Next Chapter: dasi.utils.sequence_design"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">dasi.utils.se... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/generated/dasi.utils.region.rst"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="module-dasi.utils.region">
<span id="dasi-utils-region"></span><h1>dasi.utils.region<a class="headerlink" href="#module-dasi.utils.region" title="Permalink to this headline">¶</a></h1>
<p class="rubric">Classes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Direction</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan" title="dasi.utils.region.EmptySpan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EmptySpan</span></code></a>(a, b, l[, cyclic, index, …])</p></td>
<td><p>Constructs a new Span.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region" title="dasi.utils.region.Region"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Region</span></code></a>(start, end, length[, cyclic, index, …])</p></td>
<td><p>A direction span.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Span</span></code></a>(a, b, l[, cyclic, index, ignore_wrap, …])</p></td>
<td><p><cite>Span</cite> maps the provided positions onto a context.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Exceptions</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.SpanError" title="dasi.utils.region.SpanError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpanError</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p><strong>Classes</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan" title="dasi.utils.region.EmptySpan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EmptySpan</span></code></a>(a, b, l[, cyclic, index, …])</p></td>
<td><p>Constructs a new Span.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region" title="dasi.utils.region.Region"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Region</span></code></a>(start, end, length[, cyclic, index, …])</p></td>
<td><p>A direction span.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Span</span></code></a>(a, b, l[, cyclic, index, ignore_wrap, …])</p></td>
<td><p><cite>Span</cite> maps the provided positions onto a context.</p></td>
</tr>
</tbody>
</table>
<p><strong>Exceptions</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.SpanError" title="dasi.utils.region.SpanError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpanError</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="dasi.utils.region.EmptySpan">
<em class="property">class </em><code class="sig-prename descclassname">dasi.utils.region.</code><code class="sig-name descname">EmptySpan</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">l</em>, <em class="sig-param">cyclic=False</em>, <em class="sig-param">index=0</em>, <em class="sig-param">ignore_wrap=False</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">abs_wrap=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#EmptySpan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.EmptySpan" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">dasi.utils.region.Span</span></code></a></p>
<p>Constructs a new Span. There are several options to customize the
initialization procedure.</p>
<p><strong>strict=True</strong></p>
<p>When strict, any index outside the valid bounds of the context raises an
IndexError.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Span(1, 10, 10, cyclic=True, strict=True) # no raise
Span(1, 11, 10, cyclic=True, strict=True) # raises IndexError
Span(0, 11, 10, index=1, cyclic=True, strict=True) # raises IndexError
</pre></div>
</div>
<p><strong>Attributes</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.a" title="dasi.utils.region.EmptySpan.a"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a</span></code></a></p></td>
<td><p>Return the inclusive mapped startpoint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.b" title="dasi.utils.region.EmptySpan.b"><code class="xref py py-obj docutils literal notranslate"><span class="pre">b</span></code></a></p></td>
<td><p>Return the exclusive mapped endpoint.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.c" title="dasi.utils.region.EmptySpan.c"><code class="xref py py-obj docutils literal notranslate"><span class="pre">c</span></code></a></p></td>
<td><p>Return the exclusive un-mapped endpoint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.context_length" title="dasi.utils.region.EmptySpan.context_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">context_length</span></code></a></p></td>
<td><p>Return the length of the context.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.cyclic" title="dasi.utils.region.EmptySpan.cyclic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cyclic</span></code></a></p></td>
<td><p>Return whether the context is cyclic/circular.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.index" title="dasi.utils.region.EmptySpan.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></p></td>
<td><p>Return the starting index of the context.</p></td>
</tr>
</tbody>
</table>
<p><strong>Methods</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.bounds" title="dasi.utils.region.EmptySpan.bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></a>()</p></td>
<td><p>Return the context bounds (end exclusive)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.connecting_span" title="dasi.utils.region.EmptySpan.connecting_span"><code class="xref py py-obj docutils literal notranslate"><span class="pre">connecting_span</span></code></a>(other)</p></td>
<td><p>Return the span that connects the two spans.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.consecutive" title="dasi.utils.region.EmptySpan.consecutive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">consecutive</span></code></a>(other)</p></td>
<td><p>Returns True if other span is immediately consecutive with this span.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.differences" title="dasi.utils.region.EmptySpan.differences"><code class="xref py py-obj docutils literal notranslate"><span class="pre">differences</span></code></a>(other)</p></td>
<td><p>Return a tuple of differences between this span and the other span.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.force_context" title="dasi.utils.region.EmptySpan.force_context"><code class="xref py py-obj docutils literal notranslate"><span class="pre">force_context</span></code></a>(other)</p></td>
<td><p>Raise error if another Span has different context.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.get_slice" title="dasi.utils.region.EmptySpan.get_slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_slice</span></code></a>(x[, infer_type, as_type, …])</p></td>
<td><p>Use the region to slice the iterable, returning a iterable of the same type as ‘x’.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.get_slice_iter" title="dasi.utils.region.EmptySpan.get_slice_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_slice_iter</span></code></a>(x)</p></td>
<td><p>Use the region to slice the iterable, returning another generator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.i" title="dasi.utils.region.EmptySpan.i"><code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code></a>(p)</p></td>
<td><p>Find index of position.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.intersection" title="dasi.utils.region.EmptySpan.intersection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code></a>(other)</p></td>
<td><p>Return the span inersection between this span and the other span.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.invert" title="dasi.utils.region.EmptySpan.invert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code></a>()</p></td>
<td><p>Invert the region, returning a tuple of the remaining spans from the context.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.new" title="dasi.utils.region.EmptySpan.new"><code class="xref py py-obj docutils literal notranslate"><span class="pre">new</span></code></a>(a, b[, ignore_wrap, index, strict, abs_wrap])</p></td>
<td><p>Create a new span using the same context.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.overlaps_with" title="dasi.utils.region.EmptySpan.overlaps_with"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlaps_with</span></code></a>(other)</p></td>
<td><p>Returns True if other span has an overlap with this span.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.ranges" title="dasi.utils.region.EmptySpan.ranges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ranges</span></code></a>(*args)</p></td>
<td><p>Return the valid ranges for this span.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.reindex" title="dasi.utils.region.EmptySpan.reindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex</span></code></a>(i[, strict, ignore_wrap])</p></td>
<td><p>Return a new span with positions reindexed.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.same_context" title="dasi.utils.region.EmptySpan.same_context"><code class="xref py py-obj docutils literal notranslate"><span class="pre">same_context</span></code></a>(other)</p></td>
<td><p>Return if another Span as an equivalent context.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.slices" title="dasi.utils.region.EmptySpan.slices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slices</span></code></a>()</p></td>
<td><p>Return list of slices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.sub" title="dasi.utils.region.EmptySpan.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>(a, b)</p></td>
<td><p>Create a sub region starting from a to b.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.EmptySpan.t" title="dasi.utils.region.EmptySpan.t"><code class="xref py py-obj docutils literal notranslate"><span class="pre">t</span></code></a>(p[, throw_error])</p></td>
<td><p>Translates a position ‘p’ to an index within the context bounds.</p></td>
</tr>
</tbody>
</table>
<p><strong>ignore_wrap=True</strong></p>
<p>When wrapping is ignored, indices are simply mapped to the context with no
consideration
of the number of times the absolute position would wrap around the context.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># all of the following are equivalent with ignore_wrap == True
Span(1, 10, 10, cyclic=True, ignore_wrap=True)
Span(1+10, 10, 10, cyclic=True, ignore_wrap=True)
Span(1, 10-100, 10, cyclic=True, ignore_wrap=True)
Span(1+20, 10-100, 10, cyclic=True, ignore_wrap=True)
</pre></div>
</div>
<p><strong>abs_wrap=True</strong></p>
<p>When absolute wrapping is used, the absolute difference between starting and
ending index wrappings
is calculated, the starting index is to the context while the ending index is
adjusted such
that the length will reflect the abs difference between starting and ending
index wrappings.
This can be unintuitive
is best shown with the following example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># all of the following initializations result in equivalent spans

# starts at 1, wraps around one full time, ends at 5.
# Length is 15 - 1
s1 = Span(1, 15, 10, cyclic=True, abs_wrap=True)
assert len(s1) == 14

# starts at 11, wraps around one full time, ends at 15.
# Then positions are mapped back to context at 1 and 5.
# Length is still 25 - 11 == 14
s2 = Span(11, 25, 10, cyclic=True, abs_wrap=True)
assert len(s2) == 14

# starts at 11, wraps around one full time, ends at 15.
# Then positions are mapped back to context at 1 and 5.
# Length is now 11 + 5 = 14
s3 = Span(11, 5, 10, cyclic=True, abs_wrap=True)
assert len(s3) == 14

# the lengths change with the abs diff in number of times wrapped
_s = Span(21, 5, 10, cyclic=True, abs_wrap=True)
assert len(_s) == 24

_s = Span(21, 15, 10, cyclic=True, abs_wrap=True)
assert len(_s) == 14

# all
assert s1 == s2
assert s2 == s3
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>int</em>) – start of the span (inclusive)</p></li>
<li><p><strong>b</strong> (<em>int</em>) – end of the span (exclusive)</p></li>
<li><p><strong>l</strong> (<em>int</em>) – context length of the region</p></li>
<li><p><strong>cyclic</strong> (<em>bool</em>) – whether the underlying context is cyclic</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the starting index of the region</p></li>
<li><p><strong>strict</strong> (<em>bool</em>) – if True, positions outside of context bounds are disallowed.</p></li>
<li><p><strong>ignore_wrap</strong> (<em>bool</em>) – if True (default False), initialization indicies that wrap
around multiple times will
simply be mapped directly to the context (no wrapping used).</p></li>
<li><p><strong>abs_wrap</strong> – if True, the abs difference between start and end wrappings
are used. Starting wraps that are greater than ending wraps
are valid. If False and the starting wrap is greater than
the ending wrap, an IndexError is thrown.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="dasi.utils.region.EmptySpan.a">
<em class="property">property </em><code class="sig-name descname">a</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.a" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inclusive mapped startpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.b">
<em class="property">property </em><code class="sig-name descname">b</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.bounds">
<code class="sig-name descname">bounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the context bounds (end exclusive)</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.c">
<em class="property">property </em><code class="sig-name descname">c</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.c" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive un-mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.connecting_span">
<code class="sig-name descname">connecting_span</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.connecting_span" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span that connects the two spans. Returns None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.consecutive">
<code class="sig-name descname">consecutive</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.consecutive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span is immediately consecutive with this
span.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.context_length">
<em class="property">property </em><code class="sig-name descname">context_length</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.context_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.cyclic">
<em class="property">property </em><code class="sig-name descname">cyclic</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the context is cyclic/circular.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.differences">
<code class="sig-name descname">differences</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.differences" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of differences between this span and the other
span.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>, <a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>]]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.force_context">
<code class="sig-name descname">force_context</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.force_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise error if another Span has different context.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>) – The other span</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>SpanError</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.get_slice">
<code class="sig-name descname">get_slice</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">infer_type=False</em>, <em class="sig-param">as_type=None</em>, <em class="sig-param">summary_func=None</em>, <em class="sig-param">reduce_op=&lt;built-in function add&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.get_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the region to slice the iterable, returning a iterable of the
same type as ‘x’. If as_type is provided, the iterable will be
typecast.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[~T]) – the iterable to slice</p></li>
<li><p><strong>as_type</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code>]) – type to convert the iterable into</p></li>
<li><p><strong>summary_func</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>]) – summary function that takes in an interable. If none, uses
<cite>itertools.reduce(operator.add, arr)</cite></p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.get_slice_iter">
<code class="sig-name descname">get_slice_iter</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.get_slice_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the region to slice the iterable, returning another generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[~T]) – the iterable to slice</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterable</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.i">
<code class="sig-name descname">i</code><span class="sig-paren">(</span><em class="sig-param">p</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Find index of position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#dasi.utils.region.EmptySpan.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the starting index of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.intersection">
<code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span inersection between this span and the other span.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.invert">
<code class="sig-name descname">invert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the region, returning a tuple of the remaining spans from the
context. If cyclic, a tuple (span, None) tuple is returned. If linear,
a (span, span) is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>inverted regions</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.new">
<code class="sig-name descname">new</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">ignore_wrap=None</em>, <em class="sig-param">index=None</em>, <em class="sig-param">strict=None</em>, <em class="sig-param">abs_wrap=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new span using the same context.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.overlaps_with">
<code class="sig-name descname">overlaps_with</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.overlaps_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span has an overlap with this span.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>) – The other span</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if the two spans overlap.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.ranges">
<code class="sig-name descname">ranges</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#EmptySpan.ranges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.EmptySpan.ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the valid ranges for this span.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ignore_wraps</strong> – if True, multiple wrappings will be ignored.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>List[Tuple[int, int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.reindex">
<code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param">i</em>, <em class="sig-param">strict=None</em>, <em class="sig-param">ignore_wrap=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new span with positions reindexed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – new index</p></li>
<li><p><strong>strict</strong> – initialize with ‘strict’</p></li>
<li><p><strong>ignore_wrap</strong> – whether to ignore wrapping indices</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.same_context">
<code class="sig-name descname">same_context</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.same_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if another Span as an equivalent context.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.slices">
<code class="sig-name descname">slices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sub region starting from a to b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – starting pos</p></li>
<li><p><strong>b</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – ending pos</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a new Span.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.EmptySpan.t">
<code class="sig-name descname">t</code><span class="sig-paren">(</span><em class="sig-param">p</em>, <em class="sig-param">throw_error=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.EmptySpan.t" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates a position ‘p’ to an index within the context bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – </p></li>
<li><p><strong>throw_error</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dasi.utils.region.Region">
<em class="property">class </em><code class="sig-prename descclassname">dasi.utils.region.</code><code class="sig-name descname">Region</code><span class="sig-paren">(</span><em class="sig-param">start</em>, <em class="sig-param">end</em>, <em class="sig-param">length</em>, <em class="sig-param">cyclic=False</em>, <em class="sig-param">index=0</em>, <em class="sig-param">direction=1</em>, <em class="sig-param">name=None</em>, <em class="sig-param">region_id=None</em>, <em class="sig-param">ignore_wrap=False</em>, <em class="sig-param">abs_wrap=True</em>, <em class="sig-param">strict=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Region"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Region" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">dasi.utils.region.Span</span></code></a></p>
<p>A direction span.</p>
<p>Initialize a new Region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – start position</p></li>
<li><p><strong>end</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – end position (exclusive)</p></li>
<li><p><strong>length</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – length of context</p></li>
<li><p><strong>cyclic</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – topology of context</p></li>
<li><p><strong>index</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – starting index of context</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – direction of the region</p></li>
<li><p><strong>name</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – name of the region</p></li>
<li><p><strong>region_id</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – id of the region</p></li>
<li><p><strong>strict</strong> (<em>bool</em>) – if True, positions outside of context bounds are disallowed.</p></li>
<li><p><strong>ignore_wrap</strong> (<em>bool</em>) – if True (default False), initialization indicies that wrap
around multiple times will
simply be mapped directly to the context (no wrapping used).</p></li>
<li><p><strong>abs_wrap</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, the abs difference between start and end wrappings
are used. Starting wraps that are greater than ending wraps
are valid. If False and the starting wrap is greater than
the ending wrap, an IndexError is thrown.</p></li>
</ul>
</dd>
</dl>
<p><strong>Attributes</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.a" title="dasi.utils.region.Region.a"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a</span></code></a></p></td>
<td><p>Return the inclusive mapped startpoint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.b" title="dasi.utils.region.Region.b"><code class="xref py py-obj docutils literal notranslate"><span class="pre">b</span></code></a></p></td>
<td><p>Return the exclusive mapped endpoint.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.c" title="dasi.utils.region.Region.c"><code class="xref py py-obj docutils literal notranslate"><span class="pre">c</span></code></a></p></td>
<td><p>Return the exclusive un-mapped endpoint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.context_length" title="dasi.utils.region.Region.context_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">context_length</span></code></a></p></td>
<td><p>Return the length of the context.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.cyclic" title="dasi.utils.region.Region.cyclic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cyclic</span></code></a></p></td>
<td><p>Return whether the context is cyclic/circular.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.index" title="dasi.utils.region.Region.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></p></td>
<td><p>Return the starting index of the context.</p></td>
</tr>
</tbody>
</table>
<p><strong>Methods</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.bounds" title="dasi.utils.region.Region.bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></a>()</p></td>
<td><p>Return the context bounds (end exclusive)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.connecting_span" title="dasi.utils.region.Region.connecting_span"><code class="xref py py-obj docutils literal notranslate"><span class="pre">connecting_span</span></code></a>(other)</p></td>
<td><p>Return the span that connects the two spans.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.consecutive" title="dasi.utils.region.Region.consecutive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">consecutive</span></code></a>(other)</p></td>
<td><p>Returns True if other span is immediately consecutive with this span.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.differences" title="dasi.utils.region.Region.differences"><code class="xref py py-obj docutils literal notranslate"><span class="pre">differences</span></code></a>(other)</p></td>
<td><p>Return a tuple of differences between this span and the other span.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.flip" title="dasi.utils.region.Region.flip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flip</span></code></a>()</p></td>
<td><p>Flip the indices of the region.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.force_context" title="dasi.utils.region.Region.force_context"><code class="xref py py-obj docutils literal notranslate"><span class="pre">force_context</span></code></a>(other)</p></td>
<td><p>Raise error if another Span has different context.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.get_slice" title="dasi.utils.region.Region.get_slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_slice</span></code></a>(x[, infer_type, as_type, …])</p></td>
<td><p>Use the region to slice the iterable, returning a iterable of the same type as ‘x’.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.get_slice_iter" title="dasi.utils.region.Region.get_slice_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_slice_iter</span></code></a>(x)</p></td>
<td><p>Use the region to slice the iterable, returning another generator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.i" title="dasi.utils.region.Region.i"><code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code></a>(p)</p></td>
<td><p>Find index of position.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.intersection" title="dasi.utils.region.Region.intersection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code></a>(other)</p></td>
<td><p>Return the span inersection between this span and the other span.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.invert" title="dasi.utils.region.Region.invert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code></a>()</p></td>
<td><p>Invert the region, returning a tuple of the remaining spans from the context.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.new" title="dasi.utils.region.Region.new"><code class="xref py py-obj docutils literal notranslate"><span class="pre">new</span></code></a>(a, b)</p></td>
<td><p>Create a new span using the same context.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.overlaps_with" title="dasi.utils.region.Region.overlaps_with"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlaps_with</span></code></a>(other)</p></td>
<td><p>Returns True if other span has an overlap with this span.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.ranges" title="dasi.utils.region.Region.ranges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ranges</span></code></a>([ignore_wraps])</p></td>
<td><p>Return the valid ranges for this span.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.reindex" title="dasi.utils.region.Region.reindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex</span></code></a>(i[, strict, ignore_wrap])</p></td>
<td><p>Return a new span with positions reindexed.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.same_context" title="dasi.utils.region.Region.same_context"><code class="xref py py-obj docutils literal notranslate"><span class="pre">same_context</span></code></a>(other)</p></td>
<td><p>Return if another Span as an equivalent context.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.slices" title="dasi.utils.region.Region.slices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slices</span></code></a>()</p></td>
<td><p>Return list of slices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Region.sub" title="dasi.utils.region.Region.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>(a, b)</p></td>
<td><p>Create a sub region starting from a to b.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Region.t" title="dasi.utils.region.Region.t"><code class="xref py py-obj docutils literal notranslate"><span class="pre">t</span></code></a>(p[, throw_error])</p></td>
<td><p>Translates a position ‘p’ to an index within the context bounds.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dasi.utils.region.Region.a">
<em class="property">property </em><code class="sig-name descname">a</code><a class="headerlink" href="#dasi.utils.region.Region.a" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inclusive mapped startpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.b">
<em class="property">property </em><code class="sig-name descname">b</code><a class="headerlink" href="#dasi.utils.region.Region.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.bounds">
<code class="sig-name descname">bounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the context bounds (end exclusive)</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.c">
<em class="property">property </em><code class="sig-name descname">c</code><a class="headerlink" href="#dasi.utils.region.Region.c" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive un-mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.connecting_span">
<code class="sig-name descname">connecting_span</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.connecting_span" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span that connects the two spans. Returns None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.consecutive">
<code class="sig-name descname">consecutive</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.consecutive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span is immediately consecutive with this
span.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.context_length">
<em class="property">property </em><code class="sig-name descname">context_length</code><a class="headerlink" href="#dasi.utils.region.Region.context_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.cyclic">
<em class="property">property </em><code class="sig-name descname">cyclic</code><a class="headerlink" href="#dasi.utils.region.Region.cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the context is cyclic/circular.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.differences">
<code class="sig-name descname">differences</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.differences" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of differences between this span and the other
span.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>, <a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>]]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.flip">
<code class="sig-name descname">flip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Region.flip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Region.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip the indices of the region.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#dasi.utils.region.Region" title="dasi.utils.region.Region"><code class="xref py py-class docutils literal notranslate"><span class="pre">Region</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.force_context">
<code class="sig-name descname">force_context</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.force_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise error if another Span has different context.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>) – The other span</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>SpanError</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.get_slice">
<code class="sig-name descname">get_slice</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">infer_type=False</em>, <em class="sig-param">as_type=None</em>, <em class="sig-param">summary_func=None</em>, <em class="sig-param">reduce_op=&lt;built-in function add&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.get_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the region to slice the iterable, returning a iterable of the
same type as ‘x’. If as_type is provided, the iterable will be
typecast.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[~T]) – the iterable to slice</p></li>
<li><p><strong>as_type</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code>]) – type to convert the iterable into</p></li>
<li><p><strong>summary_func</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>]) – summary function that takes in an interable. If none, uses
<cite>itertools.reduce(operator.add, arr)</cite></p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.get_slice_iter">
<code class="sig-name descname">get_slice_iter</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.get_slice_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the region to slice the iterable, returning another generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[~T]) – the iterable to slice</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterable</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.i">
<code class="sig-name descname">i</code><span class="sig-paren">(</span><em class="sig-param">p</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Find index of position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#dasi.utils.region.Region.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the starting index of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.intersection">
<code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span inersection between this span and the other span.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.invert">
<code class="sig-name descname">invert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the region, returning a tuple of the remaining spans from the
context. If cyclic, a tuple (span, None) tuple is returned. If linear,
a (span, span) is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>inverted regions</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.new">
<code class="sig-name descname">new</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Region.new"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Region.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new span using the same context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.overlaps_with">
<code class="sig-name descname">overlaps_with</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.overlaps_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span has an overlap with this span.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>) – The other span</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if the two spans overlap.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.ranges">
<code class="sig-name descname">ranges</code><span class="sig-paren">(</span><em class="sig-param">ignore_wraps=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the valid ranges for this span.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ignore_wraps</strong> – if True, multiple wrappings will be ignored.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>List[Tuple[int, int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.reindex">
<code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param">i</em>, <em class="sig-param">strict=None</em>, <em class="sig-param">ignore_wrap=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new span with positions reindexed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – new index</p></li>
<li><p><strong>strict</strong> – initialize with ‘strict’</p></li>
<li><p><strong>ignore_wrap</strong> – whether to ignore wrapping indices</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.same_context">
<code class="sig-name descname">same_context</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.same_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if another Span as an equivalent context.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.slices">
<code class="sig-name descname">slices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sub region starting from a to b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – starting pos</p></li>
<li><p><strong>b</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – ending pos</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a new Span.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Region.t">
<code class="sig-name descname">t</code><span class="sig-paren">(</span><em class="sig-param">p</em>, <em class="sig-param">throw_error=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.Region.t" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates a position ‘p’ to an index within the context bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – </p></li>
<li><p><strong>throw_error</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dasi.utils.region.Span">
<em class="property">class </em><code class="sig-prename descclassname">dasi.utils.region.</code><code class="sig-name descname">Span</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">l</em>, <em class="sig-param">cyclic=False</em>, <em class="sig-param">index=0</em>, <em class="sig-param">ignore_wrap=False</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">abs_wrap=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></p>
<p><cite>Span</cite> maps the provided positions onto a context.</p>
<p>Spans have no direction and have an underlying context
that has a certain length, can be linear or cyclic, and has a starting index.</p>
<p>The following attributes are accessible:</p>
<ul class="simple">
<li><p><cite>a</cite> - the starting (inclusive) position of the span</p></li>
<li><p><cite>b</cite> - the mapped exclusive position of the span</p></li>
<li><dl class="simple">
<dt><cite>c</cite> - the unmapped exclusive position of the span (used for cyclic spans that</dt><dd><p>wrap context multiple times)</p>
</dd>
</dl>
</li>
<li><p><cite>cyclic</cite> - whether the underlying context is circular or linear</p></li>
<li><p><cite>index</cite> - the first index of the context</p></li>
<li><p><cite>context_length</cite> - the length of the underlying context.</p></li>
</ul>
<p><strong>Attributes</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.a" title="dasi.utils.region.Span.a"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a</span></code></a></p></td>
<td><p>Return the inclusive mapped startpoint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.b" title="dasi.utils.region.Span.b"><code class="xref py py-obj docutils literal notranslate"><span class="pre">b</span></code></a></p></td>
<td><p>Return the exclusive mapped endpoint.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.c" title="dasi.utils.region.Span.c"><code class="xref py py-obj docutils literal notranslate"><span class="pre">c</span></code></a></p></td>
<td><p>Return the exclusive un-mapped endpoint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.context_length" title="dasi.utils.region.Span.context_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">context_length</span></code></a></p></td>
<td><p>Return the length of the context.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.cyclic" title="dasi.utils.region.Span.cyclic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cyclic</span></code></a></p></td>
<td><p>Return whether the context is cyclic/circular.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.index" title="dasi.utils.region.Span.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></p></td>
<td><p>Return the starting index of the context.</p></td>
</tr>
</tbody>
</table>
<p><strong>Methods</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.bounds" title="dasi.utils.region.Span.bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></a>()</p></td>
<td><p>Return the context bounds (end exclusive)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.connecting_span" title="dasi.utils.region.Span.connecting_span"><code class="xref py py-obj docutils literal notranslate"><span class="pre">connecting_span</span></code></a>(other)</p></td>
<td><p>Return the span that connects the two spans.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.consecutive" title="dasi.utils.region.Span.consecutive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">consecutive</span></code></a>(other)</p></td>
<td><p>Returns True if other span is immediately consecutive with this span.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.differences" title="dasi.utils.region.Span.differences"><code class="xref py py-obj docutils literal notranslate"><span class="pre">differences</span></code></a>(other)</p></td>
<td><p>Return a tuple of differences between this span and the other span.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.force_context" title="dasi.utils.region.Span.force_context"><code class="xref py py-obj docutils literal notranslate"><span class="pre">force_context</span></code></a>(other)</p></td>
<td><p>Raise error if another Span has different context.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.get_slice" title="dasi.utils.region.Span.get_slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_slice</span></code></a>(x[, infer_type, as_type, …])</p></td>
<td><p>Use the region to slice the iterable, returning a iterable of the same type as ‘x’.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.get_slice_iter" title="dasi.utils.region.Span.get_slice_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_slice_iter</span></code></a>(x)</p></td>
<td><p>Use the region to slice the iterable, returning another generator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.i" title="dasi.utils.region.Span.i"><code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code></a>(p)</p></td>
<td><p>Find index of position.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.intersection" title="dasi.utils.region.Span.intersection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code></a>(other)</p></td>
<td><p>Return the span inersection between this span and the other span.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.invert" title="dasi.utils.region.Span.invert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code></a>()</p></td>
<td><p>Invert the region, returning a tuple of the remaining spans from the context.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.new" title="dasi.utils.region.Span.new"><code class="xref py py-obj docutils literal notranslate"><span class="pre">new</span></code></a>(a, b[, ignore_wrap, index, strict, abs_wrap])</p></td>
<td><p>Create a new span using the same context.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.overlaps_with" title="dasi.utils.region.Span.overlaps_with"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlaps_with</span></code></a>(other)</p></td>
<td><p>Returns True if other span has an overlap with this span.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.ranges" title="dasi.utils.region.Span.ranges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ranges</span></code></a>([ignore_wraps])</p></td>
<td><p>Return the valid ranges for this span.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.reindex" title="dasi.utils.region.Span.reindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex</span></code></a>(i[, strict, ignore_wrap])</p></td>
<td><p>Return a new span with positions reindexed.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.same_context" title="dasi.utils.region.Span.same_context"><code class="xref py py-obj docutils literal notranslate"><span class="pre">same_context</span></code></a>(other)</p></td>
<td><p>Return if another Span as an equivalent context.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.slices" title="dasi.utils.region.Span.slices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slices</span></code></a>()</p></td>
<td><p>Return list of slices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasi.utils.region.Span.sub" title="dasi.utils.region.Span.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>(a, b)</p></td>
<td><p>Create a sub region starting from a to b.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasi.utils.region.Span.t" title="dasi.utils.region.Span.t"><code class="xref py py-obj docutils literal notranslate"><span class="pre">t</span></code></a>(p[, throw_error])</p></td>
<td><p>Translates a position ‘p’ to an index within the context bounds.</p></td>
</tr>
</tbody>
</table>
<p><strong>Linear spans</strong>
For example, a basic linear span can be represented using the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(0, 10, 20)
assert s.a == 0
assert s.b == 10
assert list(s) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  # spans are always
                                                  # exclusive at endpoint.
</pre></div>
</div>
<p><strong>Indexing and Slicing</strong></p>
<p>New indexes can be provided to spans.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(1, 10, 10, index=1)
assert s.a == 1
assert s.b == 10
</pre></div>
</div>
<p>Positions can be mapped to the span:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(5, 8, 10, index=5)
assert s.a == 5
assert s.b == 8
assert s[0] == 5    # the &#39;first&#39; position in the span equivalent to the
                    # starting index
assert s[-1] == 7   # the &#39;last&#39; position in the span is the last inclusive
                    # index
</pre></div>
</div>
<p>Positions can be mapped automatically during initialization:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(-1, 5, 10, cyclic=True, index=0)   # index &#39;-1&#39; is mapped onto last
                                            # available index on the context,
&#39;9&#39;
assert s.a == 9
assert s.b == 5

s = Span(6, -1, 10, cyclic=True, index=0)  # index &#39;-1&#39; is mapped onto last
                                           # available exclusive index on the
 context, &#39;10&#39;
assert s.a == 6
assert s.b == 10
</pre></div>
</div>
<p>Inclusive positions can be mapped onto the context using <cite>t</cite>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(-1, 5, 10, cyclic=True)
assert s.t(11) == 1
assert s.t(10) == 0
</pre></div>
</div>
<p><strong>Reindexing</strong></p>
<p>Context starting index can be remapped:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(0, 5, 10)
s1 = s.reindex(1)
asset s1.a == 1
assert s2.b == 6
</pre></div>
</div>
<p><strong>Slicing</strong></p>
<p>Spans can be sliced similarly to lists:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(4, 8, 10)
s1 = s[1:]
assert s1.a == 5
assert s2.b == 8

s2 = s[:-1]
assert s2.a == 4
assert s2.b == 7

s3 = s[2:-1]
assert s3.a == 5
assert s3.b == 7
</pre></div>
</div>
<p><strong>Cyclic spans</strong>
A cyclic span can be represented in the following way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(18, 2, 20, cyclic=True)
assert s.a == 18
assert s.b == 2
assert list(s) == [18, 19, 0, 1]
assert len(s) == 4
</pre></div>
</div>
<p><strong>Wrapping cyclic spans</strong>
Spans the wrap around the context multiple times can be represented as well.
The mapped endpoint
is found with <cite>span.b</cite> and the non-mapped endpoint is found using <cite>span.c</cite>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(9, 21, 10, cyclic=True)
assert list(s) == [9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
assert len(s) == 12
assert s.a == 9  # start point
assert s.b == 1  # mapped endpoint
assert s.c == 21 # the unmapped endpoint
</pre></div>
</div>
<p>The indices are reduced to their lowest ‘wrapping’ whenever possible.
For example, the following
initializations are equivalent:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s1 = Span(1, 5, 10, cyclic=True)
s2 = Span(11, 15, 10, cyclic=True)
s3 = Span(21, 25, 10, cyclic=True)
assert s1 == s2
assert s2 == s3
</pre></div>
</div>
<p><strong>Iterating through spans</strong></p>
<p>Spans can be treated like iterators:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for i in Span(5, 3, 10, cyclic=True):
    print(i)
</pre></div>
</div>
<p><strong>Span inversion</strong></p>
<p>Inversion returns two spans that represent everything <em>except</em> the span:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = Span(4, 8, 10)
s1, s2 = s.invert()  # also s[::-1]
assert s1.a == 0
assert s1.b == 4
assert s2.a == 8
assert s2.b == 10

# inverted cyclic span returns one valid span and None
s = Span(4, 8, 10, cyclic=True)
s1, s2 = s.invert()
assert s1.a == 8
assert s1.b == 4
assert s2 is None
</pre></div>
</div>
<p><strong>Intersections, differences</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s1 = Span(4, 10, 20)
s2 = Span(8, 12, 20)
s3 = s1.intersection(s2)
assert s3.a == 8
assert s3.b == 10
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s1 = Span(4, 10, 20)
s2 = Span(8, 12, 20)
s3, s4 = s1.differences(s2)

assert s3.a, s3.b == 4, 8
assert s4,a, s4.b == 10, 12
</pre></div>
</div>
<p>Constructs a new Span. There are several options to customize the
initialization procedure.</p>
<p><strong>strict=True</strong></p>
<p>When strict, any index outside the valid bounds of the context raises an
IndexError.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Span(1, 10, 10, cyclic=True, strict=True) # no raise
Span(1, 11, 10, cyclic=True, strict=True) # raises IndexError
Span(0, 11, 10, index=1, cyclic=True, strict=True) # raises IndexError
</pre></div>
</div>
<p><strong>ignore_wrap=True</strong></p>
<p>When wrapping is ignored, indices are simply mapped to the context with no
consideration
of the number of times the absolute position would wrap around the context.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># all of the following are equivalent with ignore_wrap == True
Span(1, 10, 10, cyclic=True, ignore_wrap=True)
Span(1+10, 10, 10, cyclic=True, ignore_wrap=True)
Span(1, 10-100, 10, cyclic=True, ignore_wrap=True)
Span(1+20, 10-100, 10, cyclic=True, ignore_wrap=True)
</pre></div>
</div>
<p><strong>abs_wrap=True</strong></p>
<p>When absolute wrapping is used, the absolute difference between starting and
ending index wrappings
is calculated, the starting index is to the context while the ending index is
adjusted such
that the length will reflect the abs difference between starting and ending
index wrappings.
This can be unintuitive
is best shown with the following example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># all of the following initializations result in equivalent spans

# starts at 1, wraps around one full time, ends at 5.
# Length is 15 - 1
s1 = Span(1, 15, 10, cyclic=True, abs_wrap=True)
assert len(s1) == 14

# starts at 11, wraps around one full time, ends at 15.
# Then positions are mapped back to context at 1 and 5.
# Length is still 25 - 11 == 14
s2 = Span(11, 25, 10, cyclic=True, abs_wrap=True)
assert len(s2) == 14

# starts at 11, wraps around one full time, ends at 15.
# Then positions are mapped back to context at 1 and 5.
# Length is now 11 + 5 = 14
s3 = Span(11, 5, 10, cyclic=True, abs_wrap=True)
assert len(s3) == 14

# the lengths change with the abs diff in number of times wrapped
_s = Span(21, 5, 10, cyclic=True, abs_wrap=True)
assert len(_s) == 24

_s = Span(21, 15, 10, cyclic=True, abs_wrap=True)
assert len(_s) == 14

# all
assert s1 == s2
assert s2 == s3
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>int</em>) – start of the span (inclusive)</p></li>
<li><p><strong>b</strong> (<em>int</em>) – end of the span (exclusive)</p></li>
<li><p><strong>l</strong> (<em>int</em>) – context length of the region</p></li>
<li><p><strong>cyclic</strong> (<em>bool</em>) – whether the underlying context is cyclic</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the starting index of the region</p></li>
<li><p><strong>strict</strong> (<em>bool</em>) – if True, positions outside of context bounds are disallowed.</p></li>
<li><p><strong>ignore_wrap</strong> (<em>bool</em>) – if True (default False), initialization indicies that wrap
around multiple times will
simply be mapped directly to the context (no wrapping used).</p></li>
<li><p><strong>abs_wrap</strong> – if True, the abs difference between start and end wrappings
are used. Starting wraps that are greater than ending wraps
are valid. If False and the starting wrap is greater than
the ending wrap, an IndexError is thrown.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="dasi.utils.region.Span.a">
<em class="property">property </em><code class="sig-name descname">a</code><a class="headerlink" href="#dasi.utils.region.Span.a" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inclusive mapped startpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.b">
<em class="property">property </em><code class="sig-name descname">b</code><a class="headerlink" href="#dasi.utils.region.Span.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.bounds">
<code class="sig-name descname">bounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the context bounds (end exclusive)</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.c">
<em class="property">property </em><code class="sig-name descname">c</code><a class="headerlink" href="#dasi.utils.region.Span.c" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exclusive un-mapped endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.connecting_span">
<code class="sig-name descname">connecting_span</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.connecting_span"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.connecting_span" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span that connects the two spans. Returns None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.consecutive">
<code class="sig-name descname">consecutive</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.consecutive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.consecutive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span is immediately consecutive with this
span.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.context_length">
<em class="property">property </em><code class="sig-name descname">context_length</code><a class="headerlink" href="#dasi.utils.region.Span.context_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.cyclic">
<em class="property">property </em><code class="sig-name descname">cyclic</code><a class="headerlink" href="#dasi.utils.region.Span.cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the context is cyclic/circular.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.differences">
<code class="sig-name descname">differences</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.differences"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.differences" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of differences between this span and the other
span.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>, <a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>]]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.force_context">
<code class="sig-name descname">force_context</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.force_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.force_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise error if another Span has different context.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>) – The other span</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>SpanError</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.get_slice">
<code class="sig-name descname">get_slice</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">infer_type=False</em>, <em class="sig-param">as_type=None</em>, <em class="sig-param">summary_func=None</em>, <em class="sig-param">reduce_op=&lt;built-in function add&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.get_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.get_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the region to slice the iterable, returning a iterable of the
same type as ‘x’. If as_type is provided, the iterable will be
typecast.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[~T]) – the iterable to slice</p></li>
<li><p><strong>as_type</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code>]) – type to convert the iterable into</p></li>
<li><p><strong>summary_func</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>]) – summary function that takes in an interable. If none, uses
<cite>itertools.reduce(operator.add, arr)</cite></p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.get_slice_iter">
<code class="sig-name descname">get_slice_iter</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.get_slice_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.get_slice_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the region to slice the iterable, returning another generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[~T]) – the iterable to slice</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterable</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.i">
<code class="sig-name descname">i</code><span class="sig-paren">(</span><em class="sig-param">p</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.i"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Find index of position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#dasi.utils.region.Span.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the starting index of the context.</p>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.intersection">
<code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.intersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span inersection between this span and the other span.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.invert">
<code class="sig-name descname">invert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.invert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the region, returning a tuple of the remaining spans from the
context. If cyclic, a tuple (span, None) tuple is returned. If linear,
a (span, span) is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>inverted regions</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.new">
<code class="sig-name descname">new</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">ignore_wrap=None</em>, <em class="sig-param">index=None</em>, <em class="sig-param">strict=None</em>, <em class="sig-param">abs_wrap=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.new"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new span using the same context.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.overlaps_with">
<code class="sig-name descname">overlaps_with</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.overlaps_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.overlaps_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if other span has an overlap with this span.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>) – The other span</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if the two spans overlap.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.ranges">
<code class="sig-name descname">ranges</code><span class="sig-paren">(</span><em class="sig-param">ignore_wraps=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.ranges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the valid ranges for this span.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ignore_wraps</strong> – if True, multiple wrappings will be ignored.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>List[Tuple[int, int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.reindex">
<code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param">i</em>, <em class="sig-param">strict=None</em>, <em class="sig-param">ignore_wrap=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.reindex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new span with positions reindexed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – new index</p></li>
<li><p><strong>strict</strong> – initialize with ‘strict’</p></li>
<li><p><strong>ignore_wrap</strong> – whether to ignore wrapping indices</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.same_context">
<code class="sig-name descname">same_context</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.same_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.same_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if another Span as an equivalent context.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.slices">
<code class="sig-name descname">slices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.slices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.sub"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sub region starting from a to b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – starting pos</p></li>
<li><p><strong>b</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – ending pos</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#dasi.utils.region.Span" title="dasi.utils.region.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a new Span.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dasi.utils.region.Span.t">
<code class="sig-name descname">t</code><span class="sig-paren">(</span><em class="sig-param">p</em>, <em class="sig-param">throw_error=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dasi/utils/region.html#Span.t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.Span.t" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates a position ‘p’ to an index within the context bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – </p></li>
<li><p><strong>throw_error</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="dasi.utils.region.SpanError">
<em class="property">exception </em><code class="sig-prename descclassname">dasi.utils.region.</code><code class="sig-name descname">SpanError</code><a class="reference internal" href="../_modules/dasi/utils/region.html#SpanError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dasi.utils.region.SpanError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<dl class="method">
<dt id="dasi.utils.region.SpanError.with_traceback">
<code class="sig-name descname">with_traceback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dasi.utils.region.SpanError.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>